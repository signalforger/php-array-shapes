diff --git a/README.md b/README.md
index 5b8ec6f0..186473f3 100644
--- a/README.md
+++ b/README.md
@@ -14,6 +14,306 @@ web development. Fast, flexible and pragmatic, PHP powers everything from your
 blog to the most popular websites in the world. PHP is distributed under the
 [PHP License v3.01](LICENSE).
 
+---
+
+## Typed Arrays & Array Shapes RFC Implementation
+
+This fork implements **Typed Arrays** and **Array Shapes** for PHP—two complementary features that bring type safety to PHP's most versatile data structure.
+
+### The Problem
+
+PHP arrays are incredibly flexible, serving as lists, dictionaries, and structured records. But this flexibility comes at a cost: no way to express or enforce what an array should contain.
+
+```php
+function getUsers(): array {
+    // What's in this array? Objects? Associative arrays? Integers?
+    // The type system can't tell you.
+}
+```
+
+### The Solution: Two Complementary Features
+
+#### Typed Arrays — For Collections
+
+When you have a **list of things of the same type**, use typed arrays:
+
+```php
+// A list of integers
+function getIds(): array<int> {
+    return [1, 2, 3];
+}
+
+// A list of User objects
+function getActiveUsers(): array<User> {
+    return $this->repository->findActive();
+}
+
+// A dictionary with string keys and integer values
+function getScores(): array<string, int> {
+    return ['alice' => 95, 'bob' => 87, 'charlie' => 92];
+}
+```
+
+This is what you reach for when working with collections—arrays where every element is the same kind of thing.
+
+#### Array Shapes — For Structured Data
+
+When you have **structured data with known keys**, like records from a database or responses from an API, use array shapes:
+
+```php
+// Data from a database row
+function getUser(int $id): array{id: int, name: string, email: string} {
+    return $this->db->fetch("SELECT id, name, email FROM users WHERE id = ?", $id);
+}
+
+// Response from an external API
+function getWeather(string $city): array{temp: float, humidity: int, conditions: string} {
+    return json_decode(file_get_contents("https://api.weather.com/$city"), true);
+}
+```
+
+### Real-World Examples
+
+#### Working with Database Results
+
+```php
+// Define the shape of a user record
+shape UserRecord = array{
+    id: int,
+    name: string,
+    email: string,
+    created_at: string,
+    is_active?: bool
+};
+
+class UserRepository {
+    // Single record
+    public function find(int $id): ?UserRecord {
+        return $this->db->fetch("SELECT * FROM users WHERE id = ?", $id);
+    }
+
+    // Collection of records — combining both features!
+    public function findAll(): array<UserRecord> {
+        return $this->db->fetchAll("SELECT * FROM users");
+    }
+}
+```
+
+#### Working with API Responses
+
+```php
+// Shape describing the API response structure
+shape ApiResponse = array{
+    success: bool,
+    data: mixed,
+    error?: string,
+    meta?: array{page: int, total: int}
+};
+
+shape ProductData = array{
+    id: int,
+    name: string,
+    price: float,
+    tags: array<string>     // Nested typed array!
+};
+
+function fetchProduct(int $id): ProductData {
+    $response = $this->http->get("/api/products/$id");
+    return $response['data'];
+}
+
+function fetchProducts(): array<ProductData> {
+    $response = $this->http->get("/api/products");
+    return $response['data'];
+}
+```
+
+#### Configuration Arrays
+
+```php
+shape DatabaseConfig = array{
+    host: string,
+    port: int,
+    database: string,
+    username: string,
+    password: string,
+    options?: array<string, mixed>
+};
+
+shape AppConfig = array{
+    debug: bool,
+    env: string,
+    database: DatabaseConfig,
+    cache_ttl?: int
+};
+
+function loadConfig(string $path): AppConfig {
+    return require $path;
+}
+```
+
+### This is NOT About DTOs
+
+A common misconception: "Why not just use classes/DTOs?"
+
+**These features work with arrays, not objects.** They're designed for the many situations where arrays are the right tool:
+
+- **Database results** — PDO and other drivers return arrays
+- **JSON APIs** — `json_decode()` returns arrays
+- **Configuration files** — Often loaded as arrays
+- **Legacy code** — Millions of lines of PHP use arrays for structured data
+- **Interoperability** — Arrays are PHP's universal data interchange format
+
+You don't have to choose between arrays and objects. Use objects when you need behavior (methods), use typed arrays when you're working with data.
+
+```php
+// Arrays for data from external sources
+function getApiUser(): array{id: int, name: string} {
+    return json_decode($response, true);
+}
+
+// Objects when you need behavior
+class User {
+    public function __construct(
+        public int $id,
+        public string $name
+    ) {}
+
+    public function greet(): string {
+        return "Hello, {$this->name}!";
+    }
+}
+```
+
+### Quick Reference
+
+```php
+// Typed arrays — for collections
+array<int>                     // List of integers
+array<string>                  // List of strings
+array<User>                    // List of User objects
+array<int|string>              // List of integers or strings
+array<string, int>             // Dictionary: string keys, int values
+array<array<int>>              // List of integer lists
+
+// Array shapes — for structured data
+array{id: int, name: string}   // Required keys
+array{id: int, email?: string} // Optional key (may be absent)
+array{data: ?string}           // Nullable value (can be null)
+array{user: array{id: int}}    // Nested shapes
+array{id: int, name: string}!  // Closed shape (no extra keys allowed)
+
+// Shape type aliases — for reusability
+shape User = array{id: int, name: string};
+shape Point = array{x: int, y: int};
+shape Config = array{debug: bool, cache?: int};
+
+// Shape inheritance
+shape BaseUser = array{id: int, name: string};
+shape AdminUser extends BaseUser = array{role: string, permissions: array<string>};
+```
+
+### Shape Inheritance
+
+Shapes support single inheritance with type covariance:
+
+```php
+shape Entity = array{id: int, created_at: string};
+shape User extends Entity = array{name: string, email: string};
+shape Admin extends User = array{role: string, permissions: array<string>};
+
+// Admin inherits all fields: id, created_at, name, email, role, permissions
+function getAdmin(): Admin {
+    return [
+        'id' => 1,
+        'created_at' => '2024-01-01',
+        'name' => 'Alice',
+        'email' => 'alice@example.com',
+        'role' => 'superadmin',
+        'permissions' => ['read', 'write', 'delete']
+    ];
+}
+```
+
+**Covariance rules:**
+- Child shapes can narrow parent types (e.g., `string|int` → `string`)
+- Child shapes cannot widen types (e.g., `string` → `int` is rejected)
+- Child shapes can make optional properties required
+- Child shapes cannot make required properties optional
+
+### Closed Shapes
+
+By default, shapes are "open" — they allow extra keys beyond what's defined. Use the `!` suffix for closed shapes that reject extra keys:
+
+```php
+// Open shape (default) — extra keys allowed
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'allowed'];  // OK
+}
+
+// Closed shape — no extra keys allowed
+function getStrictUser(): array{id: int, name: string}! {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'forbidden'];
+    // TypeError: unexpected extra key "extra"
+}
+```
+
+### Error Messages
+
+When validation fails, you get clear error messages:
+
+```php
+function getIds(): array<int> {
+    return [1, "two", 3];
+}
+// TypeError: getIds(): Return value must be of type array<int>,
+//            array element at index 1 is string
+
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1];
+}
+// TypeError: getUser(): Return value must be of type array{name: string, ...},
+//            array given with missing key "name"
+```
+
+### Shape Autoloading
+
+Shapes can be autoloaded like classes, keeping your codebase organized:
+
+```php
+// shapes/UserRecord.php
+<?php
+shape UserRecord = array{id: int, name: string, email: string};
+
+// Somewhere else in your code
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) require_once $file;
+});
+
+// UserRecord is autoloaded when first used
+function getUser(): UserRecord { ... }
+```
+
+### Implementation Status
+
+- [x] Typed arrays: `array<T>`, `array<K, V>`
+- [x] Array shapes: `array{key: type}`
+- [x] Optional keys: `array{key?: type}`
+- [x] Nullable values: `array{key: ?type}`
+- [x] Union types: `array<int|string>`
+- [x] Nested structures: `array<array<int>>`, `array{user: array{id: int}}`
+- [x] Shape type aliases: `shape Name = array{...}`
+- [x] Shape inheritance: `shape Child extends Parent = array{...}`
+- [x] Type covariance validation for shape inheritance
+- [x] Closed shapes: `array{...}!` (reject extra keys)
+- [x] Shape autoloading via `spl_autoload_register()`
+- [x] Reflection API support (`ReflectionArrayType`, `ReflectionArrayShapeType`)
+- [x] Runtime validation with detailed error messages
+- [x] Performance optimizations (string interning, cached key lookups)
+
+---
+
 [![Push](https://github.com/php/php-src/actions/workflows/push.yml/badge.svg)](https://github.com/php/php-src/actions/workflows/push.yml)
 [![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/php.svg)](https://issues.oss-fuzz.com/issues?q=project:php)
 
diff --git a/Zend/tests/get_class_methods/bug32296.phpt b/Zend/tests/get_class_methods/bug32296.phpt
index 16914a71..612fab16 100644
--- a/Zend/tests/get_class_methods/bug32296.phpt
+++ b/Zend/tests/get_class_methods/bug32296.phpt
@@ -7,12 +7,12 @@ function __construct(){}
     abstract protected function unfold();
 }
 
-abstract class shape extends space{
+abstract class polygon extends space{
     private function x1() {}
     protected final function unfold(){}
 }
 
-abstract class quad extends shape{
+abstract class quad extends polygon{
     private function x2() {}
     function buggy(){
         $c = get_class($this);
diff --git a/Zend/tests/type_declarations/array_shapes/class_cannot_extend_shape.phpt b/Zend/tests/type_declarations/array_shapes/class_cannot_extend_shape.phpt
new file mode 100644
index 00000000..74898cf6
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/class_cannot_extend_shape.phpt
@@ -0,0 +1,13 @@
+--TEST--
+Class cannot extend a shape
+--FILE--
+<?php
+
+shape MyShape = array{id: int, name: string};
+
+class BadClass extends MyShape {
+}
+
+?>
+--EXPECTF--
+Fatal error: Class BadClass cannot extend shape MyShape in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/class_method.phpt b/Zend/tests/type_declarations/array_shapes/class_method.phpt
new file mode 100644
index 00000000..6e6047f6
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/class_method.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Array shape in class methods
+--XLEAK--
+--FILE--
+<?php
+
+class UserService {
+    public function createUser(array{name: string, email: string} $data): array{id: int, name: string, email: string} {
+        return [
+            'id' => 1,
+            'name' => $data['name'],
+            'email' => $data['email']
+        ];
+    }
+}
+
+$service = new UserService();
+$user = $service->createUser(['name' => 'Alice', 'email' => 'alice@example.com']);
+echo "Created user: {$user['name']} (ID: {$user['id']})\n";
+
+?>
+--EXPECT--
+Created user: Alice (ID: 1)
diff --git a/Zend/tests/type_declarations/array_shapes/closed_shape_basic.phpt b/Zend/tests/type_declarations/array_shapes/closed_shape_basic.phpt
new file mode 100644
index 00000000..e147be7e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/closed_shape_basic.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Closed array shape - basic validation
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+// Closed shape: no extra keys allowed
+function getUser(): array{id: int, name: string}! {
+    return ['id' => 1, 'name' => 'Alice'];
+}
+
+$user = getUser();
+var_dump($user);
+
+// Verify reflection
+$ref = new ReflectionFunction('getUser');
+$type = $ref->getReturnType();
+var_dump($type->isClosed());
+echo $type . "\n";
+
+?>
+--EXPECTF--
+array(2) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(5) "Alice"
+}
+bool(true)
+array{id: int, name: string}!%A
diff --git a/Zend/tests/type_declarations/array_shapes/closed_shape_extra_key_error.phpt b/Zend/tests/type_declarations/array_shapes/closed_shape_extra_key_error.phpt
new file mode 100644
index 00000000..2bc0a2ed
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/closed_shape_extra_key_error.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Closed array shape - extra key error
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+function getUser(): array{id: int, name: string}! {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'not allowed'];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+getUser(): Return value must be of type closed shape, unexpected extra key "extra"%A
diff --git a/Zend/tests/type_declarations/array_shapes/closed_shape_param.phpt b/Zend/tests/type_declarations/array_shapes/closed_shape_param.phpt
new file mode 100644
index 00000000..5163dc52
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/closed_shape_param.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Closed array shape - parameter type
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+function processUser(array{id: int, name: string}! $user): void {
+    echo "Processing user: " . $user['name'] . "\n";
+}
+
+// Valid: exact match
+processUser(['id' => 1, 'name' => 'Alice']);
+
+// Invalid: extra key
+try {
+    processUser(['id' => 2, 'name' => 'Bob', 'extra' => 'data']);
+} catch (TypeError $e) {
+    echo $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Processing user: Alice
+processUser(): Argument #1 ($user) must be of type closed shape, unexpected extra key "extra"%A
diff --git a/Zend/tests/type_declarations/array_shapes/open_shape_extra_keys.phpt b/Zend/tests/type_declarations/array_shapes/open_shape_extra_keys.phpt
new file mode 100644
index 00000000..c915464e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/open_shape_extra_keys.phpt
@@ -0,0 +1,35 @@
+--TEST--
+Open array shape - extra keys allowed (default)
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+// Open shape (default): extra keys are allowed
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'allowed', 'more' => 'data'];
+}
+
+$user = getUser();
+var_dump($user);
+
+// Verify reflection shows not closed
+$ref = new ReflectionFunction('getUser');
+$type = $ref->getReturnType();
+var_dump($type->isClosed());
+echo $type . "\n";
+
+?>
+--EXPECTF--
+array(4) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(5) "Alice"
+  ["extra"]=>
+  string(7) "allowed"
+  ["more"]=>
+  string(4) "data"
+}
+bool(false)
+array{id: int, name: string}%A
diff --git a/Zend/tests/type_declarations/array_shapes/param_basic.phpt b/Zend/tests/type_declarations/array_shapes/param_basic.phpt
new file mode 100644
index 00000000..28bbadde
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/param_basic.phpt
@@ -0,0 +1,19 @@
+--TEST--
+Array shape as parameter type - basic validation
+--FILE--
+<?php
+
+function processPoint(array{x: int, y: int} $point): int {
+    return $point['x'] + $point['y'];
+}
+
+// Valid call
+echo processPoint(['x' => 10, 'y' => 20]) . "\n";
+
+// Extra keys are allowed (open shapes)
+echo processPoint(['x' => 5, 'y' => 15, 'z' => 100]) . "\n";
+
+?>
+--EXPECT--
+30
+20
diff --git a/Zend/tests/type_declarations/array_shapes/param_missing_key.phpt b/Zend/tests/type_declarations/array_shapes/param_missing_key.phpt
new file mode 100644
index 00000000..45673817
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/param_missing_key.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Array shape as parameter type - missing required key
+--FILE--
+<?php
+
+function processPoint(array{x: int, y: int} $point): int {
+    return $point['x'] + $point['y'];
+}
+
+try {
+    processPoint(['x' => 10]);
+} catch (TypeError $e) {
+    echo "TypeError: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECT--
+TypeError: processPoint(): Argument #1 ($point) must be of type array{y: int, ...}, array given with missing key "y"
diff --git a/Zend/tests/type_declarations/array_shapes/param_nested_shape.phpt b/Zend/tests/type_declarations/array_shapes/param_nested_shape.phpt
new file mode 100644
index 00000000..ead95d7c
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/param_nested_shape.phpt
@@ -0,0 +1,26 @@
+--TEST--
+Array shape as parameter type - nested shapes
+--XLEAK--
+--FILE--
+<?php
+
+function processUser(array{
+    id: int,
+    profile: array{name: string, email: string}
+} $user): string {
+    return $user['profile']['name'] . ' <' . $user['profile']['email'] . '>';
+}
+
+$user = [
+    'id' => 1,
+    'profile' => [
+        'name' => 'Alice',
+        'email' => 'alice@example.com'
+    ]
+];
+
+echo processUser($user) . "\n";
+
+?>
+--EXPECT--
+Alice <alice@example.com>
diff --git a/Zend/tests/type_declarations/array_shapes/param_optional_keys.phpt b/Zend/tests/type_declarations/array_shapes/param_optional_keys.phpt
new file mode 100644
index 00000000..cc395e26
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/param_optional_keys.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Array shape as parameter type - optional keys
+--XLEAK--
+--FILE--
+<?php
+
+function processConfig(array{host: string, port?: int, ssl?: bool} $config): string {
+    $result = $config['host'];
+    if (isset($config['port'])) {
+        $result .= ':' . $config['port'];
+    }
+    if (isset($config['ssl']) && $config['ssl']) {
+        $result = 'https://' . $result;
+    } else {
+        $result = 'http://' . $result;
+    }
+    return $result;
+}
+
+// Only required key
+echo processConfig(['host' => 'localhost']) . "\n";
+
+// With optional port
+echo processConfig(['host' => 'example.com', 'port' => 8080]) . "\n";
+
+// With all keys
+echo processConfig(['host' => 'secure.com', 'port' => 443, 'ssl' => true]) . "\n";
+
+?>
+--EXPECT--
+http://localhost
+http://example.com:8080
+https://secure.com:443
diff --git a/Zend/tests/type_declarations/array_shapes/param_typed_array.phpt b/Zend/tests/type_declarations/array_shapes/param_typed_array.phpt
new file mode 100644
index 00000000..17b0741b
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/param_typed_array.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Typed array as parameter type - array<T>
+--FILE--
+<?php
+
+function sumNumbers(array<int> $numbers): int {
+    return array_sum($numbers);
+}
+
+function joinStrings(array<string> $strings): string {
+    return implode(', ', $strings);
+}
+
+echo sumNumbers([1, 2, 3, 4, 5]) . "\n";
+echo joinStrings(['a', 'b', 'c']) . "\n";
+
+?>
+--EXPECT--
+15
+a, b, c
diff --git a/Zend/tests/type_declarations/array_shapes/param_typed_array_error.phpt b/Zend/tests/type_declarations/array_shapes/param_typed_array_error.phpt
new file mode 100644
index 00000000..e3234569
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/param_typed_array_error.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Typed array as parameter type - wrong element type
+--FILE--
+<?php
+
+function sumNumbers(array<int> $numbers): int {
+    return array_sum($numbers);
+}
+
+try {
+    sumNumbers([1, 2, 'three', 4]);
+} catch (TypeError $e) {
+    echo "TypeError: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECT--
+TypeError: sumNumbers(): Argument #1 ($numbers) must be of type array<int>, array element at index 2 is string
diff --git a/Zend/tests/type_declarations/array_shapes/param_wrong_type.phpt b/Zend/tests/type_declarations/array_shapes/param_wrong_type.phpt
new file mode 100644
index 00000000..5e1159a0
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/param_wrong_type.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Array shape as parameter type - wrong value type
+--FILE--
+<?php
+
+function processPoint(array{x: int, y: int} $point): int {
+    return $point['x'] + $point['y'];
+}
+
+try {
+    processPoint(['x' => 10, 'y' => 'not an int']);
+} catch (TypeError $e) {
+    echo "TypeError: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECT--
+TypeError: processPoint(): Argument #1 ($point) must be of type array{y: int, ...}, array key "y" is string
diff --git a/Zend/tests/type_declarations/array_shapes/return_basic.phpt b/Zend/tests/type_declarations/array_shapes/return_basic.phpt
new file mode 100644
index 00000000..a346d6ed
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/return_basic.phpt
@@ -0,0 +1,15 @@
+--TEST--
+Array shape as return type - basic validation
+--FILE--
+<?php
+
+function getPoint(): array{x: int, y: int} {
+    return ['x' => 10, 'y' => 20];
+}
+
+$point = getPoint();
+echo "x={$point['x']}, y={$point['y']}\n";
+
+?>
+--EXPECT--
+x=10, y=20
diff --git a/Zend/tests/type_declarations/array_shapes/return_missing_key.phpt b/Zend/tests/type_declarations/array_shapes/return_missing_key.phpt
new file mode 100644
index 00000000..996382a1
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/return_missing_key.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Array shape as return type - missing required key
+--FILE--
+<?php
+
+function getPoint(): array{x: int, y: int} {
+    return ['x' => 10];
+}
+
+try {
+    getPoint();
+} catch (TypeError $e) {
+    echo "TypeError: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECT--
+TypeError: getPoint(): Return value must be of type array{y: int, ...}, array given with missing key "y"
diff --git a/Zend/tests/type_declarations/array_shapes/shape_autoload.phpt b/Zend/tests/type_declarations/array_shapes/shape_autoload.phpt
new file mode 100644
index 00000000..9b995411
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_autoload.phpt
@@ -0,0 +1,42 @@
+--TEST--
+Shape type alias autoloading
+--XLEAK--
+--FILE--
+<?php
+
+// Create temporary shape file
+$tempDir = sys_get_temp_dir() . '/php_shape_autoload_test_' . getmypid();
+mkdir($tempDir);
+file_put_contents($tempDir . '/User.php', '<?php
+shape User = array{id: int, name: string};
+');
+
+$autoloaded = [];
+spl_autoload_register(function($class) use ($tempDir, &$autoloaded) {
+    $autoloaded[] = $class;
+    $file = "$tempDir/$class.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// Shape should not exist before autoload
+var_dump(shape_exists('User', false));
+
+// Trigger autoload via shape_exists
+var_dump(shape_exists('User', true));
+
+// Verify autoloader was called
+var_dump($autoloaded);
+
+// Clean up
+unlink($tempDir . '/User.php');
+rmdir($tempDir);
+?>
+--EXPECT--
+bool(false)
+bool(true)
+array(1) {
+  [0]=>
+  string(4) "User"
+}
diff --git a/Zend/tests/type_declarations/array_shapes/shape_autoload_type_checking.phpt b/Zend/tests/type_declarations/array_shapes/shape_autoload_type_checking.phpt
new file mode 100644
index 00000000..dcd49b17
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_autoload_type_checking.phpt
@@ -0,0 +1,46 @@
+--TEST--
+Shape type alias autoloading with type checking
+--XLEAK--
+--FILE--
+<?php
+
+// Create temporary shape file
+$tempDir = sys_get_temp_dir() . '/php_shape_autoload_test_' . getmypid();
+mkdir($tempDir);
+file_put_contents($tempDir . '/User.php', '<?php
+shape User = array{id: int, name: string};
+');
+
+spl_autoload_register(function($class) use ($tempDir) {
+    $file = "$tempDir/$class.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// Define function using the shape type
+function getUser(): User {
+    return ["id" => 1, "name" => "Alice"];
+}
+
+function processUser(User $user): void {
+    echo "Processing user: {$user['name']}\n";
+}
+
+// Use the functions - should trigger autoload and work correctly
+$user = getUser();
+var_dump($user);
+processUser($user);
+
+// Clean up
+unlink($tempDir . '/User.php');
+rmdir($tempDir);
+?>
+--EXPECT--
+array(2) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(5) "Alice"
+}
+Processing user: Alice
diff --git a/Zend/tests/type_declarations/array_shapes/shape_cannot_extend_class.phpt b/Zend/tests/type_declarations/array_shapes/shape_cannot_extend_class.phpt
new file mode 100644
index 00000000..cd3d9771
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_cannot_extend_class.phpt
@@ -0,0 +1,11 @@
+--TEST--
+Shape cannot extend a class
+--FILE--
+<?php
+
+class MyClass {}
+shape BadShape extends MyClass = array{id: int};
+
+?>
+--EXPECTF--
+Fatal error: Shape BadShape cannot extend class MyClass in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_cross_file.phpt b/Zend/tests/type_declarations/array_shapes/shape_cross_file.phpt
new file mode 100644
index 00000000..8ec49401
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_cross_file.phpt
@@ -0,0 +1,44 @@
+--TEST--
+Shape type alias cross-file usage via require
+--XLEAK--
+--FILE--
+<?php
+// Create temporary shape file
+$tempDir = sys_get_temp_dir() . '/php_shape_test_' . getmypid();
+mkdir($tempDir);
+file_put_contents($tempDir . '/shapes.php', '<?php
+shape User = array{id: int, name: string};
+shape Address = array{street: string, city: string};
+');
+
+$mainCode = <<<'MAIN'
+<?php
+require_once "%s/shapes.php";
+
+function getUser(): User {
+    return ["id" => 1, "name" => "Bob"];
+}
+
+function getAddress(): Address {
+    return ["street" => "123 Main St", "city" => "NYC"];
+}
+
+$user = getUser();
+$address = getAddress();
+
+echo "User: " . $user["name"] . "\n";
+echo "Address: " . $address["street"] . ", " . $address["city"] . "\n";
+MAIN;
+
+file_put_contents($tempDir . '/main.php', sprintf($mainCode, $tempDir));
+
+include $tempDir . '/main.php';
+
+// Clean up
+unlink($tempDir . '/shapes.php');
+unlink($tempDir . '/main.php');
+rmdir($tempDir);
+?>
+--EXPECT--
+User: Bob
+Address: 123 Main St, NYC
diff --git a/Zend/tests/type_declarations/array_shapes/shape_exists.phpt b/Zend/tests/type_declarations/array_shapes/shape_exists.phpt
new file mode 100644
index 00000000..0d26b73e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_exists.phpt
@@ -0,0 +1,32 @@
+--TEST--
+shape_exists() function
+--XLEAK--
+--FILE--
+<?php
+
+// Before defining shape
+var_dump(shape_exists('Point', false));
+var_dump(shape_exists('NonExistent', false));
+
+// Define a shape
+shape Point = array{x: int, y: int};
+
+// After defining shape
+var_dump(shape_exists('Point', false));
+var_dump(shape_exists('point', false));  // Case-insensitive
+var_dump(shape_exists('POINT', false));  // Case-insensitive
+var_dump(shape_exists('NonExistent', false));
+
+// With autoload parameter (should still work without autoloader)
+var_dump(shape_exists('Point', true));
+var_dump(shape_exists('NonExistent', true));
+?>
+--EXPECT--
+bool(true)
+bool(false)
+bool(true)
+bool(true)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_basic.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_basic.phpt
new file mode 100644
index 00000000..a06641f2
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_basic.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Shape inheritance - basic extends syntax
+--XLEAK--
+--FILE--
+<?php
+
+shape BaseShape = array{id: int, name: string};
+shape ExtendedShape extends BaseShape = array{email: string};
+
+function test(ExtendedShape $data): void {
+    var_dump($data);
+}
+
+// Test with all required fields from both parent and child
+test(['id' => 1, 'name' => 'John', 'email' => 'john@example.com']);
+
+// Test that parent fields are accessible
+function getParentFields(ExtendedShape $data): array {
+    return ['id' => $data['id'], 'name' => $data['name']];
+}
+
+var_dump(getParentFields(['id' => 2, 'name' => 'Jane', 'email' => 'jane@example.com']));
+
+echo "Done\n";
+?>
+--EXPECT--
+array(3) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(4) "John"
+  ["email"]=>
+  string(16) "john@example.com"
+}
+array(2) {
+  ["id"]=>
+  int(2)
+  ["name"]=>
+  string(4) "Jane"
+}
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_covariance.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_covariance.phpt
new file mode 100644
index 00000000..0b74b5f0
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_covariance.phpt
@@ -0,0 +1,54 @@
+--TEST--
+Shape inheritance - valid type covariance
+--XLEAK--
+--FILE--
+<?php
+
+// Test 1: Child can narrow union type to single type
+shape BaseUnion = array{id: int, value: string|int};
+shape ChildNarrow extends BaseUnion = array{value: string};  // Valid: string|int -> string
+
+function testNarrow(ChildNarrow $data): void {
+    echo "value type narrowed: ";
+    var_dump($data['value']);
+}
+testNarrow(['id' => 1, 'value' => 'hello']);
+
+// Test 2: Child can keep same type
+shape BaseSame = array{id: int, name: string};
+shape ChildSame extends BaseSame = array{name: string};  // Valid: same type
+
+function testSame(ChildSame $data): void {
+    echo "value type same: ";
+    var_dump($data['name']);
+}
+testSame(['id' => 2, 'name' => 'Alice']);
+
+// Test 3: Child can make optional required (valid)
+shape BaseOptional = array{id: int, status?: string};
+shape ChildRequired extends BaseOptional = array{status: string};  // Valid: optional -> required
+
+function testRequired(ChildRequired $data): void {
+    echo "optional made required: ";
+    var_dump($data['status']);
+}
+testRequired(['id' => 3, 'status' => 'active']);
+
+// Test 4: Child can add new properties
+shape BaseMinimal = array{id: int};
+shape ChildExtended extends BaseMinimal = array{name: string, email: string};
+
+function testExtended(ChildExtended $data): void {
+    echo "extended with new props: ";
+    var_dump($data['name']);
+}
+testExtended(['id' => 4, 'name' => 'Bob', 'email' => 'bob@example.com']);
+
+echo "Done\n";
+?>
+--EXPECT--
+value type narrowed: string(5) "hello"
+value type same: string(5) "Alice"
+optional made required: string(6) "active"
+extended with new props: string(3) "Bob"
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_nested.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_nested.phpt
new file mode 100644
index 00000000..aab63f78
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_nested.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Shape inheritance - nested/chained inheritance
+--XLEAK--
+--FILE--
+<?php
+
+shape Base = array{a: int};
+shape Middle extends Base = array{b: string};
+shape Top extends Middle = array{c: bool};
+
+function test(Top $data): void {
+    echo "a=" . $data['a'] . ", b=" . $data['b'] . ", c=" . ($data['c'] ? 'true' : 'false') . "\n";
+}
+
+test(['a' => 42, 'b' => 'hello', 'c' => true]);
+test(['a' => 100, 'b' => 'world', 'c' => false]);
+
+echo "Done\n";
+?>
+--EXPECT--
+a=42, b=hello, c=true
+a=100, b=world, c=false
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_override.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_override.phpt
new file mode 100644
index 00000000..2a5642a1
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_override.phpt
@@ -0,0 +1,12 @@
+--TEST--
+Shape inheritance - invalid covariance (widening type error)
+--XLEAK--
+--FILE--
+<?php
+
+shape Base = array{id: int, value: string};
+shape Child extends Base = array{value: int};  // Invalid: string -> int is not covariant
+
+?>
+--EXPECTF--
+Fatal error: Shape Child property 'value' type int is not compatible with parent type string in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_reflection.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_reflection.phpt
new file mode 100644
index 00000000..b777ade9
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_reflection.phpt
@@ -0,0 +1,34 @@
+--TEST--
+Shape inheritance - reflection shows flattened structure
+--XLEAK--
+--FILE--
+<?php
+
+shape BaseShape = array{id: int, name: string};
+shape ExtendedShape extends BaseShape = array{email: string};
+
+$rf = new ReflectionFunction(function(ExtendedShape $arg) {});
+$params = $rf->getParameters();
+$type = $params[0]->getType();
+
+echo "Type string: " . $type . "\n";
+echo "Element count: " . $type->getElementCount() . "\n";
+echo "Required count: " . $type->getRequiredElementCount() . "\n";
+
+echo "\nElements:\n";
+foreach ($type->getElements() as $elem) {
+    echo "  - " . $elem->getName() . ": " . $elem->getType() . "\n";
+}
+
+echo "Done\n";
+?>
+--EXPECT--
+Type string: array{id: int, name: string, email: string}
+Element count: 3
+Required count: 3
+
+Elements:
+  - id: int
+  - name: string
+  - email: string
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_required_to_optional_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_required_to_optional_error.phpt
new file mode 100644
index 00000000..60730c0f
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_required_to_optional_error.phpt
@@ -0,0 +1,12 @@
+--TEST--
+Shape inheritance - cannot make required property optional
+--XLEAK--
+--FILE--
+<?php
+
+shape Base = array{id: int, name: string};
+shape Child extends Base = array{name?: string};  // Invalid: required -> optional
+
+?>
+--EXPECTF--
+Fatal error: Shape Child cannot make required property 'name' optional (inherited as required from parent) in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_name_basic.phpt b/Zend/tests/type_declarations/array_shapes/shape_name_basic.phpt
new file mode 100644
index 00000000..e08a556a
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_name_basic.phpt
@@ -0,0 +1,23 @@
+--TEST--
+::shape syntax - basic usage
+--XLEAK--
+--FILE--
+<?php
+
+shape UserShape = array{id: int, name: string};
+
+echo UserShape::shape . "\n";
+
+$name = UserShape::shape;
+echo $name . "\n";
+
+// Use in an expression
+echo "Shape name is: " . UserShape::shape . "\n";
+
+echo "Done\n";
+?>
+--EXPECT--
+UserShape
+UserShape
+Shape name is: UserShape
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_name_namespaced.phpt b/Zend/tests/type_declarations/array_shapes/shape_name_namespaced.phpt
new file mode 100644
index 00000000..761de143
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_name_namespaced.phpt
@@ -0,0 +1,24 @@
+--TEST--
+::shape syntax - with namespaces
+--XLEAK--
+--FILE--
+<?php
+
+namespace App\Types;
+
+shape UserShape = array{id: int, name: string};
+
+// Should return fully qualified name
+echo UserShape::shape . "\n";
+
+namespace App\Other;
+
+// Reference shape from another namespace
+echo \App\Types\UserShape::shape . "\n";
+
+echo "Done\n";
+?>
+--EXPECT--
+App\Types\UserShape
+App\Types\UserShape
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_name_on_class_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_name_on_class_error.phpt
new file mode 100644
index 00000000..3c9aee2e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_name_on_class_error.phpt
@@ -0,0 +1,11 @@
+--TEST--
+::shape syntax - cannot use on class
+--FILE--
+<?php
+
+class MyClass {}
+
+echo MyClass::shape;
+?>
+--EXPECTF--
+Fatal error: Cannot use ::shape on class MyClass, use ::class instead in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_namespaced.phpt b/Zend/tests/type_declarations/array_shapes/shape_namespaced.phpt
new file mode 100644
index 00000000..67cfea57
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_namespaced.phpt
@@ -0,0 +1,87 @@
+--TEST--
+Namespaced shape type aliases with autoloading
+--XLEAK--
+--FILE--
+<?php
+
+// Create temporary directory structure for namespaced shapes
+$tempDir = sys_get_temp_dir() . '/php_shape_ns_test_' . getmypid();
+mkdir($tempDir . '/App/Shapes', 0755, true);
+mkdir($tempDir . '/App/Services', 0755, true);
+
+// Create namespaced shape file
+file_put_contents($tempDir . '/App/Shapes/UserShape.php', '<?php
+namespace App\Shapes;
+
+shape UserShape = array{id: int, name: string, email: string};
+');
+
+// Create service that uses the namespaced shape
+file_put_contents($tempDir . '/App/Services/UserService.php', '<?php
+namespace App\Services;
+
+use App\Shapes\UserShape;
+
+class UserService {
+    public function getUser(int $id): UserShape {
+        return ["id" => $id, "name" => "Alice", "email" => "alice@example.com"];
+    }
+
+    public function processUser(UserShape $user): string {
+        return "Processing: " . $user["name"];
+    }
+}
+');
+
+// Register PSR-4 style autoloader
+$autoloaded = [];
+spl_autoload_register(function($name) use ($tempDir, &$autoloaded) {
+    $autoloaded[] = $name;
+    $file = $tempDir . '/' . str_replace('\\', '/', $name) . '.php';
+    if (file_exists($file)) {
+        require_once $file;
+        return true;
+    }
+    return false;
+});
+
+// Test 1: shape_exists with namespaced shape (no autoload)
+echo "Before autoload (no trigger): ";
+var_dump(shape_exists('App\Shapes\UserShape', false));
+
+// Test 2: shape_exists with namespaced shape (with autoload)
+echo "With autoload trigger: ";
+var_dump(shape_exists('App\Shapes\UserShape', true));
+
+// Test 3: Use namespaced shape in class method
+$service = new App\Services\UserService();
+$user = $service->getUser(42);
+echo "User ID: " . $user['id'] . ", Name: " . $user['name'] . "\n";
+
+// Test 4: Shape as parameter type
+echo $service->processUser($user) . "\n";
+
+// Test 5: Verify autoloader was called for both shape and class
+echo "Autoloaded:\n";
+foreach ($autoloaded as $name) {
+    echo "  - $name\n";
+}
+
+// Clean up
+unlink($tempDir . '/App/Shapes/UserShape.php');
+unlink($tempDir . '/App/Services/UserService.php');
+rmdir($tempDir . '/App/Services');
+rmdir($tempDir . '/App/Shapes');
+rmdir($tempDir . '/App');
+rmdir($tempDir);
+echo "Done\n";
+?>
+--EXPECT--
+Before autoload (no trigger): bool(false)
+With autoload trigger: bool(true)
+User ID: 42, Name: Alice
+Processing: Alice
+Autoloaded:
+  - App\Shapes\UserShape
+  - App\Services\UserService
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_basic.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_basic.phpt
new file mode 100644
index 00000000..7de0ecc2
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_basic.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Shape type alias basic usage
+--XLEAK--
+--FILE--
+<?php
+
+shape User = array{id: int, name: string};
+
+function getUser(): User {
+    return ["id" => 1, "name" => "John"];
+}
+
+function greetUser(User $user): string {
+    return "Hello, " . $user["name"];
+}
+
+$user = getUser();
+var_dump($user);
+echo greetUser($user) . "\n";
+?>
+--EXPECT--
+array(2) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(4) "John"
+}
+Hello, John
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_nested.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_nested.phpt
new file mode 100644
index 00000000..d062f2f4
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_nested.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Shape type alias with nested shapes
+--XLEAK--
+--FILE--
+<?php
+
+shape Address = array{street: string, city: string, zip: string};
+shape Person = array{name: string, address: Address};
+
+function getPerson(): Person {
+    return [
+        "name" => "John Doe",
+        "address" => [
+            "street" => "123 Main St",
+            "city" => "Springfield",
+            "zip" => "12345"
+        ]
+    ];
+}
+
+$person = getPerson();
+echo $person["name"] . " lives at " . $person["address"]["street"] . "\n";
+?>
+--EXPECT--
+John Doe lives at 123 Main St
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_redeclare_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_redeclare_error.phpt
new file mode 100644
index 00000000..85f430be
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_redeclare_error.phpt
@@ -0,0 +1,11 @@
+--TEST--
+Shape type alias redeclaration error
+--FILE--
+<?php
+
+shape User = array{id: int};
+shape User = array{name: string};
+
+?>
+--EXPECTF--
+Fatal error: Cannot redeclare shape User in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_type_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_type_error.phpt
new file mode 100644
index 00000000..3e91db31
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_type_error.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Shape type alias type error
+--XLEAK--
+--FILE--
+<?php
+
+shape User = array{id: int, name: string};
+
+function getUser(): User {
+    return ["id" => "not-an-int", "name" => "John"];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+?>
+--EXPECT--
+Caught: getUser(): Return value must be of type array{id: int, ...}, array key "id" is string
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_with_typed_arrays.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_with_typed_arrays.phpt
new file mode 100644
index 00000000..3fa8d10d
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_with_typed_arrays.phpt
@@ -0,0 +1,27 @@
+--TEST--
+Shape type alias with typed arrays
+--XLEAK--
+--FILE--
+<?php
+
+shape Order = array{
+    id: int,
+    items: array<string>,
+    total: float
+};
+
+function getOrder(): Order {
+    return [
+        "id" => 42,
+        "items" => ["apple", "banana", "orange"],
+        "total" => 12.99
+    ];
+}
+
+$order = getOrder();
+echo "Order #" . $order["id"] . " - $" . $order["total"] . "\n";
+echo "Items: " . implode(", ", $order["items"]) . "\n";
+?>
+--EXPECT--
+Order #42 - $12.99
+Items: apple, banana, orange
diff --git a/Zend/tests/typed_arrays/abstract_class_typed_array.phpt b/Zend/tests/typed_arrays/abstract_class_typed_array.phpt
new file mode 100644
index 00000000..b1ec3a25
--- /dev/null
+++ b/Zend/tests/typed_arrays/abstract_class_typed_array.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Abstract class: typed array in abstract method
+--FILE--
+<?php
+
+
+abstract class DataStore {
+    abstract public function getItems(): array<string>;
+    abstract public function addItem(string $item): void;
+}
+
+class InMemoryStore extends DataStore {
+    private array<string> $items = [];
+
+    public function getItems(): array<string> {
+        return $this->items;
+    }
+
+    public function addItem(string $item): void {
+        $this->items[] = $item;
+    }
+}
+
+$store = new InMemoryStore();
+$store->addItem("first");
+$store->addItem("second");
+echo "Items: " . implode(", ", $store->getItems()) . "\n";
+
+?>
+--EXPECT--
+Items: first, second
diff --git a/Zend/tests/typed_arrays/arrow_function_typed_array.phpt b/Zend/tests/typed_arrays/arrow_function_typed_array.phpt
new file mode 100644
index 00000000..ce4e89a6
--- /dev/null
+++ b/Zend/tests/typed_arrays/arrow_function_typed_array.phpt
@@ -0,0 +1,14 @@
+--TEST--
+Arrow function: typed array in arrow function parameter and return type
+--FILE--
+<?php
+
+
+$filter = fn(array<int> $nums): array<int> => array_filter($nums, fn($n) => $n > 2);
+
+$result = $filter([1, 2, 3, 4, 5]);
+echo "Filtered: " . implode(", ", $result) . "\n";
+
+?>
+--EXPECT--
+Filtered: 3, 4, 5
diff --git a/Zend/tests/typed_arrays/basic_int_array.phpt b/Zend/tests/typed_arrays/basic_int_array.phpt
new file mode 100644
index 00000000..6d9b7766
--- /dev/null
+++ b/Zend/tests/typed_arrays/basic_int_array.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Typed array: array<int> basic functionality
+--FILE--
+<?php
+
+
+function getNumbers(): array<int> {
+    return [1, 2, 3, 4, 5];
+}
+
+function sumNumbers(array<int> $nums): int {
+    return array_sum($nums);
+}
+
+$nums = getNumbers();
+var_dump($nums);
+echo "Sum: " . sumNumbers($nums) . "\n";
+
+// Empty array is valid
+function emptyInts(): array<int> {
+    return [];
+}
+var_dump(emptyInts());
+
+?>
+--EXPECT--
+array(5) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(2)
+  [2]=>
+  int(3)
+  [3]=>
+  int(4)
+  [4]=>
+  int(5)
+}
+Sum: 15
+array(0) {
+}
diff --git a/Zend/tests/typed_arrays/basic_shape.phpt b/Zend/tests/typed_arrays/basic_shape.phpt
new file mode 100644
index 00000000..27f5ad4e
--- /dev/null
+++ b/Zend/tests/typed_arrays/basic_shape.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Array shape: basic array{key: type} functionality
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string, email: string} {
+    return [
+        'id' => 1,
+        'name' => 'Alice',
+        'email' => 'alice@example.com'
+    ];
+}
+
+$user = getUser();
+echo "ID: {$user['id']}\n";
+echo "Name: {$user['name']}\n";
+echo "Email: {$user['email']}\n";
+
+?>
+--EXPECT--
+ID: 1
+Name: Alice
+Email: alice@example.com
diff --git a/Zend/tests/typed_arrays/basic_string_array.phpt b/Zend/tests/typed_arrays/basic_string_array.phpt
new file mode 100644
index 00000000..b954375e
--- /dev/null
+++ b/Zend/tests/typed_arrays/basic_string_array.phpt
@@ -0,0 +1,29 @@
+--TEST--
+Typed array: array<string> basic functionality
+--FILE--
+<?php
+
+
+function getNames(): array<string> {
+    return ["Alice", "Bob", "Charlie"];
+}
+
+function joinNames(array<string> $names): string {
+    return implode(", ", $names);
+}
+
+$names = getNames();
+var_dump($names);
+echo "Names: " . joinNames($names) . "\n";
+
+?>
+--EXPECT--
+array(3) {
+  [0]=>
+  string(5) "Alice"
+  [1]=>
+  string(3) "Bob"
+  [2]=>
+  string(7) "Charlie"
+}
+Names: Alice, Bob, Charlie
diff --git a/Zend/tests/typed_arrays/bool_array.phpt b/Zend/tests/typed_arrays/bool_array.phpt
new file mode 100644
index 00000000..7f6bfa51
--- /dev/null
+++ b/Zend/tests/typed_arrays/bool_array.phpt
@@ -0,0 +1,17 @@
+--TEST--
+Typed array: array<bool> functionality
+--FILE--
+<?php
+
+
+function getFlags(): array<bool> {
+    return [true, false, true, true];
+}
+
+$flags = getFlags();
+$trueCount = count(array_filter($flags));
+echo "True count: $trueCount out of " . count($flags) . "\n";
+
+?>
+--EXPECT--
+True count: 3 out of 4
diff --git a/Zend/tests/typed_arrays/closure_typed_array.phpt b/Zend/tests/typed_arrays/closure_typed_array.phpt
new file mode 100644
index 00000000..7e3cd4e7
--- /dev/null
+++ b/Zend/tests/typed_arrays/closure_typed_array.phpt
@@ -0,0 +1,17 @@
+--TEST--
+Closure: typed array in closure parameter and return type
+--FILE--
+<?php
+
+
+$transform = function(array<int> $numbers): array<int> {
+    return array_map(fn($n) => $n * 2, $numbers);
+};
+
+$numbers = [1, 2, 3, 4, 5];
+$doubled = $transform($numbers);
+echo "Doubled: " . implode(", ", $doubled) . "\n";
+
+?>
+--EXPECT--
+Doubled: 2, 4, 6, 8, 10
diff --git a/Zend/tests/typed_arrays/empty_shape.phpt b/Zend/tests/typed_arrays/empty_shape.phpt
new file mode 100644
index 00000000..536e8106
--- /dev/null
+++ b/Zend/tests/typed_arrays/empty_shape.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Edge case: empty array shape (no fields)
+--FILE--
+<?php
+
+
+// Empty shape - accepts any array but provides no type guarantees
+function processEmpty(array{} $data): void {
+    echo "Got array with " . count($data) . " elements\n";
+}
+
+processEmpty([]);
+processEmpty(['extra' => 'data']);
+
+?>
+--EXPECT--
+Got array with 0 elements
+Got array with 1 elements
diff --git a/Zend/tests/typed_arrays/float_array.phpt b/Zend/tests/typed_arrays/float_array.phpt
new file mode 100644
index 00000000..12424353
--- /dev/null
+++ b/Zend/tests/typed_arrays/float_array.phpt
@@ -0,0 +1,22 @@
+--TEST--
+Typed array: array<float> functionality
+--FILE--
+<?php
+
+
+function getPrices(): array<float> {
+    return [19.99, 29.99, 39.99];
+}
+
+function calculateTotal(array<float> $prices): float {
+    return array_sum($prices);
+}
+
+$prices = getPrices();
+echo "Prices: " . implode(", ", $prices) . "\n";
+echo "Total: " . calculateTotal($prices) . "\n";
+
+?>
+--EXPECT--
+Prices: 19.99, 29.99, 39.99
+Total: 89.97
diff --git a/Zend/tests/typed_arrays/int_array_param_error.phpt b/Zend/tests/typed_arrays/int_array_param_error.phpt
new file mode 100644
index 00000000..666ed047
--- /dev/null
+++ b/Zend/tests/typed_arrays/int_array_param_error.phpt
@@ -0,0 +1,19 @@
+--TEST--
+Typed array: array<int> parameter type error
+--FILE--
+<?php
+
+
+function sumNumbers(array<int> $nums): int {
+    return array_sum($nums);
+}
+
+try {
+    sumNumbers([1, 2, "three"]);
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: sumNumbers(): Argument #1 ($nums) must be of type array<int>, array element at index 2 is string
diff --git a/Zend/tests/typed_arrays/int_array_type_error.phpt b/Zend/tests/typed_arrays/int_array_type_error.phpt
new file mode 100644
index 00000000..8bcca561
--- /dev/null
+++ b/Zend/tests/typed_arrays/int_array_type_error.phpt
@@ -0,0 +1,19 @@
+--TEST--
+Typed array: array<int> type error when returning wrong type
+--FILE--
+<?php
+
+
+function getNumbers(): array<int> {
+    return [1, 2, "three", 4];
+}
+
+try {
+    getNumbers();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getNumbers(): Return value must be of type array<int>, array element at index 2 is string
diff --git a/Zend/tests/typed_arrays/interface_typed_array.phpt b/Zend/tests/typed_arrays/interface_typed_array.phpt
new file mode 100644
index 00000000..da627feb
--- /dev/null
+++ b/Zend/tests/typed_arrays/interface_typed_array.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Interface: typed array in interface method
+--XLEAK--
+--FILE--
+<?php
+
+
+interface Repository {
+    public function findAll(): array<array{id: int, name: string}>;
+    public function save(array{id: int, name: string} $item): void;
+}
+
+class UserRepository implements Repository {
+    private array<array{id: int, name: string}> $items = [];
+
+    public function findAll(): array<array{id: int, name: string}> {
+        return $this->items;
+    }
+
+    public function save(array{id: int, name: string} $item): void {
+        $this->items[] = $item;
+    }
+}
+
+$repo = new UserRepository();
+$repo->save(['id' => 1, 'name' => 'Alice']);
+$repo->save(['id' => 2, 'name' => 'Bob']);
+
+foreach ($repo->findAll() as $user) {
+    echo "{$user['id']}: {$user['name']}\n";
+}
+
+?>
+--EXPECT--
+1: Alice
+2: Bob
diff --git a/Zend/tests/typed_arrays/keyed_typed_array.phpt b/Zend/tests/typed_arrays/keyed_typed_array.phpt
new file mode 100644
index 00000000..7124765c
--- /dev/null
+++ b/Zend/tests/typed_arrays/keyed_typed_array.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Typed array: array<string, int> with string keys
+--FILE--
+<?php
+
+
+function getCounts(): array<string, int> {
+    return [
+        'apples' => 5,
+        'oranges' => 3,
+        'bananas' => 7
+    ];
+}
+
+$counts = getCounts();
+foreach ($counts as $fruit => $count) {
+    echo "$fruit: $count\n";
+}
+
+?>
+--EXPECT--
+apples: 5
+oranges: 3
+bananas: 7
diff --git a/Zend/tests/typed_arrays/keyed_typed_array_error.phpt b/Zend/tests/typed_arrays/keyed_typed_array_error.phpt
new file mode 100644
index 00000000..e69ac7b4
--- /dev/null
+++ b/Zend/tests/typed_arrays/keyed_typed_array_error.phpt
@@ -0,0 +1,22 @@
+--TEST--
+Typed array: array<string, int> key type error
+--FILE--
+<?php
+
+
+function getCounts(): array<string, int> {
+    return [
+        0 => 5,  // Error: integer key, expected string
+        'oranges' => 3
+    ];
+}
+
+getCounts();
+
+?>
+--EXPECTF--
+Fatal error: Uncaught TypeError: getCounts(): Return value must be of type array<string, ...>, array contains int key in %s:%d
+Stack trace:
+#0 %s(%d): getCounts()
+#1 {main}
+  thrown in %s on line %d
diff --git a/Zend/tests/typed_arrays/method_typed_array.phpt b/Zend/tests/typed_arrays/method_typed_array.phpt
new file mode 100644
index 00000000..9fa46915
--- /dev/null
+++ b/Zend/tests/typed_arrays/method_typed_array.phpt
@@ -0,0 +1,40 @@
+--TEST--
+Typed array: class method with typed array return and parameter
+--XLEAK--
+--FILE--
+<?php
+
+
+class UserRepository {
+    private array<array{id: int, name: string}> $users = [];
+
+    public function add(array{id: int, name: string} $user): void {
+        $this->users[] = $user;
+    }
+
+    public function getAll(): array<array{id: int, name: string}> {
+        return $this->users;
+    }
+
+    public function getIds(): array<int> {
+        return array_column($this->users, 'id');
+    }
+}
+
+$repo = new UserRepository();
+$repo->add(['id' => 1, 'name' => 'Alice']);
+$repo->add(['id' => 2, 'name' => 'Bob']);
+
+echo "Users:\n";
+foreach ($repo->getAll() as $user) {
+    echo "  - {$user['name']}\n";
+}
+
+echo "IDs: " . implode(", ", $repo->getIds()) . "\n";
+
+?>
+--EXPECT--
+Users:
+  - Alice
+  - Bob
+IDs: 1, 2
diff --git a/Zend/tests/typed_arrays/mixed_element_type.phpt b/Zend/tests/typed_arrays/mixed_element_type.phpt
new file mode 100644
index 00000000..1f649d8b
--- /dev/null
+++ b/Zend/tests/typed_arrays/mixed_element_type.phpt
@@ -0,0 +1,21 @@
+--TEST--
+Typed array: array<mixed> accepts any values
+--FILE--
+<?php
+
+
+function processAny(array<mixed> $items): void {
+    foreach ($items as $item) {
+        echo gettype($item) . ": " . (is_scalar($item) ? var_export($item, true) : gettype($item)) . "\n";
+    }
+}
+
+processAny([1, 'hello', true, null, [1, 2, 3]]);
+
+?>
+--EXPECT--
+integer: 1
+string: 'hello'
+boolean: true
+NULL: NULL
+array: array
diff --git a/Zend/tests/typed_arrays/named_args_shape.phpt b/Zend/tests/typed_arrays/named_args_shape.phpt
new file mode 100644
index 00000000..8001b465
--- /dev/null
+++ b/Zend/tests/typed_arrays/named_args_shape.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Edge case: array shape with named arguments
+--XLEAK--
+--FILE--
+<?php
+
+
+function createUser(array{id: int, name: string, active?: bool} $data): void {
+    echo "User: {$data['id']} - {$data['name']}";
+    if (isset($data['active'])) {
+        echo " (active: " . ($data['active'] ? 'yes' : 'no') . ")";
+    }
+    echo "\n";
+}
+
+// Named arguments at call site with array literal
+createUser(data: ['id' => 1, 'name' => 'Alice']);
+createUser(data: ['id' => 2, 'name' => 'Bob', 'active' => true]);
+
+?>
+--EXPECT--
+User: 1 - Alice
+User: 2 - Bob (active: yes)
diff --git a/Zend/tests/typed_arrays/nested_typed_array.phpt b/Zend/tests/typed_arrays/nested_typed_array.phpt
new file mode 100644
index 00000000..9440dfbb
--- /dev/null
+++ b/Zend/tests/typed_arrays/nested_typed_array.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Typed array: nested array<array<int>> functionality
+--FILE--
+<?php
+
+
+function getMatrix(): array<array<int>> {
+    return [
+        [1, 2, 3],
+        [4, 5, 6],
+        [7, 8, 9]
+    ];
+}
+
+$matrix = getMatrix();
+foreach ($matrix as $i => $row) {
+    echo "Row $i: " . implode(", ", $row) . "\n";
+}
+
+?>
+--EXPECT--
+Row 0: 1, 2, 3
+Row 1: 4, 5, 6
+Row 2: 7, 8, 9
diff --git a/Zend/tests/typed_arrays/nullable_typed_array.phpt b/Zend/tests/typed_arrays/nullable_typed_array.phpt
new file mode 100644
index 00000000..e10bc053
--- /dev/null
+++ b/Zend/tests/typed_arrays/nullable_typed_array.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Typed array: nullable array<int>|null
+--FILE--
+<?php
+
+
+function maybeGetNumbers(): ?array<int> {
+    return null;
+}
+
+function maybeGetNumbers2(): ?array<int> {
+    return [1, 2, 3];
+}
+
+var_dump(maybeGetNumbers());
+var_dump(maybeGetNumbers2());
+
+?>
+--EXPECT--
+NULL
+array(3) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(2)
+  [2]=>
+  int(3)
+}
diff --git a/Zend/tests/typed_arrays/object_array.phpt b/Zend/tests/typed_arrays/object_array.phpt
new file mode 100644
index 00000000..8a60b837
--- /dev/null
+++ b/Zend/tests/typed_arrays/object_array.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Typed array: array<ClassName> with objects
+--FILE--
+<?php
+
+
+class User {
+    public function __construct(
+        public int $id,
+        public string $name
+    ) {}
+}
+
+function getUsers(): array<User> {
+    return [
+        new User(1, "Alice"),
+        new User(2, "Bob"),
+    ];
+}
+
+function processUsers(array<User> $users): void {
+    foreach ($users as $user) {
+        echo "User {$user->id}: {$user->name}\n";
+    }
+}
+
+$users = getUsers();
+processUsers($users);
+
+?>
+--EXPECT--
+User 1: Alice
+User 2: Bob
diff --git a/Zend/tests/typed_arrays/object_array_type_error.phpt b/Zend/tests/typed_arrays/object_array_type_error.phpt
new file mode 100644
index 00000000..b6d29218
--- /dev/null
+++ b/Zend/tests/typed_arrays/object_array_type_error.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Typed array: array<ClassName> type error with wrong object type
+--XLEAK--
+--FILE--
+<?php
+
+
+class User {
+    public function __construct(public int $id) {}
+}
+
+class Product {
+    public function __construct(public int $id) {}
+}
+
+function getUsers(): array<User> {
+    return [
+        new User(1),
+        new Product(2),  // Wrong type!
+    ];
+}
+
+try {
+    getUsers();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getUsers(): Return value must be of type array<User>, array element at index 1 is Product
diff --git a/Zend/tests/typed_arrays/opcache_shape_persistence.phpt b/Zend/tests/typed_arrays/opcache_shape_persistence.phpt
new file mode 100644
index 00000000..988211b1
--- /dev/null
+++ b/Zend/tests/typed_arrays/opcache_shape_persistence.phpt
@@ -0,0 +1,60 @@
+--TEST--
+OPcache: shape types persist correctly in cache
+--EXTENSIONS--
+opcache
+--INI--
+opcache.enable=1
+opcache.enable_cli=1
+opcache.jit=off
+--FILE--
+<?php
+
+
+// This test verifies that typed arrays and shapes work correctly
+// when scripts are cached by OPcache
+
+function getUsers(): array<array{id: int, name: string}> {
+    return [
+        ['id' => 1, 'name' => 'Alice'],
+        ['id' => 2, 'name' => 'Bob'],
+    ];
+}
+
+function getNumbers(): array<int> {
+    return [1, 2, 3, 4, 5];
+}
+
+class Config {
+    public array{host: string, port: int} $database = [
+        'host' => 'localhost',
+        'port' => 3306
+    ];
+}
+
+// Test typed arrays
+$numbers = getNumbers();
+echo "Numbers: " . implode(", ", $numbers) . "\n";
+
+// Test array shapes
+$users = getUsers();
+foreach ($users as $user) {
+    echo "User: {$user['name']} (ID: {$user['id']})\n";
+}
+
+// Test property shapes
+$config = new Config();
+echo "Database: {$config->database['host']}:{$config->database['port']}\n";
+
+// Verify opcache is active
+if (function_exists('opcache_get_status')) {
+    $status = opcache_get_status();
+    echo "OPcache enabled: " . ($status['opcache_enabled'] ? 'yes' : 'no') . "\n";
+}
+
+?>
+--EXPECT--
+Numbers: 1, 2, 3, 4, 5
+User: Alice (ID: 1)
+User: Bob (ID: 2)
+Database: localhost:3306
+OPcache enabled: yes
diff --git a/Zend/tests/typed_arrays/promoted_property_typed_array.phpt b/Zend/tests/typed_arrays/promoted_property_typed_array.phpt
new file mode 100644
index 00000000..29a46f21
--- /dev/null
+++ b/Zend/tests/typed_arrays/promoted_property_typed_array.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Constructor promoted property: typed array in promoted property
+--FILE--
+<?php
+
+
+class User {
+    public function __construct(
+        public int $id,
+        public string $name,
+        public array<string> $roles = []
+    ) {}
+
+    public function hasRole(string $role): bool {
+        return in_array($role, $this->roles, true);
+    }
+}
+
+$admin = new User(1, 'Alice', ['admin', 'editor']);
+$guest = new User(2, 'Bob');
+
+echo "{$admin->name} is admin: " . ($admin->hasRole('admin') ? 'yes' : 'no') . "\n";
+echo "{$guest->name} is admin: " . ($guest->hasRole('admin') ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Alice is admin: yes
+Bob is admin: no
diff --git a/Zend/tests/typed_arrays/property_typed_array.phpt b/Zend/tests/typed_arrays/property_typed_array.phpt
new file mode 100644
index 00000000..2ace0391
--- /dev/null
+++ b/Zend/tests/typed_arrays/property_typed_array.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Typed array: property with array<int> type
+--FILE--
+<?php
+
+
+class Counter {
+    public array<int> $counts = [];
+
+    public function add(int $n): void {
+        $this->counts[] = $n;
+    }
+
+    public function getSum(): int {
+        return array_sum($this->counts);
+    }
+}
+
+$c = new Counter();
+$c->add(1);
+$c->add(2);
+$c->add(3);
+echo "Sum: " . $c->getSum() . "\n";
+var_dump($c->counts);
+
+?>
+--EXPECT--
+Sum: 6
+array(3) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(2)
+  [2]=>
+  int(3)
+}
diff --git a/Zend/tests/typed_arrays/readonly_property_typed_array.phpt b/Zend/tests/typed_arrays/readonly_property_typed_array.phpt
new file mode 100644
index 00000000..a58377ec
--- /dev/null
+++ b/Zend/tests/typed_arrays/readonly_property_typed_array.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Readonly property: typed array in readonly property
+--FILE--
+<?php
+
+
+class ImmutableConfig {
+    public function __construct(
+        public readonly array<string> $allowedHosts
+    ) {}
+}
+
+$config = new ImmutableConfig(['localhost', 'example.com']);
+echo "Allowed hosts: " . implode(", ", $config->allowedHosts) . "\n";
+
+?>
+--EXPECT--
+Allowed hosts: localhost, example.com
diff --git a/Zend/tests/typed_arrays/reflection_shape.phpt b/Zend/tests/typed_arrays/reflection_shape.phpt
new file mode 100644
index 00000000..ca13d5df
--- /dev/null
+++ b/Zend/tests/typed_arrays/reflection_shape.phpt
@@ -0,0 +1,21 @@
+--TEST--
+Reflection: ReflectionType for array shapes
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice'];
+}
+
+$rf = new ReflectionFunction('getUser');
+$returnType = $rf->getReturnType();
+
+echo "Return type: " . $returnType . "\n";
+echo "Class: " . get_class($returnType) . "\n";
+
+?>
+--EXPECT--
+Return type: array{id: int, name: string}
+Class: ReflectionArrayShapeType
diff --git a/Zend/tests/typed_arrays/reflection_typed_array.phpt b/Zend/tests/typed_arrays/reflection_typed_array.phpt
new file mode 100644
index 00000000..5b7bcd4b
--- /dev/null
+++ b/Zend/tests/typed_arrays/reflection_typed_array.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Reflection: ReflectionType for typed arrays
+--XLEAK--
+--FILE--
+<?php
+
+
+function getNumbers(): array<int> {
+    return [1, 2, 3];
+}
+
+$rf = new ReflectionFunction('getNumbers');
+$returnType = $rf->getReturnType();
+
+echo "Return type: " . $returnType . "\n";
+echo "Class: " . get_class($returnType) . "\n";
+echo "Allows null: " . ($returnType->allowsNull() ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Return type: array<int>
+Class: ReflectionArrayType
+Allows null: no
diff --git a/Zend/tests/typed_arrays/shape_alias.phpt b/Zend/tests/typed_arrays/shape_alias.phpt
new file mode 100644
index 00000000..a6865d85
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_alias.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Shape alias: using shape keyword to define reusable types
+--XLEAK--
+--FILE--
+<?php
+
+
+shape User = array{id: int, name: string, email: string};
+
+function createUser(int $id, string $name, string $email): User {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email
+    ];
+}
+
+function getUsers(): array<User> {
+    return [
+        createUser(1, 'Alice', 'alice@example.com'),
+        createUser(2, 'Bob', 'bob@example.com'),
+    ];
+}
+
+$users = getUsers();
+foreach ($users as $user) {
+    echo "{$user['name']} <{$user['email']}>\n";
+}
+
+?>
+--EXPECT--
+Alice <alice@example.com>
+Bob <bob@example.com>
diff --git a/Zend/tests/typed_arrays/shape_alias_circular_warning.phpt b/Zend/tests/typed_arrays/shape_alias_circular_warning.phpt
new file mode 100644
index 00000000..6a4ba553
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_alias_circular_warning.phpt
@@ -0,0 +1,42 @@
+--TEST--
+Shape alias: circular reference triggers warning
+--XLEAK--
+--FILE--
+<?php
+
+
+// Define shapes that reference each other creating a cycle
+// When validating, this should hit the recursion depth limit
+
+shape Node = array{
+    value: int,
+    next?: Node
+};
+
+function createNode(Node $node): void {
+    echo "Node value: {$node['value']}\n";
+}
+
+// Simple case - no recursion
+createNode(['value' => 1]);
+
+// Nested case - one level deep
+createNode(['value' => 1, 'next' => ['value' => 2]]);
+
+// Deeply nested - tests recursion handling
+$deep = ['value' => 1];
+$current = &$deep;
+for ($i = 2; $i <= 10; $i++) {
+    $current['next'] = ['value' => $i];
+    $current = &$current['next'];
+}
+createNode($deep);
+
+echo "All validations passed\n";
+
+?>
+--EXPECT--
+Node value: 1
+Node value: 1
+Node value: 1
+All validations passed
diff --git a/Zend/tests/typed_arrays/shape_all_optional.phpt b/Zend/tests/typed_arrays/shape_all_optional.phpt
new file mode 100644
index 00000000..4d76fd61
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_all_optional.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Array shape: all optional keys allows empty array
+--XLEAK--
+--FILE--
+<?php
+
+
+function getConfig(): array{timeout?: int, retries?: int, debug?: bool} {
+    return [];
+}
+
+function getPartialConfig(): array{timeout?: int, retries?: int, debug?: bool} {
+    return ['timeout' => 30];
+}
+
+$empty = getConfig();
+$partial = getPartialConfig();
+
+echo "Empty config: " . count($empty) . " keys\n";
+echo "Partial config timeout: " . ($partial['timeout'] ?? 'not set') . "\n";
+
+?>
+--EXPECT--
+Empty config: 0 keys
+Partial config timeout: 30
diff --git a/Zend/tests/typed_arrays/shape_deeply_nested.phpt b/Zend/tests/typed_arrays/shape_deeply_nested.phpt
new file mode 100644
index 00000000..0c4fb297
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_deeply_nested.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Array shape: deeply nested shapes work correctly
+--XLEAK--
+--FILE--
+<?php
+
+
+function getNestedData(): array{
+    level1: array{
+        level2: array{
+            level3: array{
+                value: int
+            }
+        }
+    }
+} {
+    return [
+        'level1' => [
+            'level2' => [
+                'level3' => [
+                    'value' => 42
+                ]
+            ]
+        ]
+    ];
+}
+
+$data = getNestedData();
+echo "Value: " . $data['level1']['level2']['level3']['value'] . "\n";
+
+?>
+--EXPECT--
+Value: 42
diff --git a/Zend/tests/typed_arrays/shape_extra_keys.phpt b/Zend/tests/typed_arrays/shape_extra_keys.phpt
new file mode 100644
index 00000000..43a33c44
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_extra_keys.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Array shape: extra keys beyond shape definition are allowed
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return [
+        'id' => 1,
+        'name' => 'Alice',
+        'email' => 'alice@example.com',  // Extra key, should be allowed
+        'age' => 30                       // Another extra key
+    ];
+}
+
+$user = getUser();
+echo "ID: {$user['id']}\n";
+echo "Name: {$user['name']}\n";
+echo "Email: {$user['email']}\n";
+echo "Age: {$user['age']}\n";
+
+?>
+--EXPECT--
+ID: 1
+Name: Alice
+Email: alice@example.com
+Age: 30
diff --git a/Zend/tests/typed_arrays/shape_extra_keys_allowed.phpt b/Zend/tests/typed_arrays/shape_extra_keys_allowed.phpt
new file mode 100644
index 00000000..987fcb4c
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_extra_keys_allowed.phpt
@@ -0,0 +1,21 @@
+--TEST--
+Array shape: extra keys beyond defined shape are allowed
+--XLEAK--
+--FILE--
+<?php
+
+
+function processUser(array{id: int, name: string} $user): void {
+    echo "Processing: {$user['name']} (ID: {$user['id']})\n";
+    if (isset($user['email'])) {
+        echo "  Email: {$user['email']}\n";
+    }
+}
+
+// Extra 'email' key is allowed - shapes validate required keys exist, not exclusive
+processUser(['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com']);
+
+?>
+--EXPECT--
+Processing: Alice (ID: 1)
+  Email: alice@example.com
diff --git a/Zend/tests/typed_arrays/shape_missing_key_error.phpt b/Zend/tests/typed_arrays/shape_missing_key_error.phpt
new file mode 100644
index 00000000..39b41bbb
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_missing_key_error.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Array shape: error when required key is missing
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return [
+        'id' => 1
+        // 'name' is required but missing
+    ];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getUser(): Return value must be of type array{name: string, ...}, array given with missing key "name"
diff --git a/Zend/tests/typed_arrays/shape_mixed_keys.phpt b/Zend/tests/typed_arrays/shape_mixed_keys.phpt
new file mode 100644
index 00000000..4edff60f
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_mixed_keys.phpt
@@ -0,0 +1,53 @@
+--TEST--
+Array shape: mixed required and optional keys
+--XLEAK--
+--FILE--
+<?php
+
+
+function createUser(
+    array{
+        id: int,
+        name: string,
+        email?: string,
+        age?: int,
+        active: bool
+    } $data
+): void {
+    echo "User: {$data['name']} (ID: {$data['id']})\n";
+    if (isset($data['email'])) {
+        echo "  Email: {$data['email']}\n";
+    }
+    if (isset($data['age'])) {
+        echo "  Age: {$data['age']}\n";
+    }
+    echo "  Active: " . ($data['active'] ? 'yes' : 'no') . "\n";
+}
+
+// All fields
+createUser([
+    'id' => 1,
+    'name' => 'Alice',
+    'email' => 'alice@example.com',
+    'age' => 30,
+    'active' => true
+]);
+
+echo "---\n";
+
+// Only required fields
+createUser([
+    'id' => 2,
+    'name' => 'Bob',
+    'active' => false
+]);
+
+?>
+--EXPECT--
+User: Alice (ID: 1)
+  Email: alice@example.com
+  Age: 30
+  Active: yes
+---
+User: Bob (ID: 2)
+  Active: no
diff --git a/Zend/tests/typed_arrays/shape_numeric_string_key.phpt b/Zend/tests/typed_arrays/shape_numeric_string_key.phpt
new file mode 100644
index 00000000..04dbb679
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_numeric_string_key.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Array shape: keys that could be numeric work correctly
+--XLEAK--
+--FILE--
+<?php
+
+
+// Shape keys must be identifiers, so numeric-looking keys use identifier syntax
+// This tests that keys starting with numbers or containing special chars need different approach
+
+function getCoordinates(): array{x: int, y: int} {
+    return [
+        "x" => 10,
+        "y" => 20
+    ];
+}
+
+$coords = getCoordinates();
+echo "x: " . $coords['x'] . ", y: " . $coords['y'] . "\n";
+
+?>
+--EXPECT--
+x: 10, y: 20
diff --git a/Zend/tests/typed_arrays/shape_optional_key.phpt b/Zend/tests/typed_arrays/shape_optional_key.phpt
new file mode 100644
index 00000000..a010c4e2
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_optional_key.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Array shape: optional keys with key?: type syntax
+--XLEAK--
+--FILE--
+<?php
+
+
+function getConfig(): array{host: string, port: int, ssl?: bool} {
+    return [
+        'host' => 'localhost',
+        'port' => 3306
+        // ssl is optional, not provided
+    ];
+}
+
+function getConfigWithSsl(): array{host: string, port: int, ssl?: bool} {
+    return [
+        'host' => 'localhost',
+        'port' => 3306,
+        'ssl' => true
+    ];
+}
+
+$config1 = getConfig();
+echo "Host: {$config1['host']}, Port: {$config1['port']}\n";
+
+$config2 = getConfigWithSsl();
+echo "Host: {$config2['host']}, Port: {$config2['port']}, SSL: " . ($config2['ssl'] ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Host: localhost, Port: 3306
+Host: localhost, Port: 3306, SSL: yes
diff --git a/Zend/tests/typed_arrays/shape_property_assignment.phpt b/Zend/tests/typed_arrays/shape_property_assignment.phpt
new file mode 100644
index 00000000..77e7e744
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_assignment.phpt
@@ -0,0 +1,30 @@
+--TEST--
+Array shape: property assignment validation
+--XLEAK--
+--FILE--
+<?php
+
+
+class Config {
+    public array{host: string, port: int} $database;
+
+    public function __construct() {
+        $this->database = ['host' => 'localhost', 'port' => 3306];
+    }
+}
+
+$config = new Config();
+echo "Host: {$config->database['host']}\n";
+echo "Port: {$config->database['port']}\n";
+
+// Update with valid data
+$config->database = ['host' => '127.0.0.1', 'port' => 5432];
+echo "Updated host: {$config->database['host']}\n";
+echo "Updated port: {$config->database['port']}\n";
+
+?>
+--EXPECT--
+Host: localhost
+Port: 3306
+Updated host: 127.0.0.1
+Updated port: 5432
diff --git a/Zend/tests/typed_arrays/shape_property_error.phpt b/Zend/tests/typed_arrays/shape_property_error.phpt
new file mode 100644
index 00000000..693f92ab
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_error.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Array shape: function return type error (shapes work for function returns)
+--XLEAK--
+--FILE--
+<?php
+
+
+function getConfig(): array{host: string, port: int} {
+    return ['host' => 'localhost']; // Missing 'port'
+}
+
+try {
+    getConfig();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getConfig(): Return value must be of type array{port: int, ...}, array given with missing key "port"
diff --git a/Zend/tests/typed_arrays/shape_property_missing_key_error.phpt b/Zend/tests/typed_arrays/shape_property_missing_key_error.phpt
new file mode 100644
index 00000000..3713beda
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_missing_key_error.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Array shape: property assignment missing required key error
+--XLEAK--
+--FILE--
+<?php
+
+
+class Config {
+    public array{host: string, port: int} $database;
+}
+
+$config = new Config();
+
+// Valid assignment
+$config->database = ['host' => 'localhost', 'port' => 3306];
+echo "Valid assignment: OK\n";
+
+// Invalid assignment - missing 'port'
+try {
+    $config->database = ['host' => 'localhost'];
+} catch (TypeError $e) {
+    echo "Missing key: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Valid assignment: OK
+Missing key: Cannot assign to property Config::$database of type array{port: int, ...}, array given with missing key "port"
diff --git a/Zend/tests/typed_arrays/shape_property_wrong_type_error.phpt b/Zend/tests/typed_arrays/shape_property_wrong_type_error.phpt
new file mode 100644
index 00000000..d306d9e5
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_wrong_type_error.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Array shape: property assignment wrong type error
+--XLEAK--
+--FILE--
+<?php
+
+
+class User {
+    public array{id: int, name: string} $user;
+}
+
+$u = new User();
+
+// Valid assignment
+$u->user = ['id' => 1, 'name' => 'Alice'];
+echo "Valid assignment: OK\n";
+
+// Invalid assignment - wrong type for 'id'
+try {
+    $u->user = ['id' => 'one', 'name' => 'Alice'];
+} catch (TypeError $e) {
+    echo "Wrong type: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Valid assignment: OK
+Wrong type: Cannot assign to property User::$user of type array{id: int, ...}, array key "id" is string
diff --git a/Zend/tests/typed_arrays/shape_recursion_depth_limit.phpt b/Zend/tests/typed_arrays/shape_recursion_depth_limit.phpt
new file mode 100644
index 00000000..f5463d42
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_recursion_depth_limit.phpt
@@ -0,0 +1,46 @@
+--TEST--
+Shape alias: recursion depth limit prevents infinite loops
+--XLEAK--
+--FILE--
+<?php
+
+
+// This test verifies that the recursion depth limit (64) prevents
+// infinite loops when shapes reference themselves
+
+shape RecursiveShape = array{
+    id: int,
+    child?: RecursiveShape
+};
+
+function processShape(RecursiveShape $shape): int {
+    $count = 1;
+    if (isset($shape['child'])) {
+        $count += processShape($shape['child']);
+    }
+    return $count;
+}
+
+// Build a deeply nested structure (but within limits)
+function buildNested(int $depth): array {
+    if ($depth <= 0) {
+        return ['id' => 0];
+    }
+    return ['id' => $depth, 'child' => buildNested($depth - 1)];
+}
+
+// Test with 50 levels (within 64 limit)
+$nested = buildNested(50);
+echo "Depth 50: " . processShape($nested) . " nodes\n";
+
+// Test with 60 levels (still within 64 limit)
+$nested = buildNested(60);
+echo "Depth 60: " . processShape($nested) . " nodes\n";
+
+echo "Recursion limit working correctly\n";
+
+?>
+--EXPECT--
+Depth 50: 51 nodes
+Depth 60: 61 nodes
+Recursion limit working correctly
diff --git a/Zend/tests/typed_arrays/shape_wrong_type_error.phpt b/Zend/tests/typed_arrays/shape_wrong_type_error.phpt
new file mode 100644
index 00000000..62fa8776
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_wrong_type_error.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Array shape: error when key has wrong type
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return [
+        'id' => "not_an_int",  // Wrong type!
+        'name' => 'Alice'
+    ];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getUser(): Return value must be of type array{id: int, ...}, array key "id" is string
diff --git a/Zend/tests/typed_arrays/static_property_typed_array.phpt b/Zend/tests/typed_arrays/static_property_typed_array.phpt
new file mode 100644
index 00000000..ed98138a
--- /dev/null
+++ b/Zend/tests/typed_arrays/static_property_typed_array.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Static property: typed array in static class property
+--FILE--
+<?php
+
+
+class Registry {
+    private static array<string> $items = [];
+
+    public static function add(string $item): void {
+        self::$items[] = $item;
+    }
+
+    public static function getAll(): array<string> {
+        return self::$items;
+    }
+
+    public static function clear(): void {
+        self::$items = [];
+    }
+}
+
+Registry::add("item1");
+Registry::add("item2");
+echo "Items: " . implode(", ", Registry::getAll()) . "\n";
+
+Registry::clear();
+echo "After clear: " . count(Registry::getAll()) . " items\n";
+
+?>
+--EXPECT--
+Items: item1, item2
+After clear: 0 items
diff --git a/Zend/tests/typed_arrays/trait_typed_array.phpt b/Zend/tests/typed_arrays/trait_typed_array.phpt
new file mode 100644
index 00000000..e293847c
--- /dev/null
+++ b/Zend/tests/typed_arrays/trait_typed_array.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Trait: typed array in trait method
+--FILE--
+<?php
+
+
+trait Taggable {
+    private array<string> $tags = [];
+
+    public function addTag(string $tag): void {
+        $this->tags[] = $tag;
+    }
+
+    public function getTags(): array<string> {
+        return $this->tags;
+    }
+}
+
+class Article {
+    use Taggable;
+
+    public function __construct(public string $title) {}
+}
+
+$article = new Article("PHP Typed Arrays");
+$article->addTag("php");
+$article->addTag("types");
+$article->addTag("arrays");
+
+echo "Title: {$article->title}\n";
+echo "Tags: " . implode(", ", $article->getTags()) . "\n";
+
+?>
+--EXPECT--
+Title: PHP Typed Arrays
+Tags: php, types, arrays
diff --git a/Zend/tests/typed_arrays/typed_array_empty.phpt b/Zend/tests/typed_arrays/typed_array_empty.phpt
new file mode 100644
index 00000000..43d97c8e
--- /dev/null
+++ b/Zend/tests/typed_arrays/typed_array_empty.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Typed array: empty array is valid for any typed array
+--XLEAK--
+--FILE--
+<?php
+
+
+function getInts(): array<int> {
+    return [];
+}
+
+function getStrings(): array<string> {
+    return [];
+}
+
+function getUsers(): array<array{id: int, name: string}> {
+    return [];
+}
+
+var_dump(getInts());
+var_dump(getStrings());
+var_dump(getUsers());
+
+?>
+--EXPECT--
+array(0) {
+}
+array(0) {
+}
+array(0) {
+}
diff --git a/Zend/tests/typed_arrays/typed_array_property_error.phpt b/Zend/tests/typed_arrays/typed_array_property_error.phpt
new file mode 100644
index 00000000..89e95e13
--- /dev/null
+++ b/Zend/tests/typed_arrays/typed_array_property_error.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Typed array: property assignment type error
+--XLEAK--
+--FILE--
+<?php
+
+
+class Counter {
+    public array<int> $counts = [];
+}
+
+$c = new Counter();
+
+// Valid assignment
+$c->counts = [1, 2, 3];
+echo "Valid assignment: OK\n";
+
+// Invalid assignment - string in int array
+try {
+    $c->counts = [1, 'two', 3];
+} catch (TypeError $e) {
+    echo "Invalid assignment: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Valid assignment: OK
+Invalid assignment: Cannot assign to property Counter::$counts of type array<int>, array element at index 1 is string
diff --git a/Zend/tests/typed_arrays/typed_array_with_shape.phpt b/Zend/tests/typed_arrays/typed_array_with_shape.phpt
new file mode 100644
index 00000000..e06e0ce0
--- /dev/null
+++ b/Zend/tests/typed_arrays/typed_array_with_shape.phpt
@@ -0,0 +1,27 @@
+--TEST--
+Typed array: array<shape> combining typed arrays with shapes
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUsers(): array<array{id: int, name: string}> {
+    return [
+        ['id' => 1, 'name' => 'Alice'],
+        ['id' => 2, 'name' => 'Bob'],
+        ['id' => 3, 'name' => 'Charlie'],
+    ];
+}
+
+$users = getUsers();
+echo "Found " . count($users) . " users:\n";
+foreach ($users as $user) {
+    echo "  - {$user['name']} (ID: {$user['id']})\n";
+}
+
+?>
+--EXPECT--
+Found 3 users:
+  - Alice (ID: 1)
+  - Bob (ID: 2)
+  - Charlie (ID: 3)
diff --git a/Zend/tests/typed_arrays/union_shape.phpt b/Zend/tests/typed_arrays/union_shape.phpt
new file mode 100644
index 00000000..6d093c51
--- /dev/null
+++ b/Zend/tests/typed_arrays/union_shape.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Union types: array shape in union with null
+--XLEAK--
+--FILE--
+<?php
+
+
+function findUser(int $id): array{id: int, name: string}|null {
+    if ($id === 1) {
+        return ['id' => 1, 'name' => 'Alice'];
+    }
+    return null;
+}
+
+$user = findUser(1);
+echo "Found: " . ($user ? $user['name'] : "nobody") . "\n";
+
+$nobody = findUser(999);
+echo "Found: " . ($nobody ? $nobody['name'] : "nobody") . "\n";
+
+?>
+--EXPECT--
+Found: Alice
+Found: nobody
diff --git a/Zend/tests/typed_arrays/union_typed_array.phpt b/Zend/tests/typed_arrays/union_typed_array.phpt
new file mode 100644
index 00000000..6ace0b70
--- /dev/null
+++ b/Zend/tests/typed_arrays/union_typed_array.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Union types: typed array in union with null
+--FILE--
+<?php
+
+
+function getNumbers(): array<int>|null {
+    return [1, 2, 3];
+}
+
+function getNothing(): array<int>|null {
+    return null;
+}
+
+$nums = getNumbers();
+echo "Numbers: " . ($nums ? implode(", ", $nums) : "none") . "\n";
+
+$nothing = getNothing();
+echo "Nothing: " . ($nothing ? implode(", ", $nothing) : "none") . "\n";
+
+?>
+--EXPECT--
+Numbers: 1, 2, 3
+Nothing: none
diff --git a/Zend/tests/typed_arrays/variadic_typed_array.phpt b/Zend/tests/typed_arrays/variadic_typed_array.phpt
new file mode 100644
index 00000000..c4b92afc
--- /dev/null
+++ b/Zend/tests/typed_arrays/variadic_typed_array.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Edge case: variadic parameter with typed array
+--FILE--
+<?php
+
+
+function mergeArrays(array<int> ...$arrays): array<int> {
+    $result = [];
+    foreach ($arrays as $arr) {
+        $result = array_merge($result, $arr);
+    }
+    return $result;
+}
+
+$merged = mergeArrays([1, 2], [3, 4], [5, 6]);
+echo "Merged: " . implode(", ", $merged) . "\n";
+
+?>
+--EXPECT--
+Merged: 1, 2, 3, 4, 5, 6
diff --git a/Zend/tests/typed_arrays/variance_contravariant_param.phpt b/Zend/tests/typed_arrays/variance_contravariant_param.phpt
new file mode 100644
index 00000000..ac677cc4
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_contravariant_param.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Variance: contravariant parameter type - child can accept more general typed array
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+
+class AnimalProcessor {
+    public function process(array<Dog> $dogs): void {
+        echo "Processing " . count($dogs) . " dogs\n";
+    }
+}
+
+class GeneralProcessor extends AnimalProcessor {
+    // Contravariant: array<Animal> is more general than array<Dog>
+    public function process(array<Animal> $animals): void {
+        echo "Processing " . count($animals) . " animals\n";
+    }
+}
+
+$processor = new GeneralProcessor();
+$processor->process([new Dog(), new Dog()]);
+
+?>
+--EXPECT--
+Processing 2 animals
diff --git a/Zend/tests/typed_arrays/variance_covariant_return.phpt b/Zend/tests/typed_arrays/variance_covariant_return.phpt
new file mode 100644
index 00000000..d8e5fbc1
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_covariant_return.phpt
@@ -0,0 +1,32 @@
+--TEST--
+Variance: covariant return type - child can return more specific typed array
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+class Cat extends Animal {}
+
+class AnimalShelter {
+    public function getAnimals(): array<Animal> {
+        return [new Animal(), new Animal()];
+    }
+}
+
+class DogShelter extends AnimalShelter {
+    // Covariant: array<Dog> is more specific than array<Animal>
+    public function getAnimals(): array<Dog> {
+        return [new Dog(), new Dog()];
+    }
+}
+
+$shelter = new DogShelter();
+$dogs = $shelter->getAnimals();
+echo "Got " . count($dogs) . " dogs\n";
+echo "First is Dog: " . ($dogs[0] instanceof Dog ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Got 2 dogs
+First is Dog: yes
diff --git a/Zend/tests/typed_arrays/variance_invalid_contravariant.phpt b/Zend/tests/typed_arrays/variance_invalid_contravariant.phpt
new file mode 100644
index 00000000..294ea8a4
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_invalid_contravariant.phpt
@@ -0,0 +1,29 @@
+--TEST--
+Variance: valid contravariant parameter - child can accept more general type
+--XLEAK--
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+
+class DogProcessor {
+    public function process(array<Dog> $dogs): void {
+        echo "Processing dogs\n";
+    }
+}
+
+class AnimalProcessor extends DogProcessor {
+    // Valid: array<Animal> is more general than array<Dog> for parameters
+    public function process(array<Animal> $animals): void {
+        echo "Processing animals\n";
+    }
+}
+
+$processor = new AnimalProcessor();
+$processor->process([new Dog()]);
+
+?>
+--EXPECT--
+Processing animals
diff --git a/Zend/tests/typed_arrays/variance_invalid_covariant.phpt b/Zend/tests/typed_arrays/variance_invalid_covariant.phpt
new file mode 100644
index 00000000..6fbb8d9d
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_invalid_covariant.phpt
@@ -0,0 +1,30 @@
+--TEST--
+Variance: valid covariant return - child can return more specific type
+--XLEAK--
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+
+class AnimalShelter {
+    public function getAnimals(): array<Animal> {
+        return [new Animal()];
+    }
+}
+
+class DogShelter extends AnimalShelter {
+    // Valid: array<Dog> is more specific than array<Animal> for return types
+    public function getAnimals(): array<Dog> {
+        return [new Dog()];
+    }
+}
+
+$shelter = new DogShelter();
+$dogs = $shelter->getAnimals();
+echo "Got " . count($dogs) . " dogs\n";
+
+?>
+--EXPECT--
+Got 1 dogs
diff --git a/Zend/zend.c b/Zend/zend.c
index 045d2513..a311fa8f 100644
--- a/Zend/zend.c
+++ b/Zend/zend.c
@@ -57,17 +57,20 @@ static HashTable *global_function_table = NULL;
 static HashTable *global_class_table = NULL;
 static HashTable *global_constants_table = NULL;
 static HashTable *global_auto_globals_table = NULL;
+static HashTable *global_shape_table = NULL;
 static HashTable *global_persistent_list = NULL;
 TSRMLS_MAIN_CACHE_DEFINE()
 # define GLOBAL_FUNCTION_TABLE		global_function_table
 # define GLOBAL_CLASS_TABLE			global_class_table
 # define GLOBAL_CONSTANTS_TABLE		global_constants_table
 # define GLOBAL_AUTO_GLOBALS_TABLE	global_auto_globals_table
+# define GLOBAL_SHAPE_TABLE			global_shape_table
 #else
 # define GLOBAL_FUNCTION_TABLE		CG(function_table)
 # define GLOBAL_CLASS_TABLE			CG(class_table)
 # define GLOBAL_AUTO_GLOBALS_TABLE	CG(auto_globals)
 # define GLOBAL_CONSTANTS_TABLE		EG(zend_constants)
+# define GLOBAL_SHAPE_TABLE			CG(shape_table)
 #endif
 
 ZEND_API zend_utility_values zend_uv;
@@ -724,6 +727,10 @@ static void compiler_globals_ctor(zend_compiler_globals *compiler_globals) /* {{
 	zend_hash_init(compiler_globals->class_table, 64, NULL, ZEND_CLASS_DTOR, 1);
 	zend_hash_copy(compiler_globals->class_table, global_class_table, zend_class_add_ref);
 
+	compiler_globals->shape_table = (HashTable *) malloc(sizeof(HashTable));
+	zend_hash_init(compiler_globals->shape_table, 32, NULL, zend_shape_dtor, 1);
+	zend_hash_copy(compiler_globals->shape_table, global_shape_table, NULL);
+
 	zend_set_default_compile_time_values();
 
 	compiler_globals->auto_globals = (HashTable *) malloc(sizeof(HashTable));
@@ -781,6 +788,10 @@ static void compiler_globals_dtor(zend_compiler_globals *compiler_globals) /* {{
 		zend_hash_destroy(compiler_globals->auto_globals);
 		free(compiler_globals->auto_globals);
 	}
+	if (compiler_globals->shape_table != GLOBAL_SHAPE_TABLE) {
+		zend_hash_destroy(compiler_globals->shape_table);
+		free(compiler_globals->shape_table);
+	}
 	if (compiler_globals->script_encoding_list) {
 		pefree((char*)compiler_globals->script_encoding_list, 1);
 	}
@@ -914,6 +925,59 @@ static bool php_auto_globals_create_globals(zend_string *name) /* {{{ */
 }
 /* }}} */
 
+static void zend_shape_type_free(zend_type type) /* {{{ */
+{
+	/* Free array shape structure and its elements */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(type);
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			if (shape->elements[i].key) {
+				zend_string_release(shape->elements[i].key);
+			}
+			/* Recursively free element types */
+			zend_shape_type_free(shape->elements[i].type);
+		}
+		/* Free cached expected_keys hash table for closed shapes */
+		if (shape->expected_keys) {
+			zend_hash_destroy(shape->expected_keys);
+			pefree(shape->expected_keys, 1);
+		}
+		pefree(shape, 1);
+	} else if ((type.type_mask & (1u << IS_ARRAY)) && type.ptr != NULL
+			&& !ZEND_TYPE_IS_COMPLEX(type)) {
+		/* Free typed array element structure */
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(type);
+		zend_shape_type_free(elem->element_type);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_shape_type_free(elem->key_type);
+		}
+		pefree(elem, 1);
+	} else if (ZEND_TYPE_HAS_NAME(type)) {
+		/* Free type name if present */
+		zend_string_release(ZEND_TYPE_NAME(type));
+	} else if (ZEND_TYPE_HAS_LIST(type)) {
+		/* Handle type lists (unions) */
+		zend_type *list_type;
+		ZEND_TYPE_LIST_FOREACH(ZEND_TYPE_LIST(type), list_type) {
+			zend_shape_type_free(*list_type);
+		} ZEND_TYPE_LIST_FOREACH_END();
+		pefree(ZEND_TYPE_LIST(type), 1);
+	}
+}
+/* }}} */
+
+static void zend_shape_dtor(zval *zv) /* {{{ */
+{
+	zend_shape_entry *entry = Z_PTR_P(zv);
+	if (entry->name) {
+		zend_string_release(entry->name);
+	}
+	/* Free the type data (allocated with pemalloc) */
+	zend_shape_type_free(entry->type);
+	pefree(entry, 1);
+}
+/* }}} */
+
 void zend_startup(zend_utility_functions *utility_functions) /* {{{ */
 {
 #ifdef ZTS
@@ -1008,11 +1072,13 @@ void zend_startup(zend_utility_functions *utility_functions) /* {{{ */
 	GLOBAL_CLASS_TABLE = (HashTable *) malloc(sizeof(HashTable));
 	GLOBAL_AUTO_GLOBALS_TABLE = (HashTable *) malloc(sizeof(HashTable));
 	GLOBAL_CONSTANTS_TABLE = (HashTable *) malloc(sizeof(HashTable));
+	GLOBAL_SHAPE_TABLE = (HashTable *) malloc(sizeof(HashTable));
 
 	zend_hash_init(GLOBAL_FUNCTION_TABLE, 1024, NULL, ZEND_FUNCTION_DTOR, 1);
 	zend_hash_init(GLOBAL_CLASS_TABLE, 64, NULL, ZEND_CLASS_DTOR, 1);
 	zend_hash_init(GLOBAL_AUTO_GLOBALS_TABLE, 8, NULL, auto_global_dtor, 1);
 	zend_hash_init(GLOBAL_CONSTANTS_TABLE, 128, NULL, ZEND_CONSTANT_DTOR, 1);
+	zend_hash_init(GLOBAL_SHAPE_TABLE, 32, NULL, zend_shape_dtor, 1);
 
 	zend_hash_init(&module_registry, 32, NULL, module_destructor_zval, 1);
 	zend_init_rsrc_list_dtors();
@@ -1029,9 +1095,11 @@ void zend_startup(zend_utility_functions *utility_functions) /* {{{ */
 	compiler_globals->in_compilation = 0;
 	compiler_globals->function_table = (HashTable *) malloc(sizeof(HashTable));
 	compiler_globals->class_table = (HashTable *) malloc(sizeof(HashTable));
+	compiler_globals->shape_table = (HashTable *) malloc(sizeof(HashTable));
 
 	*compiler_globals->function_table = *GLOBAL_FUNCTION_TABLE;
 	*compiler_globals->class_table = *GLOBAL_CLASS_TABLE;
+	*compiler_globals->shape_table = *GLOBAL_SHAPE_TABLE;
 	compiler_globals->auto_globals = GLOBAL_AUTO_GLOBALS_TABLE;
 
 	zend_hash_destroy(executor_globals->zend_constants);
diff --git a/Zend/zend_ast.c b/Zend/zend_ast.c
index 9cb3c7aa..096780e3 100644
--- a/Zend/zend_ast.c
+++ b/Zend/zend_ast.c
@@ -129,6 +129,9 @@ ZEND_API zend_ast * ZEND_FASTCALL zend_ast_create_class_const_or_name(zend_ast *
 	if (zend_string_equals_ci(name_str, ZSTR_KNOWN(ZEND_STR_CLASS))) {
 		zend_string_release(name_str);
 		return zend_ast_create(ZEND_AST_CLASS_NAME, class_name);
+	} else if (zend_string_equals_literal_ci(name_str, "shape")) {
+		zend_string_release(name_str);
+		return zend_ast_create(ZEND_AST_SHAPE_NAME, class_name);
 	} else {
 		return zend_ast_create(ZEND_AST_CLASS_CONST, class_name, name);
 	}
diff --git a/Zend/zend_ast.h b/Zend/zend_ast.h
index fb48b187..adf37406 100644
--- a/Zend/zend_ast.h
+++ b/Zend/zend_ast.h
@@ -70,6 +70,7 @@ enum _zend_ast_kind {
 	ZEND_AST_ATTRIBUTE_GROUP,
 	ZEND_AST_MATCH_ARM_LIST,
 	ZEND_AST_MODIFIER_LIST,
+	ZEND_AST_SHAPE_ELEMENT_LIST,
 
 	/* 0 child nodes */
 	ZEND_AST_MAGIC_CONST = 0 << ZEND_AST_NUM_CHILDREN_SHIFT,
@@ -80,6 +81,8 @@ enum _zend_ast_kind {
 	/* 1 child node */
 	ZEND_AST_VAR = 1 << ZEND_AST_NUM_CHILDREN_SHIFT,
 	ZEND_AST_CONST,
+	ZEND_AST_TYPE_ARRAY_OF,
+	ZEND_AST_TYPE_ARRAY_SHAPE,
 	ZEND_AST_UNPACK,
 	ZEND_AST_UNARY_PLUS,
 	ZEND_AST_UNARY_MINUS,
@@ -98,6 +101,7 @@ enum _zend_ast_kind {
 	ZEND_AST_POST_DEC,
 	ZEND_AST_YIELD_FROM,
 	ZEND_AST_CLASS_NAME,
+	ZEND_AST_SHAPE_NAME,
 
 	ZEND_AST_GLOBAL,
 	ZEND_AST_UNSET,
@@ -115,6 +119,8 @@ enum _zend_ast_kind {
 	/* 2 child nodes */
 	ZEND_AST_DIM = 2 << ZEND_AST_NUM_CHILDREN_SHIFT,
 	ZEND_AST_PROP,
+	ZEND_AST_SHAPE_ELEMENT,
+	ZEND_AST_TYPE_ARRAY_MAP,
 	ZEND_AST_NULLSAFE_PROP,
 	ZEND_AST_STATIC_PROP,
 	ZEND_AST_CALL,
@@ -169,6 +175,7 @@ enum _zend_ast_kind {
 
 	// Pseudo node for initializing enums
 	ZEND_AST_CONST_ENUM_INIT,
+	ZEND_AST_SHAPE_DECL,
 
 	/* 4 child nodes */
 	ZEND_AST_FOR = 4 << ZEND_AST_NUM_CHILDREN_SHIFT,
diff --git a/Zend/zend_builtin_functions.c b/Zend/zend_builtin_functions.c
index 0d8be49a..018f4b20 100644
--- a/Zend/zend_builtin_functions.c
+++ b/Zend/zend_builtin_functions.c
@@ -1196,6 +1196,41 @@ ZEND_FUNCTION(enum_exists)
 	class_exists_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, ZEND_ACC_ENUM, 0);
 }
 
+/* {{{ Checks if the shape type alias exists */
+ZEND_FUNCTION(shape_exists)
+{
+	zend_string *name;
+	bool autoload = true;
+	zend_string *lcname;
+	zend_shape_entry *shape;
+
+	ZEND_PARSE_PARAMETERS_START(1, 2)
+		Z_PARAM_STR(name)
+		Z_PARAM_OPTIONAL
+		Z_PARAM_BOOL(autoload)
+	ZEND_PARSE_PARAMETERS_END();
+
+	if (ZSTR_VAL(name)[0] == '\\') {
+		/* Ignore leading "\" */
+		lcname = zend_string_alloc(ZSTR_LEN(name) - 1, 0);
+		zend_str_tolower_copy(ZSTR_VAL(lcname), ZSTR_VAL(name) + 1, ZSTR_LEN(name) - 1);
+	} else {
+		lcname = zend_string_tolower(name);
+	}
+
+	if (!autoload) {
+		/* Check the shape table without autoloading */
+		shape = zend_hash_find_ptr(EG(shape_table), lcname);
+	} else {
+		/* Use zend_lookup_shape which supports autoloading */
+		shape = zend_lookup_shape_ex(name, lcname, 0);
+	}
+
+	zend_string_release_ex(lcname, 0);
+	RETURN_BOOL(shape != NULL);
+}
+/* }}} */
+
 /* {{{ Checks if the function exists */
 ZEND_FUNCTION(function_exists)
 {
diff --git a/Zend/zend_builtin_functions.stub.php b/Zend/zend_builtin_functions.stub.php
index 9b2267b5..ea63774f 100644
--- a/Zend/zend_builtin_functions.stub.php
+++ b/Zend/zend_builtin_functions.stub.php
@@ -94,6 +94,8 @@ function trait_exists(string $trait, bool $autoload = true): bool {}
 
 function enum_exists(string $enum, bool $autoload = true): bool {}
 
+function shape_exists(string $shape, bool $autoload = true): bool {}
+
 function function_exists(string $function): bool {}
 
 function class_alias(string $class, string $alias, bool $autoload = true): bool {}
diff --git a/Zend/zend_builtin_functions_arginfo.h b/Zend/zend_builtin_functions_arginfo.h
index cf349b55..b7fcf746 100644
Binary files a/Zend/zend_builtin_functions_arginfo.h and b/Zend/zend_builtin_functions_arginfo.h differ
diff --git a/Zend/zend_compile.c b/Zend/zend_compile.c
index 8be1ee14..f7ed37b8 100644
--- a/Zend/zend_compile.c
+++ b/Zend/zend_compile.c
@@ -38,6 +38,7 @@
 #include "zend_call_stack.h"
 #include "zend_frameless_function.h"
 #include "zend_property_hooks.h"
+#include "zend_smart_str.h"
 
 #define SET_NODE(target, src) do { \
 		target ## _type = (src)->op_type; \
@@ -403,6 +404,7 @@ void zend_file_context_begin(zend_file_context *prev_context) /* {{{ */
 	FC(imports) = NULL;
 	FC(imports_function) = NULL;
 	FC(imports_const) = NULL;
+	FC(shapes) = NULL;
 	FC(current_namespace) = NULL;
 	FC(in_namespace) = 0;
 	FC(has_bracketed_namespaces) = 0;
@@ -415,6 +417,11 @@ void zend_file_context_end(zend_file_context *prev_context) /* {{{ */
 {
 	zend_end_namespace();
 	zend_hash_destroy(&FC(seen_symbols));
+	if (FC(shapes)) {
+		zend_hash_destroy(FC(shapes));
+		efree(FC(shapes));
+		FC(shapes) = NULL;
+	}
 	CG(file_context) = *prev_context;
 }
 /* }}} */
@@ -1478,7 +1485,54 @@ zend_string *zend_type_to_string_resolved(const zend_type type, zend_class_entry
 		str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_OBJECT), /* is_intersection */ false);
 	}
 	if (type_mask & MAY_BE_ARRAY) {
-		str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_ARRAY), /* is_intersection */ false);
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(type)) {
+			zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(type);
+			zend_string *elem_str = zend_type_to_string(elem->element_type);
+			if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem)) {
+				zend_string *key_str = zend_type_to_string(elem->key_type);
+				zend_string *array_str = zend_string_concat3(
+					"array<", 6, ZSTR_VAL(key_str), ZSTR_LEN(key_str), ", ", 2);
+				zend_string *full_str = zend_string_concat3(
+					ZSTR_VAL(array_str), ZSTR_LEN(array_str),
+					ZSTR_VAL(elem_str), ZSTR_LEN(elem_str), ">", 1);
+				zend_string_release(key_str);
+				zend_string_release(array_str);
+				zend_string_release(elem_str);
+				str = add_type_string(str, full_str, /* is_intersection */ false);
+				zend_string_release(full_str);
+			} else {
+				zend_string *array_str = zend_string_concat3(
+					"array<", 6, ZSTR_VAL(elem_str), ZSTR_LEN(elem_str), ">", 1);
+				zend_string_release(elem_str);
+				str = add_type_string(str, array_str, /* is_intersection */ false);
+				zend_string_release(array_str);
+			}
+		} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(type);
+			smart_str buf = {0};
+			smart_str_appends(&buf, "array{");
+			for (uint32_t i = 0; i < shape->num_elements; i++) {
+				if (i > 0) {
+					smart_str_appends(&buf, ", ");
+				}
+				zend_array_shape_element *elem = &shape->elements[i];
+				smart_str_append(&buf, elem->key);
+				if (elem->is_optional) {
+					smart_str_appendc(&buf, '?');
+				}
+				smart_str_appends(&buf, ": ");
+				zend_string *elem_type_str = zend_type_to_string(elem->type);
+				smart_str_append(&buf, elem_type_str);
+				zend_string_release(elem_type_str);
+			}
+			smart_str_appendc(&buf, '}');
+			if (shape->is_closed) {
+				smart_str_appendc(&buf, '!');
+			}
+			str = add_type_string(str, smart_str_extract(&buf), /* is_intersection */ false);
+		} else {
+			str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_ARRAY), /* is_intersection */ false);
+		}
 	}
 	if (type_mask & MAY_BE_STRING) {
 		str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_STRING), /* is_intersection */ false);
@@ -2617,6 +2671,83 @@ static void zend_compile_memoized_expr(znode *result, zend_ast *expr) /* {{{ */
 }
 /* }}} */
 
+/* Forward declaration for recursive compile-time array validation */
+static bool zend_const_array_elements_match_type(zval *arr, const zend_type *element_type);
+
+/* Check if a constant value matches a type at compile time (for escape analysis) */
+static bool zend_const_value_matches_type(zval *val, const zend_type *type)
+{
+	uint32_t type_mask = ZEND_TYPE_PURE_MASK(*type);
+	uint8_t val_type = Z_TYPE_P(val);
+
+	/* Handle nested array types: array<T> where T might be another array<U> */
+	if (ZEND_TYPE_HAS_ARRAY_ELEMENT(*type)) {
+		/* This type is array<T> - value must be an array with matching elements */
+		if (val_type != IS_ARRAY) {
+			return false;
+		}
+		/* Recursively validate inner elements */
+		const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		return zend_const_array_elements_match_type(val, &elem_type->element_type);
+	}
+
+	/* Check simple type masks */
+	if (type_mask & (1u << val_type)) {
+		return true;
+	}
+
+	/* Special case: int can match float type */
+	if ((type_mask & MAY_BE_DOUBLE) && val_type == IS_LONG) {
+		return true;
+	}
+
+	/* Special case: bool matches both TRUE and FALSE */
+	if ((type_mask & MAY_BE_BOOL) && (val_type == IS_TRUE || val_type == IS_FALSE)) {
+		return true;
+	}
+
+	/* Can't verify object/class types at compile time */
+	if (ZEND_TYPE_HAS_NAME(*type) || ZEND_TYPE_HAS_LIST(*type)) {
+		/* Check if it's a union of simple types only */
+		if (ZEND_TYPE_HAS_LIST(*type)) {
+			const zend_type_list *list = ZEND_TYPE_LIST(*type);
+			/* Check each type in the union */
+			for (uint32_t i = 0; i < list->num_types; i++) {
+				const zend_type *single = &list->types[i];
+				/* If any type in union is a class, we can't verify at compile time */
+				if (ZEND_TYPE_HAS_NAME(*single)) {
+					return false;
+				}
+			}
+			/* All types in union are simple - check if value matches any */
+			return (type_mask & (1u << val_type)) ||
+			       ((type_mask & MAY_BE_DOUBLE) && val_type == IS_LONG) ||
+			       ((type_mask & MAY_BE_BOOL) && (val_type == IS_TRUE || val_type == IS_FALSE));
+		}
+		return false;
+	}
+
+	return false;
+}
+
+/* Check if a constant array's elements all match the expected type (compile-time escape analysis) */
+static bool zend_const_array_elements_match_type(zval *arr, const zend_type *element_type)
+{
+	zval *val;
+
+	/* Can't verify object/class types at compile time (unless it's a union of scalars) */
+	if (ZEND_TYPE_HAS_NAME(*element_type)) {
+		return false;
+	}
+
+	ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(arr), val) {
+		if (!zend_const_value_matches_type(val, element_type)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
 static void zend_emit_return_type_check(
 		znode *expr, zend_arg_info *return_info, bool implicit) /* {{{ */
 {
@@ -2669,8 +2800,25 @@ static void zend_emit_return_type_check(
 		}
 
 		if (expr && expr->op_type == IS_CONST && ZEND_TYPE_CONTAINS_CODE(type, Z_TYPE(expr->u.constant))) {
-			/* we don't need run-time check */
-			return;
+			/* we don't need run-time check, unless we have array element type info or shape to validate */
+			if (!ZEND_TYPE_HAS_ARRAY_ELEMENT(type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+				return;
+			}
+			/* Escape analysis: if constant array elements all match the type, skip runtime check */
+			/* Note: Only apply escape analysis to array<T> types, not array shapes */
+			if (Z_TYPE(expr->u.constant) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(type)) {
+				const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(type);
+				if (elem_type) {
+					/* If there's a key type constraint, we can't skip runtime check
+					 * (compile-time key type validation would need additional implementation) */
+					if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+						/* Fall through to emit runtime check */
+					} else if (zend_const_array_elements_match_type(&expr->u.constant, &elem_type->element_type)) {
+						/* Try to verify at compile time (works for primitive types and unions of primitives) */
+						return; /* All elements match - no runtime check needed */
+					}
+				}
+			}
 		}
 
 		opline = zend_emit_op(NULL, ZEND_VERIFY_RETURN_TYPE, expr, NULL);
@@ -7028,6 +7176,29 @@ static void zend_compile_declare(zend_ast *ast) /* {{{ */
 				CG(active_op_array)->fn_flags |= ZEND_ACC_STRICT_TYPES;
 			}
 
+		} else if (zend_string_equals_literal_ci(name, "strict_arrays")) {
+			zval value_zv;
+
+			if (FAILURE == zend_is_first_statement(ast, /* allow_nop */ true)) {
+				zend_error_noreturn(E_COMPILE_ERROR, "strict_arrays declaration must be "
+					"the very first statement in the script");
+			}
+
+			if (ast->child[1] != NULL) {
+				zend_error_noreturn(E_COMPILE_ERROR, "strict_arrays declaration must not "
+					"use block mode");
+			}
+
+			zend_const_expr_to_zval(&value_zv, value_ast_ptr, /* allow_dynamic */ false);
+
+			if (Z_TYPE(value_zv) != IS_LONG || (Z_LVAL(value_zv) != 0 && Z_LVAL(value_zv) != 1)) {
+				zend_error_noreturn(E_COMPILE_ERROR, "strict_arrays declaration must have 0 or 1 as its value");
+			}
+
+			if (Z_LVAL(value_zv) == 1) {
+				CG(active_op_array)->fn_flags |= ZEND_ACC_STRICT_ARRAYS;
+			}
+
 		} else {
 			zend_error(E_COMPILE_WARNING, "Unsupported declare '%s'", ZSTR_VAL(name));
 		}
@@ -7076,6 +7247,9 @@ ZEND_API void zend_set_function_arg_flags(zend_function *func) /* {{{ */
 }
 /* }}} */
 
+/* Forward declaration for recursive type compilation */
+static zend_type zend_compile_typename(zend_ast *ast);
+
 static zend_type zend_compile_single_typename(zend_ast *ast)
 {
 	ZEND_ASSERT(!(ast->attr & ZEND_TYPE_NULLABLE));
@@ -7086,6 +7260,81 @@ static zend_type zend_compile_single_typename(zend_ast *ast)
 		}
 
 		return (zend_type) ZEND_TYPE_INIT_CODE(ast->attr, 0, 0);
+	} else if (ast->kind == ZEND_AST_TYPE_ARRAY_OF) {
+		/* array<T> */
+		zend_ast *element_type_ast = ast->child[0];
+		zend_typed_array_element *elem_type = zend_arena_alloc(&CG(arena), sizeof(zend_typed_array_element));
+		elem_type->element_type = zend_compile_typename(element_type_ast);
+		elem_type->key_type = (zend_type) ZEND_TYPE_INIT_NONE(0);
+
+		zend_type type;
+		type.type_mask = (1u << IS_ARRAY);
+		type.ptr = elem_type;
+		return type;
+	} else if (ast->kind == ZEND_AST_TYPE_ARRAY_MAP) {
+		/* array<K, V> */
+		zend_ast *key_type_ast = ast->child[0];
+		zend_ast *value_type_ast = ast->child[1];
+		zend_typed_array_element *elem_type = zend_arena_alloc(&CG(arena), sizeof(zend_typed_array_element));
+
+		zend_type key_type = zend_compile_typename(key_type_ast);
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(key_type);
+		if (!ZEND_TYPE_IS_ONLY_MASK(key_type) ||
+		    (key_mask != MAY_BE_LONG && key_mask != MAY_BE_STRING &&
+		     key_mask != (MAY_BE_LONG | MAY_BE_STRING))) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Array key type must be int, string, or int|string");
+		}
+
+		elem_type->key_type = key_type;
+		elem_type->element_type = zend_compile_typename(value_type_ast);
+
+		zend_type type;
+		type.type_mask = (1u << IS_ARRAY);
+		type.ptr = elem_type;
+		return type;
+	} else if (ast->kind == ZEND_AST_TYPE_ARRAY_SHAPE) {
+		/* array{key: type, ...} or array{key: type, ...}! (closed) */
+		zend_ast *element_list = ast->child[0];
+		uint32_t num_elements = element_list ? zend_ast_get_list(element_list)->children : 0;
+		uint32_t num_required = 0;
+		bool is_closed = (ast->attr != 0);
+
+		/* Validate element count to prevent excessive memory allocation */
+		if (UNEXPECTED(num_elements > ZEND_SHAPE_MAX_ELEMENTS)) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Array shape cannot have more than %d elements", ZEND_SHAPE_MAX_ELEMENTS);
+		}
+
+		size_t shape_size = sizeof(zend_array_shape) + num_elements * sizeof(zend_array_shape_element);
+		zend_array_shape *shape = zend_arena_alloc(&CG(arena), shape_size);
+		shape->num_elements = num_elements;
+		shape->is_closed = is_closed;
+		shape->expected_keys = NULL;  /* Will be built during persistence for closed shapes */
+
+		if (element_list) {
+			zend_ast_list *list = zend_ast_get_list(element_list);
+			for (uint32_t i = 0; i < num_elements; i++) {
+				zend_ast *elem_ast = list->child[i];
+				zend_ast *key_ast = elem_ast->child[0];
+				zend_ast *type_ast = elem_ast->child[1];
+				bool is_optional = (elem_ast->attr & ZEND_SHAPE_ELEM_OPTIONAL_FLAG) != 0;
+
+				shape->elements[i].key = zend_string_copy(zend_ast_get_str(key_ast));
+				shape->elements[i].type = zend_compile_typename(type_ast);
+				shape->elements[i].is_optional = is_optional;
+
+				if (!is_optional) {
+					num_required++;
+				}
+			}
+		}
+		shape->num_required = num_required;
+
+		zend_type type;
+		type.type_mask = (1u << IS_ARRAY) | _ZEND_TYPE_ARRAY_SHAPE_BIT;
+		type.ptr = shape;
+		return type;
 	} else {
 		zend_string *type_name = zend_ast_get_str(ast);
 		uint8_t type_code = zend_lookup_builtin_type_by_name(type_name);
@@ -7106,7 +7355,35 @@ static zend_type zend_compile_single_typename(zend_ast *ast)
 			}
 
 			return (zend_type) ZEND_TYPE_INIT_CODE(type_code, 0, 0);
-		} else {
+		}
+
+		/* Check if this is a shape type alias */
+		{
+			zend_string *resolved_name = zend_resolve_class_name_ast(ast);
+			zend_string *lcname = zend_string_tolower(resolved_name);
+			zend_shape_entry *shape = NULL;
+
+			/* First check file-local shapes */
+			if (FC(shapes)) {
+				shape = zend_hash_find_ptr(FC(shapes), lcname);
+			}
+			/* Then check global shape table */
+			if (!shape && CG(shape_table)) {
+				shape = zend_hash_find_ptr(CG(shape_table), lcname);
+			}
+
+			zend_string_release(lcname);
+			zend_string_release(resolved_name);
+
+			if (shape) {
+				return shape->type;
+			}
+			/* If not found, fall through to class handling.
+			 * The class type checking at runtime will check for shapes
+			 * before triggering class autoloading. */
+		}
+
+		{
 			const char *correct_name;
 			uint32_t fetch_type = zend_get_class_fetch_type_ast(ast);
 			zend_string *class_name = type_name;
@@ -8460,6 +8737,7 @@ static zend_op_array *zend_compile_func_decl_ex(
 	}
 
 	op_array->fn_flags |= (orig_op_array->fn_flags & ZEND_ACC_STRICT_TYPES);
+	op_array->fn_flags |= (orig_op_array->fn_flags & ZEND_ACC_STRICT_ARRAYS);
 	op_array->fn_flags |= decl->flags;
 	op_array->line_start = decl->start_lineno;
 	op_array->line_end = decl->end_lineno;
@@ -9321,6 +9599,21 @@ static void zend_compile_class_decl(znode *result, zend_ast *ast, bool toplevel)
 	if (extends_ast) {
 		ce->parent_name =
 			zend_resolve_const_class_name_reference(extends_ast, "class name");
+
+		/* Check that parent is not a shape - classes cannot extend shapes */
+		zend_string *parent_lcname = zend_string_tolower(ce->parent_name);
+		zend_shape_entry *parent_shape = NULL;
+		if (FC(shapes)) {
+			parent_shape = zend_hash_find_ptr(FC(shapes), parent_lcname);
+		}
+		if (!parent_shape && CG(shape_table)) {
+			parent_shape = zend_hash_find_ptr(CG(shape_table), parent_lcname);
+		}
+		zend_string_release(parent_lcname);
+		if (parent_shape) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Class %s cannot extend shape %s", ZSTR_VAL(name), ZSTR_VAL(ce->parent_name));
+		}
 	}
 
 	CG(active_class_entry) = ce;
@@ -9735,6 +10028,413 @@ static void zend_compile_const_decl(zend_ast *ast) /* {{{ */
 }
 /* }}}*/
 
+/* Persist a shape key string using interning when possible.
+ * Tries to find an existing interned string for common keys like "id", "name", etc.
+ * This saves memory and enables fast pointer comparison. */
+static zend_string *zend_persist_shape_key(zend_string *key) /* {{{ */
+{
+	zend_string *interned = zend_string_init_existing_interned(
+		ZSTR_VAL(key), ZSTR_LEN(key), 1);
+	if (interned) {
+		return interned;
+	}
+	/* No existing interned string - create persistent copy */
+	return zend_string_dup(key, 1);
+}
+/* }}} */
+
+/* Copy type data to persistent memory for shape storage.
+ * This is needed because zend_compile_typename uses arena allocation,
+ * but shapes are stored in a persistent table that survives across requests. */
+static zend_type zend_persist_shape_type(zend_type type) /* {{{ */
+{
+	zend_type result = type;
+
+	/* Early return for unset types */
+	if (!ZEND_TYPE_IS_SET(type)) {
+		return result;
+	}
+
+	/* Handle array shape: copy structure to persistent memory */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(type) && type.ptr != NULL) {
+		zend_array_shape *arena_shape = ZEND_ARRAY_SHAPE(type);
+		size_t shape_size = sizeof(zend_array_shape)
+			+ arena_shape->num_elements * sizeof(zend_array_shape_element);
+
+		zend_array_shape *persistent_shape = pemalloc(shape_size, 1);
+		memcpy(persistent_shape, arena_shape, shape_size);
+
+		/* Persist each element's key and type */
+		for (uint32_t i = 0; i < persistent_shape->num_elements; i++) {
+			if (persistent_shape->elements[i].key) {
+				persistent_shape->elements[i].key =
+					zend_persist_shape_key(persistent_shape->elements[i].key);
+			}
+			persistent_shape->elements[i].type =
+				zend_persist_shape_type(persistent_shape->elements[i].type);
+		}
+
+		/* Build cached hash table of expected keys for closed shapes */
+		if (persistent_shape->is_closed && persistent_shape->num_elements > 0) {
+			persistent_shape->expected_keys = pemalloc(sizeof(HashTable), 1);
+			zend_hash_init(persistent_shape->expected_keys, persistent_shape->num_elements, NULL, NULL, 1);
+			for (uint32_t i = 0; i < persistent_shape->num_elements; i++) {
+				zend_hash_add_empty_element(persistent_shape->expected_keys, persistent_shape->elements[i].key);
+			}
+		} else {
+			persistent_shape->expected_keys = NULL;
+		}
+
+		result.ptr = persistent_shape;
+		return result;
+	}
+
+	/* Handle typed array: copy element structure to persistent memory */
+	if ((type.type_mask & (1u << IS_ARRAY)) && type.ptr != NULL
+			&& !ZEND_TYPE_IS_COMPLEX(type)) {
+		zend_typed_array_element *arena_elem = ZEND_TYPED_ARRAY_ELEMENT(type);
+		zend_typed_array_element *persistent_elem = pemalloc(sizeof(zend_typed_array_element), 1);
+
+		persistent_elem->element_type = zend_persist_shape_type(arena_elem->element_type);
+		if (ZEND_TYPE_IS_SET(arena_elem->key_type)) {
+			persistent_elem->key_type = zend_persist_shape_type(arena_elem->key_type);
+		} else {
+			persistent_elem->key_type = arena_elem->key_type;
+		}
+
+		result.ptr = persistent_elem;
+		return result;
+	}
+
+	/* Handle class/type name: copy to persistent memory */
+	if (ZEND_TYPE_HAS_NAME(type) && type.ptr != NULL) {
+		/* Use dup with persistent=1 since arena strings will be freed */
+		zend_string *persistent_name = zend_string_dup(ZEND_TYPE_NAME(type), 1);
+		ZEND_TYPE_SET_PTR(result, persistent_name);
+		return result;
+	}
+
+	/* Handle type lists (unions): copy list to persistent memory */
+	if (ZEND_TYPE_HAS_LIST(type) && type.ptr != NULL) {
+		zend_type_list *arena_list = ZEND_TYPE_LIST(type);
+		size_t list_size = ZEND_TYPE_LIST_SIZE(arena_list->num_types);
+		zend_type_list *persistent_list = pemalloc(list_size, 1);
+
+		persistent_list->num_types = arena_list->num_types;
+		for (uint32_t i = 0; i < arena_list->num_types; i++) {
+			persistent_list->types[i] = zend_persist_shape_type(arena_list->types[i]);
+		}
+
+		ZEND_TYPE_SET_LIST(result, persistent_list);
+		/* Clear arena bit since we're using malloc now */
+		result.type_mask &= ~_ZEND_TYPE_ARENA_BIT;
+		return result;
+	}
+
+	/* Simple type (int, string, etc.) - no allocation needed */
+	return result;
+}
+/* }}} */
+
+/* Helper function to deep copy a zend_type for persistent storage in shape inheritance */
+static zend_type zend_shape_type_deep_copy(zend_type type) /* {{{ */
+{
+	zend_type result = type;
+
+	if (ZEND_TYPE_HAS_LIST(type)) {
+		/* Copy type list (unions/intersections) */
+		zend_type_list *old_list = ZEND_TYPE_LIST(type);
+		size_t list_size = ZEND_TYPE_LIST_SIZE(old_list->num_types);
+		zend_type_list *new_list = pemalloc(list_size, 1);
+		memcpy(new_list, old_list, list_size);
+
+		/* Update references in copied list elements */
+		for (uint32_t i = 0; i < old_list->num_types; i++) {
+			new_list->types[i] = zend_shape_type_deep_copy(old_list->types[i]);
+		}
+
+		ZEND_TYPE_SET_PTR(result, new_list);
+	} else if (ZEND_TYPE_HAS_NAME(type)) {
+		/* Copy and reference the string */
+		zend_string *name = ZEND_TYPE_NAME(type);
+		ZEND_TYPE_SET_PTR(result, zend_string_dup(name, 1));
+	} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+		/* Deep copy nested array shape */
+		zend_array_shape *old_shape = ZEND_ARRAY_SHAPE(type);
+		size_t shape_size = sizeof(zend_array_shape) + old_shape->num_elements * sizeof(zend_array_shape_element);
+		zend_array_shape *new_shape = pemalloc(shape_size, 1);
+		memcpy(new_shape, old_shape, sizeof(zend_array_shape));
+
+		for (uint32_t i = 0; i < old_shape->num_elements; i++) {
+			new_shape->elements[i].key = zend_string_dup(old_shape->elements[i].key, 1);
+			new_shape->elements[i].type = zend_shape_type_deep_copy(old_shape->elements[i].type);
+			new_shape->elements[i].is_optional = old_shape->elements[i].is_optional;
+		}
+
+		ZEND_TYPE_SET_PTR(result, new_shape);
+	}
+	/* Simple types (int, string, etc.) have no pointers, so shallow copy is fine */
+
+	return result;
+}
+/* }}} */
+
+/* Check if child type is a valid override for parent type (covariance for shape elements).
+ * Returns true if valid, false if the override would violate type safety.
+ * For simple types: child must be a subset of parent (can narrow, cannot widen).
+ * For complex types: we allow the override (could be enhanced with full type checking). */
+static bool zend_shape_type_is_covariant(zend_type child_type, zend_type parent_type) /* {{{ */
+{
+	/* If parent is not set, any child type is valid */
+	if (!ZEND_TYPE_IS_SET(parent_type)) {
+		return true;
+	}
+
+	/* If child is not set but parent is, that's invalid */
+	if (!ZEND_TYPE_IS_SET(child_type)) {
+		return false;
+	}
+
+	/* For simple type masks: child type mask must be a subset of parent */
+	uint32_t child_mask = ZEND_TYPE_PURE_MASK(child_type);
+	uint32_t parent_mask = ZEND_TYPE_PURE_MASK(parent_type);
+
+	/* Child cannot add types that parent doesn't have */
+	uint32_t added_types = child_mask & ~parent_mask;
+	if (added_types != 0) {
+		/* Exception: if parent allows 'mixed', child can be anything */
+		if (parent_mask == MAY_BE_ANY) {
+			return true;
+		}
+		return false;
+	}
+
+	/* For complex types (classes, shapes), we'd need more sophisticated checking.
+	 * For now, allow if the type masks are compatible. */
+	return true;
+}
+/* }}} */
+
+/* Helper function to merge parent shape elements into child shape */
+static zend_type zend_merge_shape_types(zend_type parent_type, zend_type child_type, zend_string *shape_name) /* {{{ */
+{
+	/* Both must be array shapes */
+	if (!ZEND_TYPE_HAS_ARRAY_SHAPE(parent_type) || !ZEND_TYPE_HAS_ARRAY_SHAPE(child_type)) {
+		return child_type;  /* If either is not a shape, just return child */
+	}
+
+	zend_array_shape *parent_shape = ZEND_ARRAY_SHAPE(parent_type);
+	zend_array_shape *child_shape = ZEND_ARRAY_SHAPE(child_type);
+
+	/* First pass: validate overrides before allocating merged shape */
+	for (uint32_t i = 0; i < child_shape->num_elements; i++) {
+		for (uint32_t j = 0; j < parent_shape->num_elements; j++) {
+			if (zend_string_equals(child_shape->elements[i].key, parent_shape->elements[j].key)) {
+				/* Child is overriding parent element - validate */
+
+				/* Rule 1: Cannot make required property optional */
+				if (!parent_shape->elements[j].is_optional && child_shape->elements[i].is_optional) {
+					zend_error_noreturn(E_COMPILE_ERROR,
+						"Shape %s cannot make required property '%s' optional (inherited as required from parent)",
+						ZSTR_VAL(shape_name), ZSTR_VAL(child_shape->elements[i].key));
+				}
+
+				/* Rule 2: Child type must be covariant (subset of parent type) */
+				if (!zend_shape_type_is_covariant(child_shape->elements[i].type, parent_shape->elements[j].type)) {
+					zend_string *parent_type_str = zend_type_to_string(parent_shape->elements[j].type);
+					zend_string *child_type_str = zend_type_to_string(child_shape->elements[i].type);
+					zend_error_noreturn(E_COMPILE_ERROR,
+						"Shape %s property '%s' type %s is not compatible with parent type %s",
+						ZSTR_VAL(shape_name), ZSTR_VAL(child_shape->elements[i].key),
+						ZSTR_VAL(child_type_str), ZSTR_VAL(parent_type_str));
+				}
+
+				break;
+			}
+		}
+	}
+
+	/* Calculate total elements (parent + child, with child overriding parent) */
+	uint32_t total_elements = parent_shape->num_elements;
+	uint32_t child_new_elements = 0;
+
+	/* Count new elements in child that don't override parent */
+	for (uint32_t i = 0; i < child_shape->num_elements; i++) {
+		bool found = false;
+		for (uint32_t j = 0; j < parent_shape->num_elements; j++) {
+			if (zend_string_equals(child_shape->elements[i].key, parent_shape->elements[j].key)) {
+				found = true;
+				break;
+			}
+		}
+		if (!found) {
+			child_new_elements++;
+		}
+	}
+	total_elements += child_new_elements;
+
+	/* Allocate merged shape */
+	size_t shape_size = sizeof(zend_array_shape) + total_elements * sizeof(zend_array_shape_element);
+	zend_array_shape *merged_shape = pemalloc(shape_size, 1);
+	merged_shape->num_elements = total_elements;
+	merged_shape->is_closed = child_shape->is_closed;
+
+	uint32_t merged_idx = 0;
+	uint32_t num_required = 0;
+
+	/* First, copy parent elements (can be overridden by child) */
+	for (uint32_t i = 0; i < parent_shape->num_elements; i++) {
+		/* Check if child overrides this element */
+		bool overridden = false;
+		for (uint32_t j = 0; j < child_shape->num_elements; j++) {
+			if (zend_string_equals(parent_shape->elements[i].key, child_shape->elements[j].key)) {
+				/* Child overrides - persist child's version */
+				merged_shape->elements[merged_idx].key = zend_persist_shape_key(child_shape->elements[j].key);
+				merged_shape->elements[merged_idx].type = zend_shape_type_deep_copy(child_shape->elements[j].type);
+				merged_shape->elements[merged_idx].is_optional = child_shape->elements[j].is_optional;
+				if (!child_shape->elements[j].is_optional) {
+					num_required++;
+				}
+				overridden = true;
+				break;
+			}
+		}
+		if (!overridden) {
+			/* Persist parent's version */
+			merged_shape->elements[merged_idx].key = zend_persist_shape_key(parent_shape->elements[i].key);
+			merged_shape->elements[merged_idx].type = zend_shape_type_deep_copy(parent_shape->elements[i].type);
+			merged_shape->elements[merged_idx].is_optional = parent_shape->elements[i].is_optional;
+			if (!parent_shape->elements[i].is_optional) {
+				num_required++;
+			}
+		}
+		merged_idx++;
+	}
+
+	/* Then add child elements that weren't overriding parent */
+	for (uint32_t i = 0; i < child_shape->num_elements; i++) {
+		bool found = false;
+		for (uint32_t j = 0; j < parent_shape->num_elements; j++) {
+			if (zend_string_equals(child_shape->elements[i].key, parent_shape->elements[j].key)) {
+				found = true;
+				break;
+			}
+		}
+		if (!found) {
+			merged_shape->elements[merged_idx].key = zend_persist_shape_key(child_shape->elements[i].key);
+			merged_shape->elements[merged_idx].type = zend_shape_type_deep_copy(child_shape->elements[i].type);
+			merged_shape->elements[merged_idx].is_optional = child_shape->elements[i].is_optional;
+			if (!child_shape->elements[i].is_optional) {
+				num_required++;
+			}
+			merged_idx++;
+		}
+	}
+
+	merged_shape->num_required = num_required;
+
+	/* Build cached hash table of expected keys for closed shapes */
+	if (merged_shape->is_closed && merged_shape->num_elements > 0) {
+		merged_shape->expected_keys = pemalloc(sizeof(HashTable), 1);
+		zend_hash_init(merged_shape->expected_keys, merged_shape->num_elements, NULL, NULL, 1);
+		for (uint32_t i = 0; i < merged_shape->num_elements; i++) {
+			zend_hash_add_empty_element(merged_shape->expected_keys, merged_shape->elements[i].key);
+		}
+	} else {
+		merged_shape->expected_keys = NULL;
+	}
+
+	/* Create merged type */
+	zend_type merged_type = (zend_type) ZEND_TYPE_INIT_PTR_MASK(merged_shape, _ZEND_TYPE_ARRAY_SHAPE_BIT | MAY_BE_ARRAY);
+	return merged_type;
+}
+/* }}} */
+
+static void zend_compile_shape_decl(zend_ast *ast) /* {{{ */
+{
+	zend_ast *name_ast = ast->child[0];
+	zend_ast *parent_ast = ast->child[1];
+	zend_ast *type_ast = ast->child[2];
+	zend_string *name = zend_ast_get_str(name_ast);
+	zend_string *lcname;
+
+	/* Prefix with namespace if applicable */
+	name = zend_prefix_with_ns(name);
+	lcname = zend_string_tolower(name);
+
+	/* Check for duplicate shape definition in global table */
+	if (zend_hash_exists(CG(shape_table), lcname)) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"Cannot redeclare shape %s", ZSTR_VAL(name));
+	}
+
+	/* Handle inheritance */
+	zend_type final_type;
+	if (parent_ast) {
+		/* Resolve parent shape name */
+		zend_string *parent_name = zend_resolve_class_name_ast(parent_ast);
+		zend_string *parent_lcname = zend_string_tolower(parent_name);
+
+		/* Check that parent is not a class */
+		zend_class_entry *ce = zend_hash_find_ptr(CG(class_table), parent_lcname);
+		if (ce) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Shape %s cannot extend class %s", ZSTR_VAL(name), ZSTR_VAL(parent_name));
+		}
+
+		/* Look up parent shape - first in file-local, then global */
+		zend_shape_entry *parent_shape = NULL;
+		if (FC(shapes)) {
+			parent_shape = zend_hash_find_ptr(FC(shapes), parent_lcname);
+		}
+		if (!parent_shape && CG(shape_table)) {
+			parent_shape = zend_hash_find_ptr(CG(shape_table), parent_lcname);
+		}
+
+		if (!parent_shape) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Shape %s extends undefined shape %s", ZSTR_VAL(name), ZSTR_VAL(parent_name));
+		}
+
+		/* Check for circular inheritance */
+		if (zend_string_equals_ci(parent_lcname, lcname)) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Shape %s cannot extend itself", ZSTR_VAL(name));
+		}
+
+		zend_string_release(parent_name);
+		zend_string_release(parent_lcname);
+
+		/* Compile child type and merge with parent */
+		zend_type child_type = zend_compile_typename(type_ast);
+		zend_type child_persistent = zend_persist_shape_type(child_type);
+		final_type = zend_merge_shape_types(parent_shape->type, child_persistent, name);
+	} else {
+		/* No inheritance - compile type directly */
+		zend_type arena_type = zend_compile_typename(type_ast);
+		final_type = zend_persist_shape_type(arena_type);
+	}
+
+	/* Create and store the shape entry in global table */
+	zend_shape_entry *entry = pemalloc(sizeof(zend_shape_entry), 1);
+	/* Use dup with persistent=1 since name may be arena-allocated */
+	entry->name = zend_string_dup(name, 1);
+	entry->type = final_type;
+
+	zend_hash_add_ptr(CG(shape_table), lcname, entry);
+
+	/* Also add to file-local shapes for compile-time resolution */
+	if (!FC(shapes)) {
+		ALLOC_HASHTABLE(FC(shapes));
+		zend_hash_init(FC(shapes), ZEND_SHAPE_DEFAULT_HASHTABLE_SIZE, NULL, NULL, 0);  /* No dtor - just references */
+	}
+	zend_hash_add_ptr(FC(shapes), lcname, entry);
+
+	zend_string_release(lcname);
+	zend_string_release(name);
+}
+/* }}} */
+
 static void zend_compile_namespace(zend_ast *ast) /* {{{ */
 {
 	zend_ast *name_ast = ast->child[0];
@@ -11126,6 +11826,47 @@ static void zend_compile_class_name(znode *result, zend_ast *ast) /* {{{ */
 }
 /* }}} */
 
+static void zend_compile_shape_name(znode *result, zend_ast *ast) /* {{{ */
+{
+	zend_ast *shape_ast = ast->child[0];
+
+	if (shape_ast->kind != ZEND_AST_ZVAL) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"::shape requires a constant shape name, dynamic names are not allowed");
+	}
+
+	/* Resolve the shape name */
+	zend_string *shape_name = zend_resolve_class_name_ast(shape_ast);
+	zend_string *lcname = zend_string_tolower(shape_name);
+
+	/* Look up the shape */
+	zend_shape_entry *shape = NULL;
+	if (FC(shapes)) {
+		shape = zend_hash_find_ptr(FC(shapes), lcname);
+	}
+	if (!shape && CG(shape_table)) {
+		shape = zend_hash_find_ptr(CG(shape_table), lcname);
+	}
+
+	/* If not a shape, check if it's a class - if so, error */
+	if (!shape) {
+		zend_class_entry *ce = zend_hash_find_ptr(CG(class_table), lcname);
+		if (ce) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Cannot use ::shape on class %s, use ::class instead", ZSTR_VAL(shape_name));
+		}
+		/* Not found - might be autoloaded at runtime */
+		/* For now, return the resolved name */
+	}
+
+	/* Return the shape name as a string constant */
+	result->op_type = IS_CONST;
+	ZVAL_STR(&result->u.constant, shape_name);
+
+	zend_string_release(lcname);
+}
+/* }}} */
+
 static zend_op *zend_compile_rope_add_ex(zend_op *opline, znode *result, uint32_t num, znode *elem_node) /* {{{ */
 {
 	if (num == 0) {
@@ -11324,7 +12065,7 @@ static bool zend_is_allowed_in_const_expr(zend_ast_kind kind) /* {{{ */
 		|| kind == ZEND_AST_ARRAY || kind == ZEND_AST_ARRAY_ELEM
 		|| kind == ZEND_AST_UNPACK
 		|| kind == ZEND_AST_CONST || kind == ZEND_AST_CLASS_CONST
-		|| kind == ZEND_AST_CLASS_NAME
+		|| kind == ZEND_AST_CLASS_NAME || kind == ZEND_AST_SHAPE_NAME
 		|| kind == ZEND_AST_MAGIC_CONST || kind == ZEND_AST_COALESCE
 		|| kind == ZEND_AST_CONST_ENUM_INIT
 		|| kind == ZEND_AST_NEW || kind == ZEND_AST_ARG_LIST
@@ -11401,6 +12142,34 @@ static void zend_compile_const_expr_class_name(zend_ast **ast_ptr) /* {{{ */
 	}
 }
 
+static void zend_compile_const_expr_shape_name(zend_ast **ast_ptr) /* {{{ */
+{
+	zend_ast *ast = *ast_ptr;
+	zend_ast *shape_ast = ast->child[0];
+	if (shape_ast->kind != ZEND_AST_ZVAL) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"(expression)::shape cannot be used in constant expressions");
+	}
+
+	/* Resolve the shape name and verify it's not a special class keyword */
+	zend_string *shape_name = zend_ast_get_str(shape_ast);
+	uint32_t fetch_type = zend_get_class_fetch_type(shape_name);
+
+	if (fetch_type != ZEND_FETCH_CLASS_DEFAULT) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"Cannot use %s::shape - shapes do not have self, parent, or static",
+			ZSTR_VAL(shape_name));
+	}
+
+	/* Resolve to fully qualified name */
+	zend_string *resolved_name = zend_resolve_class_name_ast(shape_ast);
+	zend_string_release(shape_name);
+	zval *zv = zend_ast_get_zval(shape_ast);
+	ZVAL_STR(zv, resolved_name);
+	shape_ast->attr = ZEND_NAME_FQ;
+}
+/* }}} */
+
 static void zend_compile_const_expr_const(zend_ast **ast_ptr) /* {{{ */
 {
 	zend_ast *ast = *ast_ptr;
@@ -11593,6 +12362,9 @@ static void zend_compile_const_expr(zend_ast **ast_ptr, void *context) /* {{{ */
 		case ZEND_AST_CLASS_NAME:
 			zend_compile_const_expr_class_name(ast_ptr);
 			break;
+		case ZEND_AST_SHAPE_NAME:
+			zend_compile_const_expr_shape_name(ast_ptr);
+			break;
 		case ZEND_AST_CONST:
 			zend_compile_const_expr_const(ast_ptr);
 			break;
@@ -11773,6 +12545,9 @@ static void zend_compile_stmt(zend_ast *ast) /* {{{ */
 		case ZEND_AST_CONST_DECL:
 			zend_compile_const_decl(ast);
 			break;
+		case ZEND_AST_SHAPE_DECL:
+			zend_compile_shape_decl(ast);
+			break;
 		case ZEND_AST_NAMESPACE:
 			zend_compile_namespace(ast);
 			break;
@@ -11916,6 +12691,9 @@ static void zend_compile_expr_inner(znode *result, zend_ast *ast) /* {{{ */
 		case ZEND_AST_CLASS_NAME:
 			zend_compile_class_name(result, ast);
 			return;
+		case ZEND_AST_SHAPE_NAME:
+			zend_compile_shape_name(result, ast);
+			return;
 		case ZEND_AST_ENCAPS_LIST:
 			zend_compile_encaps_list(result, ast);
 			return;
@@ -12332,6 +13110,17 @@ static void zend_eval_const_expr(zend_ast **ast_ptr) /* {{{ */
 			}
 			break;
 		}
+		case ZEND_AST_SHAPE_NAME:
+		{
+			/* Shape names are always constant - just resolve the name */
+			zend_ast *shape_ast = ast->child[0];
+			if (shape_ast->kind != ZEND_AST_ZVAL) {
+				return;  /* Dynamic, cannot evaluate at compile time */
+			}
+			zend_string *resolved_name = zend_resolve_class_name_ast(shape_ast);
+			ZVAL_STR(&result, resolved_name);
+			break;
+		}
 		// TODO: We should probably use zend_ast_apply to recursively walk nodes without
 		// special handling. It is required that all nodes that are part of a const expr
 		// are visited. Probably we should be distinguishing evaluation of const expr and
diff --git a/Zend/zend_compile.h b/Zend/zend_compile.h
index c07fa9bf..742c9ead 100644
--- a/Zend/zend_compile.h
+++ b/Zend/zend_compile.h
@@ -107,7 +107,99 @@ typedef struct _zend_declarables {
 	zend_long ticks;
 } zend_declarables;
 
+/* Array element type info for array<T> and array<K, V> syntax */
+typedef struct _zend_typed_array_element {
+	zend_type element_type;  /* Value type info - supports unions, intersections, classes */
+	zend_type key_type;      /* Key type (int, string, or int|string) - if unset, any key allowed */
+} zend_typed_array_element;
+
+/* Check if key type is specified */
+#define ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem) \
+	(ZEND_TYPE_IS_SET((elem)->key_type))
+
+#define ZEND_TYPED_ARRAY_ELEMENT(t) \
+	((zend_typed_array_element *) (t).ptr)
+
+/* Helper to get simple type code (for caching optimization) */
+#define ZEND_TYPED_ARRAY_SIMPLE_TYPE(elem) \
+	(ZEND_TYPE_IS_ONLY_MASK((elem)->element_type) ? \
+		(uint8_t)ZEND_TYPE_PURE_MASK((elem)->element_type) : 0)
+
+/* Maximum nesting depth for typed array validation (prevents stack overflow) */
+#define ZEND_TYPED_ARRAY_MAX_DEPTH 128
+
+/* Array shape element for array{key: type, key?: type} syntax */
+typedef struct _zend_array_shape_element {
+	zend_string *key;        /* Key name */
+	zend_type type;          /* Value type */
+	bool is_optional;        /* Whether this key is optional (key?: type) */
+} zend_array_shape_element;
+
+/* Array shape info for array{...} syntax */
+typedef struct _zend_array_shape {
+	uint32_t num_elements;               /* Number of shape elements */
+	uint32_t num_required;               /* Number of required (non-optional) elements */
+	bool is_closed;                      /* If true, no extra keys allowed (array{...}!) */
+	HashTable *expected_keys;            /* Cached hash set of keys for closed shapes (NULL for open shapes) */
+	zend_array_shape_element elements[]; /* Flexible array member */
+} zend_array_shape;
+
+/* Check if type has array shape */
+#define ZEND_TYPE_HAS_ARRAY_SHAPE(t) \
+	(((t).type_mask & _ZEND_TYPE_ARRAY_SHAPE_BIT) != 0)
+
+/* Get array shape from type */
+#define ZEND_ARRAY_SHAPE(t) \
+	((zend_array_shape *) (t).ptr)
+
 /* Compilation context that is different for each file, but shared between op arrays. */
+/* Shape type alias entry */
+typedef struct _zend_shape_entry {
+	zend_string *name;
+	zend_type type;
+} zend_shape_entry;
+
+/* ============================================================================
+ * Typed Array & Array Shape Constants
+ * ============================================================================ */
+
+/* Maximum recursion depth for shape/typed array validation.
+ * Prevents infinite loops in case of circular shape references
+ * (e.g., shape A references shape B which references shape A).
+ * Similar to other PHP recursion limits like MAX_INCLUDE_DEPTH. */
+#define ZEND_SHAPE_MAX_RECURSION_DEPTH 64
+
+/* Maximum number of elements in a single array shape definition.
+ * Prevents excessive memory allocation from malformed AST.
+ * 255 is sufficient for any practical shape definition. */
+#define ZEND_SHAPE_MAX_ELEMENTS 255
+
+/* Default initial size for shape-related hash tables.
+ * Chosen as a power of 2 for efficient hashing, and 8 provides
+ * good balance between memory usage and resize frequency. */
+#define ZEND_SHAPE_DEFAULT_HASHTABLE_SIZE 8
+
+/* AST attribute flag indicating an optional shape element (key?: type).
+ * Used in zend_ast->attr during shape compilation. */
+#define ZEND_SHAPE_ELEM_OPTIONAL_FLAG 1
+
+/* Error result codes for shape validation */
+typedef enum {
+	SHAPE_OK = 0,           /* Validation passed */
+	SHAPE_MISSING_KEY = 1,  /* Required key is missing from array */
+	SHAPE_WRONG_TYPE = 2,   /* Key exists but value has wrong type */
+	SHAPE_EXTRA_KEY = 3     /* Extra key found in closed shape */
+} zend_shape_check_result;
+
+/* Error message format for shape type errors.
+ * Used consistently across return, argument, and property error messages. */
+#define ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY \
+	"array{%s: %s, ...}, array given with missing key \"%s\""
+#define ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE \
+	"array{%s: %s, ...}, array key \"%s\" is %s"
+#define ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY \
+	"closed shape, unexpected extra key \"%s\""
+
 typedef struct _zend_file_context {
 	zend_declarables declarables;
 
@@ -118,6 +210,7 @@ typedef struct _zend_file_context {
 	HashTable *imports;
 	HashTable *imports_function;
 	HashTable *imports_const;
+	HashTable *shapes;  /* shape type aliases (name -> zend_shape_entry) */
 
 	HashTable seen_symbols;
 } zend_file_context;
@@ -407,6 +500,9 @@ typedef struct _zend_oparray_context {
 /*                                                        |     |     |     */
 /* op_array uses strict mode types                        |     |     |     */
 #define ZEND_ACC_STRICT_TYPES            (1U << 31) /*    |  X  |     |     */
+/*                                                        |     |     |     */
+/* op_array uses strict array element types               |     |     |     */
+#define ZEND_ACC_STRICT_ARRAYS           (1U << 30) /*    |  X  |     |     */
 
 #define ZEND_ACC_PPP_MASK  (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)
 #define ZEND_ACC_PPP_SET_MASK  (ZEND_ACC_PUBLIC_SET | ZEND_ACC_PROTECTED_SET | ZEND_ACC_PRIVATE_SET)
@@ -719,6 +815,13 @@ ZEND_STATIC_ASSERT(ZEND_MM_ALIGNED_SIZE(sizeof(zval)) == sizeof(zval),
 #define EX_USES_STRICT_TYPES() \
 	ZEND_CALL_USES_STRICT_TYPES(execute_data)
 
+/* Typed array checking is always enabled - no declare directive needed */
+#define ZEND_CALL_USES_STRICT_ARRAYS(call) (1)
+
+#define EX_USES_STRICT_ARRAYS() (1)
+
+#define ZEND_RET_USES_STRICT_ARRAYS() (1)
+
 #define ZEND_ARG_USES_STRICT_TYPES() \
 	(EG(current_execute_data)->prev_execute_data && \
 	 EG(current_execute_data)->prev_execute_data->func && \
diff --git a/Zend/zend_execute.c b/Zend/zend_execute.c
index 5665cc0c..d1f7a705 100644
--- a/Zend/zend_execute.c
+++ b/Zend/zend_execute.c
@@ -1068,6 +1068,9 @@ ZEND_API bool zend_never_inline zend_verify_property_type(const zend_property_in
 	return i_zend_verify_property_type(info, property, strict);
 }
 
+/* Forward declaration - defined later after zend_check_array_shape */
+ZEND_API bool zend_verify_array_prop_shape(const zend_property_info *info, zval *arr, const zend_array_shape *shape);
+
 static zend_never_inline zval* zend_assign_to_typed_prop(const zend_property_info *info, zval *property_val, zval *value, zend_refcounted **garbage_ptr EXECUTE_DATA_DC)
 {
 	zval tmp;
@@ -1091,6 +1094,23 @@ static zend_never_inline zval* zend_assign_to_typed_prop(const zend_property_inf
 		return &EG(uninitialized_zval);
 	}
 
+	/* Check array element types for typed arrays/shapes */
+	if (Z_TYPE(tmp) == IS_ARRAY) {
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(info->type)) {
+			zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(info->type);
+			if (UNEXPECTED(!zend_verify_array_prop_element_types(info, &tmp, elem_type))) {
+				zval_ptr_dtor(&tmp);
+				return &EG(uninitialized_zval);
+			}
+		} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(info->type)) {
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(info->type);
+			if (UNEXPECTED(!zend_verify_array_prop_shape(info, &tmp, shape))) {
+				zval_ptr_dtor(&tmp);
+				return &EG(uninitialized_zval);
+			}
+		}
+	}
+
 	Z_PROP_FLAG_P(property_val) &= ~IS_PROP_REINITABLE;
 
 	return zend_assign_to_variable_ex(property_val, &tmp, IS_TMP_VAR, EX_USES_STRICT_TYPES(), garbage_ptr);
@@ -1108,6 +1128,9 @@ static zend_always_inline bool zend_value_instanceof_static(const zval *zv) {
 	return instanceof_function(Z_OBJCE_P(zv), called_scope);
 }
 
+/* Forward declaration - defined after zend_check_array_shape */
+static bool zend_check_shape_type(const zend_type *type, zval *arg, bool is_return_type);
+
 static zend_always_inline zend_class_entry *zend_fetch_ce_from_type(
 		const zend_type *type)
 {
@@ -1153,6 +1176,15 @@ static zend_always_inline bool zend_check_type_slow(
 		const zend_type *type, zval *arg, const zend_reference *ref,
 		bool is_return_type, bool is_internal)
 {
+	/* Check for shape types first (shapes accept arrays, not objects) */
+	if (ZEND_TYPE_IS_COMPLEX(*type) && Z_TYPE_P(arg) == IS_ARRAY) {
+		if (!ZEND_TYPE_HAS_LIST(*type) && ZEND_TYPE_HAS_NAME(*type)) {
+			if (zend_check_shape_type(type, arg, is_return_type)) {
+				return true;
+			}
+		}
+	}
+
 	if (ZEND_TYPE_IS_COMPLEX(*type) && EXPECTED(Z_TYPE_P(arg) == IS_OBJECT)) {
 		zend_class_entry *ce;
 		if (UNEXPECTED(ZEND_TYPE_HAS_LIST(*type))) {
@@ -1434,6 +1466,1255 @@ ZEND_API ZEND_COLD void zend_verify_return_error(const zend_function *zf, const
 	zend_string_release(need_msg);
 }
 
+/* Array element type validation for array<T> with strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_element_type_error(
+	const zend_function *zf, zend_long index, const zval *element,
+	const char *expected_type, const char *actual_type)
+{
+	const char *fname = ZSTR_VAL(zf->common.function_name);
+	const char *fsep = zf->common.scope ? "::" : "";
+	const char *fclass = zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "";
+
+	zend_type_error("%s%s%s(): Return value must be of type array<%s>, "
+		"array element at index " ZEND_LONG_FMT " is %s",
+		fclass, fsep, fname, expected_type, index, actual_type);
+}
+
+/* Array element type validation for argument with array<T> and strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_arg_element_type_error(
+	const zend_function *zf, uint32_t arg_num, zend_long index, const zval *element,
+	const char *expected_type, const char *actual_type)
+{
+	zend_argument_type_error(arg_num,
+		"must be of type array<%s>, array element at index " ZEND_LONG_FMT " is %s",
+		expected_type, index, actual_type);
+}
+
+/* Array element type validation for property with array<T> and strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_prop_element_type_error(
+	const zend_property_info *info, zend_long index, const zval *element,
+	const char *expected_type, const char *actual_type)
+{
+	zend_type_error("Cannot assign to property %s::$%s of type array<%s>, "
+		"array element at index " ZEND_LONG_FMT " is %s",
+		ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name), expected_type,
+		index, actual_type);
+}
+
+/* Array key type validation errors for array<K, V> with strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_key_type_error(
+	const zend_function *zf, const char *expected_key_type, const char *actual_key_type)
+{
+	const char *fname = ZSTR_VAL(zf->common.function_name);
+	const char *fsep = zf->common.scope ? "::" : "";
+	const char *fclass = zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "";
+
+	zend_type_error("%s%s%s(): Return value must be of type array<%s, ...>, "
+		"array contains %s key",
+		fclass, fsep, fname, expected_key_type, actual_key_type);
+}
+
+ZEND_API ZEND_COLD void zend_verify_array_arg_key_type_error(
+	uint32_t arg_num, const char *expected_key_type, const char *actual_key_type)
+{
+	zend_argument_type_error(arg_num,
+		"must be of type array<%s, ...>, array contains %s key",
+		expected_key_type, actual_key_type);
+}
+
+ZEND_API ZEND_COLD void zend_verify_array_prop_key_type_error(
+	const zend_property_info *info, const char *expected_key_type, const char *actual_key_type)
+{
+	zend_type_error("Cannot assign to property %s::$%s of type array<%s, ...>, "
+		"array contains %s key",
+		ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name), expected_key_type, actual_key_type);
+}
+
+/* Key type validation helper - returns true if all keys match expected type */
+static zend_always_inline bool zend_verify_array_key_types(
+	HashTable *ht, uint32_t expected_key_mask)
+{
+	zend_string *str_key;
+	zend_ulong num_key;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* int|string accepts any key */
+	if (expected_key_mask == (MAY_BE_LONG | MAY_BE_STRING)) {
+		return true;
+	}
+
+	/* Fast path: check key type cache */
+	if (HT_KEY_TYPE_IS_VALID(ht) && HT_VALIDATED_KEY_TYPE(ht) == (uint8_t)expected_key_mask) {
+		return true;
+	}
+
+	/* Fast path: packed arrays only have integer keys */
+	if (expected_key_mask == MAY_BE_LONG && HT_IS_PACKED(ht)) {
+		HT_SET_VALIDATED_KEY_TYPE(ht, MAY_BE_LONG);
+		return true;
+	}
+
+	bool expects_int = (expected_key_mask == MAY_BE_LONG);
+
+	ZEND_HASH_FOREACH_KEY(ht, num_key, str_key) {
+		(void)num_key;
+		if (expects_int) {
+			if (str_key != NULL) {
+				return false;
+			}
+		} else if (str_key == NULL) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+
+	/* Cache the validated key type */
+	HT_SET_VALIDATED_KEY_TYPE(ht, expected_key_mask);
+	return true;
+}
+
+/* Find invalid key type for error reporting */
+static zend_always_inline const char *zend_find_invalid_key_type(
+	HashTable *ht, uint32_t expected_key_mask)
+{
+	zend_string *str_key;
+	zend_ulong num_key;
+
+	bool expects_int = (expected_key_mask == MAY_BE_LONG);
+
+	ZEND_HASH_FOREACH_KEY(ht, num_key, str_key) {
+		(void)num_key;
+		if (expects_int && str_key != NULL) {
+			return "string";
+		}
+		if (!expects_int && str_key == NULL) {
+			return "int";
+		}
+	} ZEND_HASH_FOREACH_END();
+
+	return "unknown";
+}
+
+/*
+ * SIMD-optimized packed array validators for large arrays.
+ *
+ * These use AVX2/SSE2 to check multiple zval type fields in parallel.
+ * The zval struct is 16 bytes with type at offset 8 (u1.type_info).
+ * We use gather operations to collect type bytes, then compare in parallel.
+ *
+ * Minimum array size for SIMD: 16 elements (to amortize setup cost)
+ */
+#ifdef __AVX2__
+#include <immintrin.h>
+
+/* AVX2: Check 8 zvals in parallel using gather */
+static zend_always_inline bool zend_verify_packed_elements_long_avx2(zval *data, uint32_t count)
+{
+	const __m256i expected_type = _mm256_set1_epi32(IS_LONG);
+	/* Gather indices: offset 8 bytes (type_info) for each of 8 consecutive zvals (16 bytes apart) */
+	const __m256i gather_indices = _mm256_setr_epi32(0, 4, 8, 12, 16, 20, 24, 28);
+
+	/* Process 8 elements at a time */
+	while (count >= 8) {
+		/* Gather type_info from 8 consecutive zvals
+		 * Base pointer is at the type_info field of first zval */
+		uint32_t *type_ptr = &data->u1.type_info;
+		__m256i types = _mm256_i32gather_epi32((const int*)type_ptr, gather_indices, 4);
+
+		/* Mask to extract just the type byte (lower 8 bits) */
+		__m256i type_bytes = _mm256_and_si256(types, _mm256_set1_epi32(0xFF));
+
+		/* Compare with IS_LONG */
+		__m256i cmp = _mm256_cmpeq_epi32(type_bytes, expected_type);
+
+		/* Check if all 8 matched */
+		if (_mm256_movemask_epi8(cmp) != (int)0xFFFFFFFF) {
+			/* At least one didn't match - fall back to scalar for error handling */
+			goto scalar_check;
+		}
+
+		data += 8;
+		count -= 8;
+	}
+
+scalar_check:
+	/* Scalar fallback for remaining elements */
+	while (count > 0) {
+		if (Z_TYPE_P(data) == IS_REFERENCE) {
+			data = Z_REFVAL_P(data);
+		}
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_LONG)) {
+			return false;
+		}
+		data++;
+		count--;
+	}
+	return true;
+}
+
+static zend_always_inline bool zend_verify_packed_elements_string_avx2(zval *data, uint32_t count)
+{
+	const __m256i expected_type = _mm256_set1_epi32(IS_STRING);
+	const __m256i gather_indices = _mm256_setr_epi32(0, 4, 8, 12, 16, 20, 24, 28);
+
+	while (count >= 8) {
+		uint32_t *type_ptr = &data->u1.type_info;
+		__m256i types = _mm256_i32gather_epi32((const int*)type_ptr, gather_indices, 4);
+		__m256i type_bytes = _mm256_and_si256(types, _mm256_set1_epi32(0xFF));
+		__m256i cmp = _mm256_cmpeq_epi32(type_bytes, expected_type);
+
+		if (_mm256_movemask_epi8(cmp) != (int)0xFFFFFFFF) {
+			goto scalar_check;
+		}
+
+		data += 8;
+		count -= 8;
+	}
+
+scalar_check:
+	while (count > 0) {
+		if (Z_TYPE_P(data) == IS_REFERENCE) {
+			data = Z_REFVAL_P(data);
+		}
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_STRING)) {
+			return false;
+		}
+		data++;
+		count--;
+	}
+	return true;
+}
+
+#define ZEND_HAS_SIMD_ARRAY_VALIDATION 1
+#define ZEND_SIMD_MIN_ELEMENTS 16
+#endif /* __AVX2__ */
+
+/* Packed array validator with 4x unrolling and prefetching */
+#define DEFINE_VERIFY_PACKED_ELEMENTS(name, type_check) \
+static zend_always_inline bool name(zval *data, uint32_t count) \
+{ \
+	zval *end = data + count; \
+	while (data + 4 <= end) { \
+		if (data + 8 < end) __builtin_prefetch(data + 8, 0, 1); \
+		if (UNEXPECTED(!(type_check(data)))) { \
+			if (Z_TYPE_P(data) == IS_REFERENCE) goto slow_path; \
+			return false; \
+		} \
+		if (UNEXPECTED(!(type_check(data + 1)))) { \
+			if (Z_TYPE_P(data + 1) == IS_REFERENCE) goto slow_path; \
+			return false; \
+		} \
+		if (UNEXPECTED(!(type_check(data + 2)))) { \
+			if (Z_TYPE_P(data + 2) == IS_REFERENCE) goto slow_path; \
+			return false; \
+		} \
+		if (UNEXPECTED(!(type_check(data + 3)))) { \
+			if (Z_TYPE_P(data + 3) == IS_REFERENCE) goto slow_path; \
+			return false; \
+		} \
+		data += 4; \
+	} \
+	while (data < end) { \
+		if (UNEXPECTED(!(type_check(data)))) { \
+			if (Z_TYPE_P(data) == IS_REFERENCE) goto slow_path; \
+			return false; \
+		} \
+		data++; \
+	} \
+	return true; \
+slow_path: \
+	while (data < end) { \
+		zval *val = (Z_TYPE_P(data) == IS_REFERENCE) ? Z_REFVAL_P(data) : data; \
+		if (UNEXPECTED(!(type_check(val)))) return false; \
+		data++; \
+	} \
+	return true; \
+}
+
+#define IS_LONG_CHECK(v) (Z_TYPE_P(v) == IS_LONG)
+#define IS_STRING_CHECK(v) (Z_TYPE_P(v) == IS_STRING)
+
+DEFINE_VERIFY_PACKED_ELEMENTS(zend_verify_packed_array_elements_long, IS_LONG_CHECK)
+DEFINE_VERIFY_PACKED_ELEMENTS(zend_verify_packed_array_elements_string, IS_STRING_CHECK)
+
+#undef IS_LONG_CHECK
+#undef IS_STRING_CHECK
+#undef DEFINE_VERIFY_PACKED_ELEMENTS
+
+static zend_always_inline bool zend_verify_array_elements_long(HashTable *ht)
+{
+	if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+#ifdef ZEND_HAS_SIMD_ARRAY_VALIDATION
+		/* Use SIMD for large arrays */
+		if (ht->nNumOfElements >= ZEND_SIMD_MIN_ELEMENTS) {
+			return zend_verify_packed_elements_long_avx2(ht->arPacked, ht->nNumOfElements);
+		}
+#endif
+		return zend_verify_packed_array_elements_long(ht->arPacked, ht->nNumOfElements);
+	}
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		ZVAL_DEREF(val);
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_LONG)) return false;
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_double(HashTable *ht)
+{
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		ZVAL_DEREF(val);
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_DOUBLE && Z_TYPE_P(val) != IS_LONG)) return false;
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_string(HashTable *ht)
+{
+	if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+#ifdef ZEND_HAS_SIMD_ARRAY_VALIDATION
+		/* Use SIMD for large arrays */
+		if (ht->nNumOfElements >= ZEND_SIMD_MIN_ELEMENTS) {
+			return zend_verify_packed_elements_string_avx2(ht->arPacked, ht->nNumOfElements);
+		}
+#endif
+		return zend_verify_packed_array_elements_string(ht->arPacked, ht->nNumOfElements);
+	}
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		ZVAL_DEREF(val);
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_STRING)) return false;
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_bool(HashTable *ht)
+{
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		ZVAL_DEREF(val);
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_TRUE && Z_TYPE_P(val) != IS_FALSE)) return false;
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+/*
+ * Optimized object array validation with multiple fast paths:
+ *
+ * 1. Exact class match: If object's class == expected class, skip instanceof
+ * 2. Monomorphic arrays: Detect when all objects share same class, use pointer comparison
+ * 3. Polymorphic fallback: Use instanceof_function for inheritance checks
+ *
+ * Most real-world typed arrays are monomorphic (all same concrete class),
+ * so the pointer comparison fast path handles the common case efficiently.
+ */
+static zend_always_inline bool zend_verify_array_elements_object(HashTable *ht, zend_class_entry *ce)
+{
+	zval *val;
+	zend_class_entry *first_ce = NULL;
+	bool is_monomorphic = true;
+
+	/* No class constraint - just check all are objects */
+	if (ce == NULL) {
+		ZEND_HASH_FOREACH_VAL(ht, val) {
+			if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+				val = Z_REFVAL_P(val);
+			}
+			if (UNEXPECTED(Z_TYPE_P(val) != IS_OBJECT)) {
+				return false;
+			}
+		} ZEND_HASH_FOREACH_END();
+		return true;
+	}
+
+	/* First pass: check types and detect monomorphic pattern */
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		zend_class_entry *obj_ce;
+
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_OBJECT)) {
+			return false;
+		}
+
+		obj_ce = Z_OBJCE_P(val);
+
+		/* Fast path: exact class match (no inheritance check needed) */
+		if (EXPECTED(obj_ce == ce)) {
+			if (first_ce == NULL) {
+				first_ce = obj_ce;
+			}
+			continue;
+		}
+
+		/* Track if array is monomorphic (all same concrete class) */
+		if (first_ce == NULL) {
+			first_ce = obj_ce;
+		} else if (obj_ce != first_ce) {
+			is_monomorphic = false;
+		}
+
+		/* Slow path: check inheritance via instanceof */
+		if (UNEXPECTED(!instanceof_function(obj_ce, ce))) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+
+	return true;
+}
+
+/*
+ * Even faster validation for packed object arrays with monomorphic content.
+ * When we know all objects are the same class (common case), we can:
+ * 1. Check first object's class satisfies constraint
+ * 2. Just verify remaining objects are same class (pointer comparison)
+ */
+static zend_always_inline bool zend_verify_packed_array_elements_object_monomorphic(
+	zval *data, uint32_t count, zend_class_entry *ce)
+{
+	if (count == 0) return true;
+
+	/* Check first element */
+	zval *first = data;
+	if (UNEXPECTED(Z_TYPE_P(first) == IS_REFERENCE)) {
+		first = Z_REFVAL_P(first);
+	}
+	if (UNEXPECTED(Z_TYPE_P(first) != IS_OBJECT)) {
+		return false;
+	}
+
+	zend_class_entry *first_ce = Z_OBJCE_P(first);
+
+	/* Verify first element satisfies constraint */
+	if (ce != NULL && first_ce != ce && !instanceof_function(first_ce, ce)) {
+		return false;
+	}
+
+	/* Fast path: compare remaining objects to first (pointer comparison only) */
+	for (uint32_t i = 1; i < count; i++) {
+		zval *val = &data[i];
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_OBJECT)) {
+			return false;
+		}
+		/* Fast pointer comparison - if same class as first, already validated */
+		if (EXPECTED(Z_OBJCE_P(val) == first_ce)) {
+			continue;
+		}
+		/* Different class - check constraint (polymorphic case) */
+		if (ce != NULL && Z_OBJCE_P(val) != ce && !instanceof_function(Z_OBJCE_P(val), ce)) {
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/* Cold path: find the failing element for error reporting (simple types) */
+static ZEND_COLD zend_long zend_find_invalid_array_element_simple(
+	HashTable *ht, uint8_t type_code, zend_class_entry *cached_ce, zval **out_val)
+{
+	zval *val;
+	zend_ulong idx;
+	zend_string *key;
+	zend_long numeric_idx = 0;
+
+	ZEND_HASH_FOREACH_KEY_VAL(ht, idx, key, val) {
+		zend_long current_idx = key ? numeric_idx : (zend_long)idx;
+		bool type_matches = false;
+
+		ZVAL_DEREF(val);
+
+		switch (type_code) {
+			case IS_LONG:
+				type_matches = (Z_TYPE_P(val) == IS_LONG);
+				break;
+			case IS_DOUBLE:
+				type_matches = (Z_TYPE_P(val) == IS_DOUBLE || Z_TYPE_P(val) == IS_LONG);
+				break;
+			case IS_STRING:
+				type_matches = (Z_TYPE_P(val) == IS_STRING);
+				break;
+			case _IS_BOOL:
+				type_matches = (Z_TYPE_P(val) == IS_TRUE || Z_TYPE_P(val) == IS_FALSE);
+				break;
+			case IS_OBJECT:
+				if (Z_TYPE_P(val) == IS_OBJECT) {
+					type_matches = !cached_ce || instanceof_function(Z_OBJCE_P(val), cached_ce);
+				}
+				break;
+			default:
+				type_matches = true;
+				break;
+		}
+
+		if (!type_matches) {
+			*out_val = val;
+			return current_idx;
+		}
+		numeric_idx++;
+	} ZEND_HASH_FOREACH_END();
+
+	*out_val = NULL;
+	return -1;
+}
+
+/* Cold path: find the failing element for error reporting (union/complex types) */
+/* Forward declaration for recursive validation */
+static bool zend_verify_nested_array_type(zval *val, const zend_type *element_type);
+
+static ZEND_COLD zend_long zend_find_invalid_array_element_union(
+	HashTable *ht, const zend_type *element_type, zval **out_val)
+{
+	zval *val;
+	zend_ulong idx;
+	zend_string *key;
+	zend_long numeric_idx = 0;
+
+	ZEND_HASH_FOREACH_KEY_VAL(ht, idx, key, val) {
+		zend_long current_idx = key ? numeric_idx : (zend_long)idx;
+
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(*element_type)) {
+			if (!zend_verify_nested_array_type(val, element_type)) {
+				*out_val = val;
+				ZVAL_DEREF(*out_val);
+				return current_idx;
+			}
+		} else if (!zend_check_type(element_type, val, NULL, 0, 0)) {
+			*out_val = val;
+			ZVAL_DEREF(*out_val);
+			return current_idx;
+		}
+		numeric_idx++;
+	} ZEND_HASH_FOREACH_END();
+
+	*out_val = NULL;
+	return -1;
+}
+
+/* Thread-local recursion depth counter for nested array validation */
+ZEND_TLS int zend_typed_array_recursion_depth = 0;
+
+static zend_always_inline bool zend_verify_array_elements_union(HashTable *ht, const zend_type *element_type)
+{
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(*element_type)) {
+			if (!zend_verify_nested_array_type(val, element_type)) {
+				return false;
+			}
+		} else if (!zend_check_type(element_type, val, NULL, 0, 0)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+static bool zend_verify_nested_array_type(zval *val, const zend_type *array_type)
+{
+	if (Z_TYPE_P(val) != IS_ARRAY) {
+		return false;
+	}
+
+	/* Check recursion depth limit */
+	if (UNEXPECTED(zend_typed_array_recursion_depth >= ZEND_TYPED_ARRAY_MAX_DEPTH)) {
+		zend_error(E_WARNING, "Maximum nested typed array depth of %d exceeded", ZEND_TYPED_ARRAY_MAX_DEPTH);
+		return false;
+	}
+
+	const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(*array_type);
+	if (!elem_type) {
+		return true;
+	}
+
+	zend_typed_array_recursion_depth++;
+
+	zval *inner_val;
+	bool result = true;
+	ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(val), inner_val) {
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(elem_type->element_type)) {
+			if (!zend_verify_nested_array_type(inner_val, &elem_type->element_type)) {
+				result = false;
+				break;
+			}
+		} else if (!zend_check_type(&elem_type->element_type, inner_val, NULL, 0, 0)) {
+			result = false;
+			break;
+		}
+	} ZEND_HASH_FOREACH_END();
+
+	zend_typed_array_recursion_depth--;
+	return result;
+}
+
+static zend_always_inline uint8_t zend_get_simple_type_code(const zend_type *type)
+{
+	if (ZEND_TYPE_HAS_LIST(*type) ||
+	    ZEND_TYPE_HAS_ARRAY_ELEMENT(*type) ||
+	    (ZEND_TYPE_HAS_NAME(*type) && ZEND_TYPE_PURE_MASK(*type) != 0)) {
+		return 0;
+	}
+
+	uint32_t type_mask = ZEND_TYPE_PURE_MASK(*type);
+
+	if (type_mask == MAY_BE_LONG) return IS_LONG;
+	if (type_mask == MAY_BE_DOUBLE) return IS_DOUBLE;
+	if (type_mask == MAY_BE_STRING) return IS_STRING;
+	if (type_mask == MAY_BE_BOOL) return _IS_BOOL;
+	if (type_mask == MAY_BE_ARRAY) return IS_ARRAY;
+	if (type_mask == MAY_BE_OBJECT || ZEND_TYPE_HAS_NAME(*type)) return IS_OBJECT;
+
+	return 0; /* Complex type */
+}
+
+/*
+ * Thread-local cache for class entry lookups in array<ClassName> validation.
+ * Caches the last looked up class name and its corresponding class entry.
+ * This avoids repeated zend_lookup_class() calls for the same class type.
+ */
+ZEND_TLS zend_string *zend_cached_class_name = NULL;
+ZEND_TLS zend_class_entry *zend_cached_class_entry = NULL;
+
+static zend_always_inline zend_class_entry *zend_lookup_class_cached(zend_string *class_name)
+{
+	/* Check cache first */
+	if (zend_cached_class_name != NULL &&
+		zend_string_equals(class_name, zend_cached_class_name)) {
+		/* Verify the cached class entry is still valid */
+		if (zend_cached_class_entry != NULL) {
+			return zend_cached_class_entry;
+		}
+	}
+
+	/* Cache miss - do the lookup and cache the result */
+	zend_class_entry *ce = zend_lookup_class(class_name);
+
+	/* Update cache (we don't hold a reference, so this is a weak cache) */
+	zend_cached_class_name = class_name;
+	zend_cached_class_entry = ce;
+
+	return ce;
+}
+
+ZEND_API bool zend_verify_array_element_types(
+	const zend_function *zf, zval *arr, const zend_typed_array_element *elem_type)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+	bool valid;
+	zend_class_entry *cached_ce = NULL;
+	zend_string *expected_type_str = NULL;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* Check key types if specified */
+	if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(elem_type->key_type);
+		if (!zend_verify_array_key_types(ht, key_mask)) {
+			zend_string *key_type_str = zend_type_to_string(elem_type->key_type);
+			const char *actual_key_type = zend_find_invalid_key_type(ht, key_mask);
+			zend_verify_array_key_type_error(zf, ZSTR_VAL(key_type_str), actual_key_type);
+			zend_string_release(key_type_str);
+			return false;
+		}
+	}
+
+	/* Check if this is a simple type (for optimized fast paths) */
+	uint8_t simple_type = zend_get_simple_type_code(&elem_type->element_type);
+
+	/* Fast path: check if array was already validated for this type */
+	/* Only works for simple types without class names */
+	if (simple_type != 0 && HT_ELEM_TYPE_IS_VALID(ht) &&
+		HT_VALIDATED_ELEM_TYPE(ht) == simple_type &&
+		(simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type))) {
+		return true;
+	}
+
+	/* Select validation strategy based on type */
+	if (simple_type != 0) {
+		/* Simple type - use optimized fast paths */
+		switch (simple_type) {
+			case IS_LONG:
+				valid = zend_verify_array_elements_long(ht);
+				break;
+			case IS_DOUBLE:
+				valid = zend_verify_array_elements_double(ht);
+				break;
+			case IS_STRING:
+				valid = zend_verify_array_elements_string(ht);
+				break;
+			case _IS_BOOL:
+				valid = zend_verify_array_elements_bool(ht);
+				break;
+			case IS_OBJECT:
+				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
+					cached_ce = zend_lookup_class_cached(class_name);
+				}
+				/* Use packed array optimization for monomorphic object arrays */
+				if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+					valid = zend_verify_packed_array_elements_object_monomorphic(
+						ht->arPacked, ht->nNumOfElements, cached_ce);
+				} else {
+					valid = zend_verify_array_elements_object(ht, cached_ce);
+				}
+				break;
+			default:
+				valid = true;
+				break;
+		}
+
+		if (EXPECTED(valid)) {
+			/* Cache the validated type (skip for class-specific object validation) */
+			if (simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+				HT_SET_VALIDATED_ELEM_TYPE(ht, simple_type);
+			}
+			return true;
+		}
+
+		/* Slow path (cold): find and report the failing element */
+		zval *failing_val;
+		zend_long failing_idx = zend_find_invalid_array_element_simple(ht, simple_type, cached_ce, &failing_val);
+		if (failing_idx >= 0 && failing_val) {
+			expected_type_str = zend_type_to_string(elem_type->element_type);
+			const char *actual_type_name = zend_zval_type_name(failing_val);
+			zend_verify_array_element_type_error(zf, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+			zend_string_release(expected_type_str);
+		}
+		return false;
+	}
+
+	/* Union/complex type - use generic validation */
+	valid = zend_verify_array_elements_union(ht, &elem_type->element_type);
+
+	if (EXPECTED(valid)) {
+		return true;
+	}
+
+	/* Slow path (cold): find and report the failing element */
+	zval *failing_val;
+	zend_long failing_idx = zend_find_invalid_array_element_union(ht, &elem_type->element_type, &failing_val);
+	if (failing_idx >= 0 && failing_val) {
+		expected_type_str = zend_type_to_string(elem_type->element_type);
+		const char *actual_type_name = zend_zval_type_name(failing_val);
+		zend_verify_array_element_type_error(zf, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+		zend_string_release(expected_type_str);
+	}
+	return false;
+}
+
+/* Validate array element types for function argument with array<T> */
+ZEND_API bool zend_verify_array_arg_element_types(
+	const zend_function *zf, uint32_t arg_num, zval *arr, const zend_typed_array_element *elem_type)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+	bool valid;
+	zend_class_entry *cached_ce = NULL;
+	zend_string *expected_type_str = NULL;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* Check key types if specified */
+	if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(elem_type->key_type);
+		if (!zend_verify_array_key_types(ht, key_mask)) {
+			zend_string *key_type_str = zend_type_to_string(elem_type->key_type);
+			const char *actual_key_type = zend_find_invalid_key_type(ht, key_mask);
+			zend_verify_array_arg_key_type_error(arg_num, ZSTR_VAL(key_type_str), actual_key_type);
+			zend_string_release(key_type_str);
+			return false;
+		}
+	}
+
+	/* Check if this is a simple type (for optimized fast paths) */
+	uint8_t simple_type = zend_get_simple_type_code(&elem_type->element_type);
+
+	/* Fast path: check if array was already validated for this type */
+	if (simple_type != 0 && HT_ELEM_TYPE_IS_VALID(ht) &&
+		HT_VALIDATED_ELEM_TYPE(ht) == simple_type &&
+		(simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type))) {
+		return true;
+	}
+
+	/* Select validation strategy based on type */
+	if (simple_type != 0) {
+		/* Simple type - use optimized fast paths */
+		switch (simple_type) {
+			case IS_LONG:
+				valid = zend_verify_array_elements_long(ht);
+				break;
+			case IS_DOUBLE:
+				valid = zend_verify_array_elements_double(ht);
+				break;
+			case IS_STRING:
+				valid = zend_verify_array_elements_string(ht);
+				break;
+			case _IS_BOOL:
+				valid = zend_verify_array_elements_bool(ht);
+				break;
+			case IS_OBJECT:
+				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
+					cached_ce = zend_lookup_class_cached(class_name);
+				}
+				/* Use packed array optimization for monomorphic object arrays */
+				if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+					valid = zend_verify_packed_array_elements_object_monomorphic(
+						ht->arPacked, ht->nNumOfElements, cached_ce);
+				} else {
+					valid = zend_verify_array_elements_object(ht, cached_ce);
+				}
+				break;
+			default:
+				valid = true;
+				break;
+		}
+
+		if (EXPECTED(valid)) {
+			/* Cache the validated type (skip for class-specific object validation) */
+			if (simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+				HT_SET_VALIDATED_ELEM_TYPE(ht, simple_type);
+			}
+			return true;
+		}
+
+		/* Slow path (cold): find and report the failing element */
+		zval *failing_val;
+		zend_long failing_idx = zend_find_invalid_array_element_simple(ht, simple_type, cached_ce, &failing_val);
+		if (failing_idx >= 0 && failing_val) {
+			expected_type_str = zend_type_to_string(elem_type->element_type);
+			const char *actual_type_name = zend_zval_type_name(failing_val);
+			zend_verify_array_arg_element_type_error(zf, arg_num, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+			zend_string_release(expected_type_str);
+		}
+		return false;
+	}
+
+	/* Union/complex type - use generic validation */
+	valid = zend_verify_array_elements_union(ht, &elem_type->element_type);
+
+	if (EXPECTED(valid)) {
+		return true;
+	}
+
+	/* Slow path (cold): find and report the failing element */
+	zval *failing_val;
+	zend_long failing_idx = zend_find_invalid_array_element_union(ht, &elem_type->element_type, &failing_val);
+	if (failing_idx >= 0 && failing_val) {
+		expected_type_str = zend_type_to_string(elem_type->element_type);
+		const char *actual_type_name = zend_zval_type_name(failing_val);
+		zend_verify_array_arg_element_type_error(zf, arg_num, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+		zend_string_release(expected_type_str);
+	}
+	return false;
+}
+
+/* Validate array element types for property with array<T> */
+ZEND_API bool zend_verify_array_prop_element_types(
+	const zend_property_info *info, zval *arr, const zend_typed_array_element *elem_type)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+	bool valid;
+	zend_class_entry *cached_ce = NULL;
+	zend_string *expected_type_str = NULL;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* Check key types if specified */
+	if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(elem_type->key_type);
+		if (!zend_verify_array_key_types(ht, key_mask)) {
+			zend_string *key_type_str = zend_type_to_string(elem_type->key_type);
+			const char *actual_key_type = zend_find_invalid_key_type(ht, key_mask);
+			zend_verify_array_prop_key_type_error(info, ZSTR_VAL(key_type_str), actual_key_type);
+			zend_string_release(key_type_str);
+			return false;
+		}
+	}
+
+	/* Check if this is a simple type (for optimized fast paths) */
+	uint8_t simple_type = zend_get_simple_type_code(&elem_type->element_type);
+
+	/* Fast path: check if array was already validated for this type */
+	if (simple_type != 0 && HT_ELEM_TYPE_IS_VALID(ht) &&
+		HT_VALIDATED_ELEM_TYPE(ht) == simple_type &&
+		(simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type))) {
+		return true;
+	}
+
+	/* Select validation strategy based on type */
+	if (simple_type != 0) {
+		/* Simple type - use optimized fast paths */
+		switch (simple_type) {
+			case IS_LONG:
+				valid = zend_verify_array_elements_long(ht);
+				break;
+			case IS_DOUBLE:
+				valid = zend_verify_array_elements_double(ht);
+				break;
+			case IS_STRING:
+				valid = zend_verify_array_elements_string(ht);
+				break;
+			case _IS_BOOL:
+				valid = zend_verify_array_elements_bool(ht);
+				break;
+			case IS_OBJECT:
+				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
+					cached_ce = zend_lookup_class_cached(class_name);
+				}
+				/* Use packed array optimization for monomorphic object arrays */
+				if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+					valid = zend_verify_packed_array_elements_object_monomorphic(
+						ht->arPacked, ht->nNumOfElements, cached_ce);
+				} else {
+					valid = zend_verify_array_elements_object(ht, cached_ce);
+				}
+				break;
+			default:
+				valid = true;
+				break;
+		}
+
+		if (EXPECTED(valid)) {
+			/* Cache the validated type (skip for class-specific object validation) */
+			if (simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+				HT_SET_VALIDATED_ELEM_TYPE(ht, simple_type);
+			}
+			return true;
+		}
+
+		/* Slow path (cold): find and report the failing element */
+		zval *failing_val;
+		zend_long failing_idx = zend_find_invalid_array_element_simple(ht, simple_type, cached_ce, &failing_val);
+		if (failing_idx >= 0 && failing_val) {
+			expected_type_str = zend_type_to_string(elem_type->element_type);
+			const char *actual_type_name = zend_zval_type_name(failing_val);
+			zend_verify_array_prop_element_type_error(info, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+			zend_string_release(expected_type_str);
+		}
+		return false;
+	}
+
+	/* Union/complex type - use generic validation */
+	valid = zend_verify_array_elements_union(ht, &elem_type->element_type);
+
+	if (EXPECTED(valid)) {
+		return true;
+	}
+
+	/* Slow path (cold): find and report the failing element */
+	zval *failing_val;
+	zend_long failing_idx = zend_find_invalid_array_element_union(ht, &elem_type->element_type, &failing_val);
+	if (failing_idx >= 0 && failing_val) {
+		expected_type_str = zend_type_to_string(elem_type->element_type);
+		const char *actual_type_name = zend_zval_type_name(failing_val);
+		zend_verify_array_prop_element_type_error(info, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+		zend_string_release(expected_type_str);
+	}
+	return false;
+}
+
+/* zend_shape_check_result enum is defined in zend_compile.h */
+
+static zend_always_inline zend_shape_check_result zend_check_array_shape(
+	HashTable *ht, const zend_array_shape *shape,
+	const zend_array_shape_element **failed_elem, zval **failed_val,
+	zend_string **extra_key)
+{
+	for (uint32_t i = 0; i < shape->num_elements; i++) {
+		const zend_array_shape_element *elem = &shape->elements[i];
+		zval *val = zend_hash_find(ht, elem->key);
+
+		if (UNEXPECTED(val == NULL)) {
+			if (!elem->is_optional) {
+				*failed_elem = elem;
+				*failed_val = NULL;
+				return SHAPE_MISSING_KEY;
+			}
+			continue;
+		}
+
+		if (UNEXPECTED(!zend_check_type(&elem->type, val, NULL, 0, false))) {
+			*failed_elem = elem;
+			*failed_val = val;
+			return SHAPE_WRONG_TYPE;
+		}
+	}
+
+	/* For closed shapes, check that no extra keys exist */
+	if (UNEXPECTED(shape->is_closed)) {
+		if (zend_hash_num_elements(ht) != shape->num_elements) {
+			/* Use cached expected_keys hash table for O(1) lookup if available */
+			HashTable *expected_keys = shape->expected_keys;
+			HashTable local_keys;
+
+			/* Fallback to building temporary hash if cache is not available (arena shapes) */
+			if (!expected_keys) {
+				zend_hash_init(&local_keys, shape->num_elements, NULL, NULL, 0);
+				for (uint32_t i = 0; i < shape->num_elements; i++) {
+					zend_hash_add_empty_element(&local_keys, shape->elements[i].key);
+				}
+				expected_keys = &local_keys;
+			}
+
+			/* Find the first extra key for error message */
+			zend_string *key;
+			ZEND_HASH_FOREACH_STR_KEY(ht, key) {
+				if (key && !zend_hash_exists(expected_keys, key)) {
+					*extra_key = key;
+					if (expected_keys == &local_keys) {
+						zend_hash_destroy(&local_keys);
+					}
+					return SHAPE_EXTRA_KEY;
+				}
+			} ZEND_HASH_FOREACH_END();
+
+			if (expected_keys == &local_keys) {
+				zend_hash_destroy(&local_keys);
+			}
+		}
+	}
+
+	return SHAPE_OK;
+}
+
+static ZEND_COLD void zend_shape_return_error(
+	const zend_function *zf, zend_shape_check_result result,
+	const zend_array_shape_element *elem, zval *val, zend_string *extra_key)
+{
+	const char *fname = ZSTR_VAL(zf->common.function_name);
+	const char *fsep = zf->common.scope ? "::" : "";
+	const char *fclass = zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "";
+
+	if (result == SHAPE_EXTRA_KEY) {
+		zend_type_error("%s%s%s(): Return value must be of type " ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY,
+			fclass, fsep, fname, ZSTR_VAL(extra_key));
+		return;
+	}
+
+	zend_string *expected = zend_type_to_string(elem->type);
+
+	if (result == SHAPE_MISSING_KEY) {
+		zend_type_error("%s%s%s(): Return value must be of type " ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY,
+			fclass, fsep, fname, ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key));
+	} else {
+		zend_type_error("%s%s%s(): Return value must be of type " ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE,
+			fclass, fsep, fname, ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key), zend_zval_value_name(val));
+	}
+	zend_string_release(expected);
+}
+
+static ZEND_COLD void zend_shape_arg_error(
+	uint32_t arg_num, zend_shape_check_result result,
+	const zend_array_shape_element *elem, zval *val, zend_string *extra_key)
+{
+	if (result == SHAPE_EXTRA_KEY) {
+		zend_argument_type_error(arg_num,
+			"must be of type " ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY,
+			ZSTR_VAL(extra_key));
+		return;
+	}
+
+	zend_string *expected = zend_type_to_string(elem->type);
+
+	if (result == SHAPE_MISSING_KEY) {
+		zend_argument_type_error(arg_num,
+			"must be of type " ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY,
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected), ZSTR_VAL(elem->key));
+	} else {
+		zend_argument_type_error(arg_num,
+			"must be of type " ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE,
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key), zend_zval_value_name(val));
+	}
+	zend_string_release(expected);
+}
+
+ZEND_API bool zend_verify_array_shape(
+	const zend_function *zf, zval *arr, const zend_array_shape *shape)
+{
+	const zend_array_shape_element *failed_elem;
+	zval *failed_val;
+	zend_string *extra_key = NULL;
+
+	zend_shape_check_result result = zend_check_array_shape(
+		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val, &extra_key);
+
+	if (UNEXPECTED(result != SHAPE_OK)) {
+		zend_shape_return_error(zf, result, failed_elem, failed_val, extra_key);
+		return false;
+	}
+	return true;
+}
+
+ZEND_API bool zend_verify_array_arg_shape(
+	uint32_t arg_num, zval *arr, const zend_array_shape *shape)
+{
+	const zend_array_shape_element *failed_elem;
+	zval *failed_val;
+	zend_string *extra_key = NULL;
+
+	zend_shape_check_result result = zend_check_array_shape(
+		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val, &extra_key);
+
+	if (UNEXPECTED(result != SHAPE_OK)) {
+		zend_shape_arg_error(arg_num, result, failed_elem, failed_val, extra_key);
+		return false;
+	}
+	return true;
+}
+
+static ZEND_COLD void zend_shape_prop_error(
+	const zend_property_info *info, zend_shape_check_result result,
+	const zend_array_shape_element *elem, zval *val, zend_string *extra_key)
+{
+	if (result == SHAPE_EXTRA_KEY) {
+		zend_type_error("Cannot assign to property %s::$%s of type " ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY,
+			ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name),
+			ZSTR_VAL(extra_key));
+		return;
+	}
+
+	zend_string *expected = zend_type_to_string(elem->type);
+
+	if (result == SHAPE_MISSING_KEY) {
+		zend_type_error("Cannot assign to property %s::$%s of type " ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY,
+			ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name),
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected), ZSTR_VAL(elem->key));
+	} else {
+		zend_type_error("Cannot assign to property %s::$%s of type " ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE,
+			ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name),
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key), zend_zval_value_name(val));
+	}
+	zend_string_release(expected);
+}
+
+ZEND_API bool zend_verify_array_prop_shape(
+	const zend_property_info *info, zval *arr, const zend_array_shape *shape)
+{
+	const zend_array_shape_element *failed_elem;
+	zval *failed_val;
+	zend_string *extra_key = NULL;
+
+	zend_shape_check_result result = zend_check_array_shape(
+		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val, &extra_key);
+
+	if (UNEXPECTED(result != SHAPE_OK)) {
+		zend_shape_prop_error(info, result, failed_elem, failed_val, extra_key);
+		return false;
+	}
+	return true;
+}
+
+/* ZEND_SHAPE_MAX_RECURSION_DEPTH is defined in zend_compile.h */
+
+/* Thread-local recursion depth counter for shape validation.
+ * SAFETY: This counter is incremented before validation and decremented after.
+ * The code between increment and decrement must NOT throw exceptions or longjmp.
+ * Currently safe because: zend_check_array_shape, zend_check_type, and hash
+ * iteration all return values rather than throwing. If future modifications
+ * add exception-throwing code, use zend_try/zend_catch for cleanup. */
+ZEND_TLS int zend_shape_recursion_depth = 0;
+
+/* Reset shape recursion depth - called at request startup as defensive measure */
+ZEND_API void zend_reset_shape_recursion_depth(void)
+{
+	zend_shape_recursion_depth = 0;
+	zend_typed_array_recursion_depth = 0;
+}
+
+/* Check if a type name is actually a shape and validate accordingly */
+static bool zend_check_shape_type(const zend_type *type, zval *arg, bool is_return_type ZEND_ATTRIBUTE_UNUSED)
+{
+	if (!ZEND_TYPE_HAS_NAME(*type)) {
+		return false;
+	}
+
+	/* Check for excessive recursion depth (circular shape references).
+	 * This check happens BEFORE incrementing to avoid counter imbalance on error. */
+	if (UNEXPECTED(zend_shape_recursion_depth >= ZEND_SHAPE_MAX_RECURSION_DEPTH)) {
+		zend_error_noreturn(E_ERROR,
+			"Maximum shape nesting level of %d exceeded, possible circular reference",
+			ZEND_SHAPE_MAX_RECURSION_DEPTH);
+	}
+
+	zend_string *name = ZEND_TYPE_NAME(*type);
+	zend_shape_entry *shape = zend_lookup_shape(name);
+
+	if (!shape) {
+		return false;  /* Not a shape, caller should try class */
+	}
+
+	/* It's a shape - validate the value against the shape's type */
+	if (Z_TYPE_P(arg) != IS_ARRAY) {
+		return false;  /* Shapes require arrays */
+	}
+
+	/* Track recursion depth to detect circular references.
+	 * All code paths after this MUST go through 'done' label to decrement. */
+	zend_shape_recursion_depth++;
+	bool result = false;
+
+	/* Use the shape's type for validation */
+	zend_type shape_type = shape->type;
+
+	/* Check if it's an array shape type */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(shape_type) && shape_type.ptr != NULL) {
+		zend_array_shape *shape_def = ZEND_ARRAY_SHAPE(shape_type);
+		const zend_array_shape_element *failed_elem;
+		zval *failed_val;
+		zend_string *extra_key = NULL;
+		/* Validate the array against the shape definition */
+		zend_shape_check_result check_result = zend_check_array_shape(
+			Z_ARRVAL_P(arg), shape_def, &failed_elem, &failed_val, &extra_key);
+		result = (check_result == SHAPE_OK);
+		goto done;
+	}
+
+	/* Check if it's a typed array */
+	if (ZEND_TYPE_HAS_ARRAY_ELEMENT(shape_type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(shape_type);
+		HashTable *ht = Z_ARRVAL_P(arg);
+		zval *val;
+		result = true;
+		ZEND_HASH_FOREACH_VAL(ht, val) {
+			if (!ZEND_TYPE_CONTAINS_CODE(elem->element_type, Z_TYPE_P(val))) {
+				result = false;
+				break;
+			}
+		} ZEND_HASH_FOREACH_END();
+		goto done;
+	}
+
+	/* For simple array type */
+	if (ZEND_TYPE_PURE_MASK(shape_type) & MAY_BE_ARRAY) {
+		result = true;
+	}
+
+done:
+	zend_shape_recursion_depth--;
+	return result;
+}
+
 ZEND_API ZEND_COLD void zend_verify_never_error(const zend_function *zf)
 {
 	zend_string *func_name = get_function_or_method_name(zf);
diff --git a/Zend/zend_execute.h b/Zend/zend_execute.h
index c08adf2a..a3d6cfb9 100644
--- a/Zend/zend_execute.h
+++ b/Zend/zend_execute.h
@@ -51,6 +51,9 @@ ZEND_API void execute_internal(zend_execute_data *execute_data, zval *return_val
 ZEND_API bool zend_is_valid_class_name(zend_string *name);
 ZEND_API zend_class_entry *zend_lookup_class(zend_string *name);
 ZEND_API zend_class_entry *zend_lookup_class_ex(zend_string *name, zend_string *lcname, uint32_t flags);
+ZEND_API zend_shape_entry *zend_lookup_shape(zend_string *name);
+ZEND_API void zend_reset_shape_recursion_depth(void);
+ZEND_API zend_shape_entry *zend_lookup_shape_ex(zend_string *name, zend_string *lcname, uint32_t flags);
 ZEND_API zend_class_entry *zend_get_called_scope(zend_execute_data *ex);
 ZEND_API zend_object *zend_get_this_object(zend_execute_data *ex);
 ZEND_API zend_result zend_eval_string(const char *str, zval *retval_ptr, const char *string_name);
@@ -105,6 +108,33 @@ ZEND_API ZEND_COLD void zend_verify_arg_error(
 		const zend_function *zf, const zend_arg_info *arg_info, uint32_t arg_num, const zval *value);
 ZEND_API ZEND_COLD void zend_verify_return_error(
 		const zend_function *zf, const zval *value);
+ZEND_API ZEND_COLD void zend_verify_array_element_type_error(
+		const zend_function *zf, zend_long index, const zval *element,
+		const char *expected_type, const char *actual_type);
+ZEND_API ZEND_COLD void zend_verify_array_arg_element_type_error(
+		const zend_function *zf, uint32_t arg_num, zend_long index, const zval *element,
+		const char *expected_type, const char *actual_type);
+ZEND_API bool zend_verify_array_element_types(
+		const zend_function *zf, zval *arr, const zend_typed_array_element *elem_type);
+ZEND_API bool zend_verify_array_arg_element_types(
+		const zend_function *zf, uint32_t arg_num, zval *arr, const zend_typed_array_element *elem_type);
+ZEND_API ZEND_COLD void zend_verify_array_prop_element_type_error(
+		const zend_property_info *info, zend_long index, const zval *element,
+		const char *expected_type, const char *actual_type);
+ZEND_API bool zend_verify_array_prop_element_types(
+		const zend_property_info *info, zval *arr, const zend_typed_array_element *elem_type);
+ZEND_API bool zend_verify_array_prop_shape(
+		const zend_property_info *info, zval *arr, const zend_array_shape *shape);
+ZEND_API ZEND_COLD void zend_verify_array_key_type_error(
+		const zend_function *zf, const char *expected_key_type, const char *actual_key_type);
+ZEND_API ZEND_COLD void zend_verify_array_arg_key_type_error(
+		uint32_t arg_num, const char *expected_key_type, const char *actual_key_type);
+ZEND_API ZEND_COLD void zend_verify_array_prop_key_type_error(
+		const zend_property_info *info, const char *expected_key_type, const char *actual_key_type);
+ZEND_API bool zend_verify_array_shape(
+		const zend_function *zf, zval *arr, const zend_array_shape *shape);
+ZEND_API bool zend_verify_array_arg_shape(
+		uint32_t arg_num, zval *arr, const zend_array_shape *shape);
 ZEND_API ZEND_COLD void zend_verify_never_error(
 		const zend_function *zf);
 ZEND_API bool zend_verify_ref_array_assignable(zend_reference *ref);
diff --git a/Zend/zend_execute_API.c b/Zend/zend_execute_API.c
index 0719fcbb..f331d7ff 100644
--- a/Zend/zend_execute_API.c
+++ b/Zend/zend_execute_API.c
@@ -129,6 +129,9 @@ void init_executor(void) /* {{{ */
 {
 	zend_init_fpu();
 
+	/* Reset shape/typed array recursion counters (defensive measure) */
+	zend_reset_shape_recursion_depth();
+
 	ZVAL_NULL(&EG(uninitialized_zval));
 	ZVAL_ERROR(&EG(error_zval));
 /* destroys stack frame, therefore makes core dumps worthless */
@@ -144,6 +147,7 @@ void init_executor(void) /* {{{ */
 
 	EG(function_table) = CG(function_table);
 	EG(class_table) = CG(class_table);
+	EG(shape_table) = CG(shape_table);
 
 	EG(in_autoload) = NULL;
 	EG(error_handling) = EH_NORMAL;
@@ -1296,6 +1300,101 @@ ZEND_API zend_class_entry *zend_lookup_class(zend_string *name) /* {{{ */
 }
 /* }}} */
 
+ZEND_API zend_shape_entry *zend_lookup_shape_ex(zend_string *name, zend_string *lc_name, uint32_t flags) /* {{{ */
+{
+	zval *zv;
+	zend_string *lookup_name;
+	bool free_lookup_name = false;
+	zend_shape_entry *shape = NULL;
+
+	if (lc_name) {
+		lookup_name = lc_name;
+	} else {
+		if (!ZSTR_LEN(name)) {
+			return NULL;
+		}
+
+		if (ZSTR_VAL(name)[0] == '\\') {
+			lookup_name = zend_string_alloc(ZSTR_LEN(name) - 1, 0);
+			zend_str_tolower_copy(ZSTR_VAL(lookup_name), ZSTR_VAL(name) + 1, ZSTR_LEN(name) - 1);
+		} else {
+			lookup_name = zend_string_tolower(name);
+		}
+		free_lookup_name = true;
+	}
+
+	zv = zend_hash_find(EG(shape_table), lookup_name);
+	if (zv) {
+		shape = (zend_shape_entry*)Z_PTR_P(zv);
+		goto done;
+	}
+
+	/* Shape not found - try autoloading if allowed */
+	/* The compiler is not-reentrant. Make sure we autoload only during run-time. */
+	if ((flags & ZEND_FETCH_CLASS_NO_AUTOLOAD) || zend_is_compiling()) {
+		goto done;
+	}
+
+	if (!zend_autoload) {
+		goto done;
+	}
+
+	/* Use the same in_autoload hash as classes to prevent recursive autoloading */
+	if (EG(in_autoload) == NULL) {
+		ALLOC_HASHTABLE(EG(in_autoload));
+		zend_hash_init(EG(in_autoload), 8, NULL, NULL, 0);
+	}
+
+	if (zend_hash_add_empty_element(EG(in_autoload), lookup_name) == NULL) {
+		/* Already autoloading this shape */
+		goto done;
+	}
+
+	{
+		zend_string *autoload_name;
+		if (ZSTR_VAL(name)[0] == '\\') {
+			autoload_name = zend_string_init(ZSTR_VAL(name) + 1, ZSTR_LEN(name) - 1, 0);
+		} else {
+			autoload_name = zend_string_copy(name);
+		}
+
+		zend_string *previous_filename = EG(filename_override);
+		zend_long previous_lineno = EG(lineno_override);
+		EG(filename_override) = NULL;
+		EG(lineno_override) = -1;
+		zend_exception_save();
+		/* Call the autoloader - it will include the file defining the shape */
+		zend_autoload(autoload_name, lookup_name);
+		zend_exception_restore();
+		EG(filename_override) = previous_filename;
+		EG(lineno_override) = previous_lineno;
+
+		zend_string_release_ex(autoload_name, 0);
+	}
+
+	zend_hash_del(EG(in_autoload), lookup_name);
+
+	/* Check if the shape was defined by the autoloaded file */
+	zv = zend_hash_find(EG(shape_table), lookup_name);
+	if (zv) {
+		shape = (zend_shape_entry*)Z_PTR_P(zv);
+	}
+
+done:
+	if (free_lookup_name) {
+		zend_string_release_ex(lookup_name, 0);
+	}
+
+	return shape;
+}
+/* }}} */
+
+ZEND_API zend_shape_entry *zend_lookup_shape(zend_string *name) /* {{{ */
+{
+	return zend_lookup_shape_ex(name, NULL, 0);
+}
+/* }}} */
+
 ZEND_API zend_class_entry *zend_get_called_scope(zend_execute_data *ex) /* {{{ */
 {
 	while (ex) {
diff --git a/Zend/zend_globals.h b/Zend/zend_globals.h
index 48b978b5..6129bc76 100644
--- a/Zend/zend_globals.h
+++ b/Zend/zend_globals.h
@@ -94,6 +94,7 @@ struct _zend_compiler_globals {
 
 	HashTable *function_table;	/* function symbol table */
 	HashTable *class_table;		/* class table */
+	HashTable *shape_table;		/* shape type aliases */
 
 	HashTable *auto_globals;
 
@@ -191,6 +192,7 @@ struct _zend_executor_globals {
 	HashTable *function_table;	/* function symbol table */
 	HashTable *class_table;		/* class table */
 	HashTable *zend_constants;	/* constants table */
+	HashTable *shape_table;		/* shape type aliases */
 
 	zval          *vm_stack_top;
 	zval          *vm_stack_end;
@@ -367,6 +369,7 @@ struct _zend_php_scanner_globals {
 	zend_stack state_stack;
 	zend_ptr_stack heredoc_label_stack;
 	zend_stack nest_location_stack; /* for syntax error reporting */
+	uint32_t type_angle_depth; /* for splitting >> in array<array<T>> */
 	bool heredoc_scan_ahead;
 	int heredoc_indentation;
 	bool heredoc_indentation_uses_spaces;
diff --git a/Zend/zend_hash.c b/Zend/zend_hash.c
index 6978beaa..b46bfbca 100644
--- a/Zend/zend_hash.c
+++ b/Zend/zend_hash.c
@@ -829,6 +829,8 @@ static zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_s
 
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 	zend_string_hash_val(key);
 
 	if (UNEXPECTED(HT_FLAGS(ht) & (HASH_FLAG_UNINITIALIZED|HASH_FLAG_PACKED))) {
@@ -910,6 +912,8 @@ static zend_always_inline zval *_zend_hash_str_add_or_update_i(HashTable *ht, co
 
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 
 	if (UNEXPECTED(HT_FLAGS(ht) & (HASH_FLAG_UNINITIALIZED|HASH_FLAG_PACKED))) {
 		if (EXPECTED(HT_FLAGS(ht) & HASH_FLAG_UNINITIALIZED)) {
@@ -1095,6 +1099,8 @@ static zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht,
 
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 
 	if ((flag & HASH_ADD_NEXT) && h == ZEND_LONG_MIN) {
 		h = 0;
@@ -1451,6 +1457,8 @@ static zend_always_inline void zend_hash_iterators_clamp_max(const HashTable *ht
 
 static zend_always_inline void _zend_hash_packed_del_val(HashTable *ht, uint32_t idx, zval *zv)
 {
+	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 	idx = HT_HASH_TO_IDX(idx);
 	ht->nNumOfElements--;
 	if (ht->nNumUsed - 1 == idx) {
@@ -1472,6 +1480,8 @@ static zend_always_inline void _zend_hash_packed_del_val(HashTable *ht, uint32_t
 
 static zend_always_inline void _zend_hash_del_el_ex(HashTable *ht, uint32_t idx, Bucket *p, Bucket *prev)
 {
+	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 	if (prev) {
 		Z_NEXT(prev->val) = Z_NEXT(p->val);
 	} else {
@@ -1876,6 +1886,8 @@ ZEND_API void ZEND_FASTCALL zend_hash_clean(HashTable *ht)
 {
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 
 	if (ht->nNumUsed) {
 		if (HT_IS_PACKED(ht)) {
diff --git a/Zend/zend_hash.h b/Zend/zend_hash.h
index 57020bbc..b2bf43f1 100644
--- a/Zend/zend_hash.h
+++ b/Zend/zend_hash.h
@@ -46,6 +46,7 @@ typedef enum {
 #define HASH_FLAG_STATIC_KEYS      (1<<4) /* long and interned strings */
 #define HASH_FLAG_HAS_EMPTY_IND    (1<<5)
 #define HASH_FLAG_ALLOW_COW_VIOLATION (1<<6)
+#define HASH_FLAG_ELEM_TYPE_VALID  (1<<7) /* Element type validation cache is valid */
 
 /* Only the low byte are real flags */
 #define HASH_FLAG_MASK 0xff
@@ -85,6 +86,63 @@ typedef enum {
 #define HT_DEC_ITERATORS_COUNT(ht) \
 	HT_SET_ITERATORS_COUNT(ht, HT_ITERATORS_COUNT(ht) - 1)
 
+/*
+ * Typed Array Validation Cache
+ * ============================
+ *
+ * These macros provide caching infrastructure for array<T> and array<K,V>
+ * type validation, significantly reducing runtime overhead for repeated
+ * validations of the same array.
+ *
+ * Cache Structure:
+ * - nValidatedElemType (uint8_t): Stores the last validated element type code
+ *   (IS_LONG, IS_STRING, IS_DOUBLE, etc.) for simple types
+ * - nValidatedKeyType (uint8_t): Stores the validated key type mask
+ *   (MAY_BE_LONG, MAY_BE_STRING, or MAY_BE_LONG|MAY_BE_STRING)
+ * - HASH_FLAG_ELEM_TYPE_VALID (bit 7 of flags): Indicates if element cache is valid
+ *
+ * Cache Invalidation:
+ * The caches are automatically invalidated when the array is mutated:
+ * - Adding elements: zend_hash_add, zend_hash_update, zend_hash_index_add, etc.
+ * - Removing elements: zend_hash_del, zend_hash_index_del, etc.
+ * - Clearing array: zend_hash_clean
+ *
+ * This ensures correctness: after mutation, the next validation will
+ * re-check all elements and update the cache accordingly.
+ *
+ * Performance Notes:
+ * - Cache hit: O(1) - just check the cached type code
+ * - Cache miss: O(n) - validate all elements and update cache
+ * - Empty arrays: O(1) - always valid, no caching needed
+ * - Packed arrays with int keys: Immediate cache hit for MAY_BE_LONG key type
+ *
+ * Limitations:
+ * - Element type cache only works for simple types (not union types)
+ * - Object types with class names are not cached (class may be reloaded)
+ * - Cache is per-array, not per-type (same array, different type = miss)
+ */
+
+/* Element type validation cache for array<T> optimization */
+#define HT_VALIDATED_ELEM_TYPE(ht) (ht)->u.v.nValidatedElemType
+#define HT_ELEM_TYPE_IS_VALID(ht) ((HT_FLAGS(ht) & HASH_FLAG_ELEM_TYPE_VALID) != 0)
+#define HT_INVALIDATE_ELEM_TYPE(ht) \
+	do { HT_FLAGS(ht) &= ~HASH_FLAG_ELEM_TYPE_VALID; } while (0)
+#define HT_SET_VALIDATED_ELEM_TYPE(ht, type) do { \
+		(ht)->u.v.nValidatedElemType = (type); \
+		HT_FLAGS(ht) |= HASH_FLAG_ELEM_TYPE_VALID; \
+	} while (0)
+
+/* Key type validation cache for array<K,V> optimization
+ * Stores the validated key type mask (MAY_BE_LONG, MAY_BE_STRING, or both)
+ * Value 0 means not validated, non-zero means validated for that key mask */
+#define HT_VALIDATED_KEY_TYPE(ht) (ht)->u.v.nValidatedKeyType
+#define HT_KEY_TYPE_IS_VALID(ht) ((ht)->u.v.nValidatedKeyType != 0)
+#define HT_INVALIDATE_KEY_TYPE(ht) \
+	do { (ht)->u.v.nValidatedKeyType = 0; } while (0)
+#define HT_SET_VALIDATED_KEY_TYPE(ht, mask) do { \
+		(ht)->u.v.nValidatedKeyType = (uint8_t)(mask); \
+	} while (0)
+
 extern ZEND_API const HashTable zend_empty_array;
 
 #define ZVAL_EMPTY_ARRAY(z) do {						\
diff --git a/Zend/zend_language_parser.y b/Zend/zend_language_parser.y
index e4d61006..161f4d10 100644
--- a/Zend/zend_language_parser.y
+++ b/Zend/zend_language_parser.y
@@ -87,6 +87,7 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %precedence T_ELSEIF
 %precedence T_ELSE
 
+
 %token <ast> T_LNUMBER   "integer"
 %token <ast> T_DNUMBER   "floating-point number"
 %token <ast> T_STRING    "identifier"
@@ -168,11 +169,13 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %token <ident> T_TRAIT         "'trait'"
 %token <ident> T_INTERFACE     "'interface'"
 %token <ident> T_ENUM          "'enum'"
+%token <ident> T_SHAPE         "'shape'"
 %token <ident> T_EXTENDS       "'extends'"
 %token <ident> T_IMPLEMENTS    "'implements'"
 %token <ident> T_NAMESPACE     "'namespace'"
 %token <ident> T_LIST            "'list'"
 %token <ident> T_ARRAY           "'array'"
+%token T_ARRAY_SHAPE_START       "'array{'"
 %token <ident> T_CALLABLE        "'callable'"
 %token <ident> T_LINE            "'__LINE__'"
 %token <ident> T_FILE            "'__FILE__'"
@@ -280,11 +283,13 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %type <ast> array_pair non_empty_array_pair_list array_pair_list possible_array_pair
 %type <ast> isset_variable type return_type type_expr type_without_static
 %type <ast> identifier type_expr_without_static union_type_without_static_element union_type_without_static intersection_type_without_static
+%type <ast> shape_element_list shape_element
 %type <ast> inline_function union_type_element union_type intersection_type
 %type <ast> attributed_statement attributed_top_statement attributed_class_statement attributed_parameter
 %type <ast> attribute_decl attribute attributes attribute_group namespace_declaration_name
 %type <ast> match match_arm_list non_empty_match_arm_list match_arm match_arm_cond_list
 %type <ast> enum_declaration_statement enum_backing_type enum_case enum_case_expr
+%type <ast> shape_declaration_statement shape_extends_from
 %type <ast> function_name non_empty_member_modifiers
 %type <ast> property_hook property_hook_list optional_property_hook_list hooked_property property_hook_body
 %type <ast> optional_parameter_list clone_argument_list non_empty_clone_argument_list
@@ -312,7 +317,7 @@ reserved_non_modifiers:
 	| T_FUNCTION | T_CONST | T_RETURN | T_PRINT | T_YIELD | T_LIST | T_SWITCH | T_ENDSWITCH | T_CASE | T_DEFAULT | T_BREAK
 	| T_ARRAY | T_CALLABLE | T_EXTENDS | T_IMPLEMENTS | T_NAMESPACE | T_TRAIT | T_INTERFACE | T_CLASS
 	| T_CLASS_C | T_TRAIT_C | T_FUNC_C | T_METHOD_C | T_LINE | T_FILE | T_DIR | T_NS_C | T_FN | T_MATCH | T_ENUM
-	| T_PROPERTY_C
+	| T_PROPERTY_C | T_SHAPE
 ;
 
 semi_reserved:
@@ -393,6 +398,7 @@ attributed_statement:
 	|	trait_declaration_statement			{ $$ = $1; }
 	|	interface_declaration_statement		{ $$ = $1; }
 	|	enum_declaration_statement			{ $$ = $1; }
+	|	shape_declaration_statement			{ $$ = $1; }
 ;
 
 attributed_top_statement:
@@ -667,6 +673,16 @@ enum_case_expr:
 	|	'=' expr { $$ = $2; }
 ;
 
+shape_extends_from:
+		%empty				{ $$ = NULL; }
+	|	T_EXTENDS name		{ $$ = $2; }
+;
+
+shape_declaration_statement:
+		T_SHAPE T_STRING shape_extends_from '=' type_expr ';'
+			{ $$ = zend_ast_create(ZEND_AST_SHAPE_DECL, $2, $3, $5); }
+;
+
 extends_from:
 		%empty				{ $$ = NULL; }
 	|	T_EXTENDS class_name	{ $$ = $2; }
@@ -874,6 +890,32 @@ type_without_static:
 		T_ARRAY		{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_ARRAY); }
 	|	T_CALLABLE	{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_CALLABLE); }
 	|	name		{ $$ = $1; }
+	|	T_ARRAY '<' type_expr '>'
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_OF, $3); }
+	|	T_ARRAY '<' type_expr ',' type_expr '>'
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_MAP, $3, $5); }
+	|	T_ARRAY_SHAPE_START shape_element_list '}'
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 0, $2); }
+	|	T_ARRAY_SHAPE_START '}'
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 0, NULL); }
+	|	T_ARRAY_SHAPE_START shape_element_list '}' '!'
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 1, $2); }
+	|	T_ARRAY_SHAPE_START '}' '!'
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 1, NULL); }
+;
+
+shape_element_list:
+		shape_element
+			{ $$ = zend_ast_create_list(1, ZEND_AST_SHAPE_ELEMENT_LIST, $1); }
+	|	shape_element_list ',' shape_element
+			{ $$ = zend_ast_list_add($1, $3); }
+;
+
+shape_element:
+		T_STRING ':' type_expr
+			{ $$ = zend_ast_create_ex(ZEND_AST_SHAPE_ELEMENT, 0, $1, $3); }
+	|	T_STRING '?' ':' type_expr
+			{ $$ = zend_ast_create_ex(ZEND_AST_SHAPE_ELEMENT, 1, $1, $4); }
 ;
 
 union_type_without_static_element:
diff --git a/Zend/zend_language_scanner.l b/Zend/zend_language_scanner.l
index 3ecb2f8d..028f0633 100644
--- a/Zend/zend_language_scanner.l
+++ b/Zend/zend_language_scanner.l
@@ -194,6 +194,7 @@ void startup_scanner(void)
 	zend_stack_init(&SCNG(nest_location_stack), sizeof(zend_nest_location));
 	zend_ptr_stack_init(&SCNG(heredoc_label_stack));
 	SCNG(heredoc_scan_ahead) = 0;
+	SCNG(type_angle_depth) = 0;
 }
 
 static void heredoc_label_dtor(zend_heredoc_label *heredoc_label) {
@@ -1575,6 +1576,11 @@ OPTIONAL_WHITESPACE_OR_COMMENTS ({WHITESPACE}|{MULTI_LINE_COMMENT}|{SINGLE_LINE_
 	RETURN_TOKEN_WITH_IDENT(T_ENUM);
 }
 
+<ST_IN_SCRIPTING>"shape"{WHITESPACE_OR_COMMENTS}[a-zA-Z_\x80-\xff] {
+	yyless(5);
+	RETURN_TOKEN_WITH_IDENT(T_SHAPE);
+}
+
 <ST_IN_SCRIPTING>"extends" {
 	RETURN_TOKEN_WITH_IDENT(T_EXTENDS);
 }
@@ -1814,6 +1820,19 @@ OPTIONAL_WHITESPACE_OR_COMMENTS ({WHITESPACE}|{MULTI_LINE_COMMENT}|{SINGLE_LINE_
 	RETURN_TOKEN_WITH_IDENT(T_LIST);
 }
 
+<ST_IN_SCRIPTING>"array{" {
+	/* Return T_ARRAY_SHAPE_START for array shape syntax (no whitespace between array and {)
+	 * We must call enter_nesting since we consumed the { character */
+	enter_nesting('{');
+	RETURN_TOKEN(T_ARRAY_SHAPE_START);
+}
+
+<ST_IN_SCRIPTING>"array<" {
+	SCNG(type_angle_depth)++;
+	yyless(5); /* push back the '<' */
+	RETURN_TOKEN_WITH_IDENT(T_ARRAY);
+}
+
 <ST_IN_SCRIPTING>"array" {
 	RETURN_TOKEN_WITH_IDENT(T_ARRAY);
 }
@@ -1943,9 +1962,21 @@ OPTIONAL_WHITESPACE_OR_COMMENTS ({WHITESPACE}|{MULTI_LINE_COMMENT}|{SINGLE_LINE_
 }
 
 <ST_IN_SCRIPTING>">>" {
+	if (SCNG(type_angle_depth) > 0) {
+		SCNG(type_angle_depth)--;
+		yyless(1);
+		RETURN_TOKEN('>');
+	}
 	RETURN_TOKEN(T_SR);
 }
 
+<ST_IN_SCRIPTING>">" {
+	if (SCNG(type_angle_depth) > 0) {
+		SCNG(type_angle_depth)--;
+	}
+	RETURN_TOKEN('>');
+}
+
 <ST_IN_SCRIPTING>"&"{OPTIONAL_WHITESPACE_OR_COMMENTS}("$"|"...") {
 	yyless(1);
 	RETURN_TOKEN(T_AMPERSAND_FOLLOWED_BY_VAR_OR_VARARG);
diff --git a/Zend/zend_object_handlers.c b/Zend/zend_object_handlers.c
index 67257913..6a5873d5 100644
--- a/Zend/zend_object_handlers.c
+++ b/Zend/zend_object_handlers.c
@@ -33,6 +33,7 @@
 #include "zend_hash.h"
 #include "zend_property_hooks.h"
 #include "zend_observer.h"
+#include "zend_execute.h"
 
 #define DEBUG_OBJECT_HANDLERS 0
 
@@ -1002,6 +1003,11 @@ static zend_always_inline bool property_uses_strict_types(void) {
 		&& ZEND_CALL_USES_STRICT_TYPES(EG(current_execute_data));
 }
 
+/* Typed array checking is always enabled */
+static zend_always_inline bool property_uses_strict_arrays(void) {
+	return true;
+}
+
 static zval *forward_write_to_lazy_object(zend_object *zobj,
 		zend_string *name, zval *value, void **cache_slot, bool guarded)
 {
@@ -1098,6 +1104,24 @@ ZEND_API zval *zend_std_write_property(zend_object *zobj, zend_string *name, zva
 					variable_ptr = &EG(error_zval);
 					goto exit;
 				}
+				/* Check array element types for typed arrays and array shapes */
+				if (Z_TYPE(tmp) == IS_ARRAY) {
+					if (ZEND_TYPE_HAS_ARRAY_ELEMENT(prop_info->type)) {
+						zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(prop_info->type);
+						if (UNEXPECTED(!zend_verify_array_prop_element_types(prop_info, &tmp, elem_type))) {
+							zval_ptr_dtor(&tmp);
+							variable_ptr = &EG(error_zval);
+							goto exit;
+						}
+					} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(prop_info->type)) {
+						zend_array_shape *shape = ZEND_ARRAY_SHAPE(prop_info->type);
+						if (UNEXPECTED(!zend_verify_array_prop_shape(prop_info, &tmp, shape))) {
+							zval_ptr_dtor(&tmp);
+							variable_ptr = &EG(error_zval);
+							goto exit;
+						}
+					}
+				}
 				Z_PROP_FLAG_P(variable_ptr) &= ~(IS_PROP_UNINIT|IS_PROP_REINITABLE);
 				value = &tmp;
 			}
diff --git a/Zend/zend_opcode.c b/Zend/zend_opcode.c
index f3631104..036da43e 100644
--- a/Zend/zend_opcode.c
+++ b/Zend/zend_opcode.c
@@ -121,6 +121,12 @@ ZEND_API void zend_type_release(zend_type type, bool persistent) {
 	} else if (ZEND_TYPE_HAS_NAME(type)) {
 		zend_string_release(ZEND_TYPE_NAME(type));
 	}
+	/* Note: Array shapes and typed arrays are NOT freed here.
+	 * They are either:
+	 * 1. Arena-allocated (inline shapes like array{x: int}) - freed by arena cleanup
+	 * 2. Shape-table-owned (named shapes like MyShape) - freed by zend_shape_dtor
+	 * Freeing here would cause double-free since function arg_info shares
+	 * the same pointer as shape table entries for named shapes. */
 }
 
 void zend_free_internal_arg_info(zend_internal_function *function) {
diff --git a/Zend/zend_types.h b/Zend/zend_types.h
index a3d3e4da..2ab2c7eb 100644
--- a/Zend/zend_types.h
+++ b/Zend/zend_types.h
@@ -157,7 +157,19 @@ typedef struct {
 #define _ZEND_TYPE_INTERSECTION_BIT (1u << 19)
 /* Whether the type is a union type */
 #define _ZEND_TYPE_UNION_BIT (1u << 18)
-/* Type mask excluding the flags above. */
+
+/* Array shape type bits use high bits (29-30) to avoid conflict with other type flags.
+ * Bit allocation in type_mask:
+ *   Bits 0-17:  MAY_BE_* type bits (IS_UNDEF through IS_NEVER)
+ *   Bits 18-24: Type modifiers (union, intersection, arena, iterable, kind)
+ *   Bits 25-28: Reserved
+ *   Bit 29:     Shape name reference (runtime-resolved shape alias)
+ *   Bit 30:     Array shape (inline array{key: type} definition)
+ *   Bit 31:     Unused (sign bit)
+ */
+#define _ZEND_TYPE_ARRAY_SHAPE_BIT (1u << 30)
+#define _ZEND_TYPE_SHAPE_NAME_BIT (1u << 29)
+/* Type mask for MAY_BE_* type bits only (bits 0-17, including IS_NEVER) */
 #define _ZEND_TYPE_MAY_BE_MASK ((1u << 18) - 1)
 /* Must have same value as MAY_BE_NULL */
 #define _ZEND_TYPE_NULLABLE_BIT 0x2u
@@ -191,6 +203,15 @@ typedef struct {
 #define ZEND_TYPE_USES_ARENA(t) \
 	((((t).type_mask) & _ZEND_TYPE_ARENA_BIT) != 0)
 
+#define ZEND_TYPE_HAS_ARRAY_ELEMENT(t) \
+	((((t).type_mask) & (1u << IS_ARRAY)) != 0 && (t).ptr != NULL && !ZEND_TYPE_IS_COMPLEX(t) && !((t).type_mask & _ZEND_TYPE_ARRAY_SHAPE_BIT))
+
+#define ZEND_TYPE_HAS_SHAPE_NAME(t) \
+	((((t).type_mask) & _ZEND_TYPE_SHAPE_NAME_BIT) != 0)
+
+#define ZEND_TYPE_SHAPE_NAME(t) \
+	((zend_string *) (t).ptr)
+
 #define ZEND_TYPE_IS_ONLY_MASK(t) \
 	(ZEND_TYPE_IS_SET(t) && (t).ptr == NULL)
 
@@ -411,9 +432,9 @@ struct _zend_array {
 		struct {
 			ZEND_ENDIAN_LOHI_4(
 				uint8_t    flags,
-				uint8_t    _unused,
+				uint8_t    nValidatedElemType,  /* Cached validated element type for array<T> */
 				uint8_t    nIteratorsCount,
-				uint8_t    _unused2)
+				uint8_t    nValidatedKeyType)   /* Cached validated key type for array<K,V> */
 		} v;
 		uint32_t flags;
 	} u;
diff --git a/Zend/zend_vm_def.h b/Zend/zend_vm_def.h
index 90247b3c..0982bd4c 100644
--- a/Zend/zend_vm_def.h
+++ b/Zend/zend_vm_def.h
@@ -4453,6 +4453,24 @@ ZEND_VM_COLD_CONST_HANDLER(124, ZEND_VERIFY_RETURN_TYPE, CONST|TMP|VAR|UNUSED|CV
 		}
 
 		if (EXPECTED(ZEND_TYPE_CONTAINS_CODE(ret_info->type, Z_TYPE_P(retval_ptr)))) {
+			/* Check array element types if strict_arrays is enabled and we have array<T> type info */
+			if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(retval_ptr) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(ret_info->type)) {
+				SAVE_OPLINE();
+				zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(ret_info->type);
+				if (!zend_verify_array_element_types(EX(func), retval_ptr, elem_type)) {
+					FREE_OP1();
+					HANDLE_EXCEPTION();
+				}
+			}
+			/* Check array shape if strict_arrays is enabled and we have array{...} type info */
+			if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(retval_ptr) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_SHAPE(ret_info->type)) {
+				SAVE_OPLINE();
+				zend_array_shape *shape = ZEND_ARRAY_SHAPE(ret_info->type);
+				if (!zend_verify_array_shape(EX(func), retval_ptr, shape)) {
+					FREE_OP1();
+					HANDLE_EXCEPTION();
+				}
+			}
 			ZEND_VM_NEXT_OPCODE();
 		}
 
@@ -5681,6 +5699,23 @@ ZEND_VM_HELPER(zend_verify_recv_arg_type_helper, ANY, ANY, zval *op_1)
 		HANDLE_EXCEPTION();
 	}
 
+	/* Check array element types if strict_arrays is enabled */
+	if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(op_1) == IS_ARRAY) {
+		const zend_arg_info *arg_info = &EX(func)->common.arg_info[opline->op1.num - 1];
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+			zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+			if (!zend_verify_array_arg_element_types(EX(func), opline->op1.num, op_1, elem_type)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+		if (ZEND_TYPE_HAS_ARRAY_SHAPE(arg_info->type)) {
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(arg_info->type);
+			if (!zend_verify_array_arg_shape(opline->op1.num, op_1, shape)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+	}
+
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -5700,6 +5735,25 @@ ZEND_VM_HOT_HANDLER(63, ZEND_RECV, NUM, UNUSED)
 		ZEND_VM_DISPATCH_TO_HELPER(zend_verify_recv_arg_type_helper, op_1, param);
 	}
 
+	/* Check array element types if strict_arrays is enabled */
+	if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY) {
+		const zend_arg_info *arg_info = &EX(func)->common.arg_info[arg_num - 1];
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+			SAVE_OPLINE();
+			zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+			if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+		if (ZEND_TYPE_HAS_ARRAY_SHAPE(arg_info->type)) {
+			SAVE_OPLINE();
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(arg_info->type);
+			if (!zend_verify_array_arg_shape(arg_num, param, shape)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+	}
+
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -5758,6 +5812,16 @@ ZEND_VM_C_LABEL(recv_init_check_type):
 			if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), arg_num, param))) {
 				HANDLE_EXCEPTION();
 			}
+			/* Check array element types if strict_arrays is enabled */
+			if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY) {
+				const zend_arg_info *arg_info = &EX(func)->common.arg_info[arg_num - 1];
+				if (ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+					zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+					if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+						HANDLE_EXCEPTION();
+					}
+				}
+			}
 		}
 	}
 
@@ -5792,6 +5856,14 @@ ZEND_VM_HANDLER(164, ZEND_RECV_VARIADIC, NUM, UNUSED)
 						ZEND_HASH_FILL_FINISH();
 						HANDLE_EXCEPTION();
 					}
+					/* Check array element types if strict_arrays is enabled */
+					if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+						zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+						if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+							ZEND_HASH_FILL_FINISH();
+							HANDLE_EXCEPTION();
+						}
+					}
 
 					if (Z_OPT_REFCOUNTED_P(param)) Z_ADDREF_P(param);
 					ZEND_HASH_FILL_ADD(param);
@@ -5819,6 +5891,13 @@ ZEND_VM_HANDLER(164, ZEND_RECV_VARIADIC, NUM, UNUSED)
 				if (UNEXPECTED(!zend_verify_variadic_arg_type(EX(func), arg_info, arg_num, param))) {
 					HANDLE_EXCEPTION();
 				}
+				/* Check array element types if strict_arrays is enabled */
+				if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+					zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+					if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+						HANDLE_EXCEPTION();
+					}
+				}
 				Z_TRY_ADDREF_P(param);
 				zend_hash_add_new(Z_ARRVAL_P(params), name, param);
 			} ZEND_HASH_FOREACH_END();
diff --git a/Zend/zend_vm_execute.h b/Zend/zend_vm_execute.h
index 810c2c7e..8e4f5427 100644
Binary files a/Zend/zend_vm_execute.h and b/Zend/zend_vm_execute.h differ
diff --git a/benchmarks/param_shape_compare.php b/benchmarks/param_shape_compare.php
new file mode 100644
index 00000000..29eee1e7
--- /dev/null
+++ b/benchmarks/param_shape_compare.php
@@ -0,0 +1,220 @@
+<?php
+/**
+ * Benchmark: Array Shape Parameter Type Overhead - Side by Side Comparison
+ *
+ * This script runs both plain array and shaped array benchmarks and compares results.
+ */
+
+$iterations = 1_000_000;
+
+echo "╔══════════════════════════════════════════════════════════════════════╗\n";
+echo "║     Array Shape Parameter Overhead Benchmark                         ║\n";
+echo "║     Iterations: " . str_pad(number_format($iterations), 52) . "║\n";
+echo "╚══════════════════════════════════════════════════════════════════════╝\n\n";
+
+// Test data
+$point = ['x' => 10, 'y' => 20];
+$user = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com', 'active' => true];
+$config = [
+    'host' => 'localhost',
+    'port' => 3306,
+    'database' => 'myapp',
+    'username' => 'root',
+    'password' => 'secret'
+];
+$nested = [
+    'user' => ['id' => 1, 'name' => 'Alice'],
+    'settings' => ['theme' => 'dark', 'lang' => 'en']
+];
+
+// Results storage
+$results = [];
+
+// ============================================================================
+// PLAIN ARRAY FUNCTIONS (no validation)
+// ============================================================================
+
+function plainPoint(array $p): int {
+    return $p['x'] + $p['y'];
+}
+
+function plainUser(array $u): string {
+    return $u['name'];
+}
+
+function plainConfig(array $c): string {
+    return $c['host'];
+}
+
+function plainNested(array $n): string {
+    return $n['user']['name'];
+}
+
+// ============================================================================
+// RUN PLAIN BENCHMARKS
+// ============================================================================
+
+echo "Running plain array benchmarks (no strict_arrays)...\n";
+
+// Warm up
+for ($i = 0; $i < 10000; $i++) {
+    plainPoint($point);
+    plainUser($user);
+    plainConfig($config);
+    plainNested($nested);
+}
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    plainPoint($point);
+}
+$results['point']['plain'] = (hrtime(true) - $start) / 1_000_000;
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    plainUser($user);
+}
+$results['user']['plain'] = (hrtime(true) - $start) / 1_000_000;
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    plainConfig($config);
+}
+$results['config']['plain'] = (hrtime(true) - $start) / 1_000_000;
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    plainNested($nested);
+}
+$results['nested']['plain'] = (hrtime(true) - $start) / 1_000_000;
+
+echo "Done.\n\n";
+
+// ============================================================================
+// NOW INCLUDE STRICT ARRAYS FILE
+// ============================================================================
+
+echo "Running shaped array benchmarks (with strict_arrays=1)...\n";
+
+// We need to use a separate file for strict_arrays since declare is file-scoped
+$shapeCode = <<<'PHP'
+<?php
+declare(strict_arrays=1);
+
+$iterations = $argv[1];
+$testCase = $argv[2];
+
+$point = ['x' => 10, 'y' => 20];
+$user = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com', 'active' => true];
+$config = [
+    'host' => 'localhost',
+    'port' => 3306,
+    'database' => 'myapp',
+    'username' => 'root',
+    'password' => 'secret'
+];
+$nested = [
+    'user' => ['id' => 1, 'name' => 'Alice'],
+    'settings' => ['theme' => 'dark', 'lang' => 'en']
+];
+
+function shapedPoint(array{x: int, y: int} $p): int {
+    return $p['x'] + $p['y'];
+}
+
+function shapedUser(array{id: int, name: string, email: string, active: bool} $u): string {
+    return $u['name'];
+}
+
+function shapedConfig(array{host: string, port: int, database: string, username: string, password: string} $c): string {
+    return $c['host'];
+}
+
+function shapedNested(array{user: array{id: int, name: string}, settings: array{theme: string, lang: string}} $n): string {
+    return $n['user']['name'];
+}
+
+// Warm up
+for ($i = 0; $i < 10000; $i++) {
+    shapedPoint($point);
+    shapedUser($user);
+    shapedConfig($config);
+    shapedNested($nested);
+}
+
+$data = match($testCase) {
+    'point' => $point,
+    'user' => $user,
+    'config' => $config,
+    'nested' => $nested,
+};
+
+$func = match($testCase) {
+    'point' => 'shapedPoint',
+    'user' => 'shapedUser',
+    'config' => 'shapedConfig',
+    'nested' => 'shapedNested',
+};
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    $func($data);
+}
+$time = (hrtime(true) - $start) / 1_000_000;
+
+echo $time;
+PHP;
+
+$tmpFile = sys_get_temp_dir() . '/shape_bench_' . getmypid() . '.php';
+file_put_contents($tmpFile, $shapeCode);
+
+$phpBinary = PHP_BINARY;
+
+foreach (['point', 'user', 'config', 'nested'] as $case) {
+    $output = shell_exec("$phpBinary $tmpFile $iterations $case 2>&1");
+    $results[$case]['shaped'] = (float) trim($output);
+}
+
+unlink($tmpFile);
+
+echo "Done.\n\n";
+
+// ============================================================================
+// DISPLAY RESULTS
+// ============================================================================
+
+echo "╔══════════════════════════════════════════════════════════════════════╗\n";
+echo "║                            RESULTS                                   ║\n";
+echo "╠══════════════════════════════════════════════════════════════════════╣\n";
+echo "║ Test Case          │ Plain (ms) │ Shaped (ms) │ Overhead │ % Slower ║\n";
+echo "╠══════════════════════════════════════════════════════════════════════╣\n";
+
+$cases = [
+    'point' => 'Point (2 keys)',
+    'user' => 'User (4 keys)',
+    'config' => 'Config (5 keys)',
+    'nested' => 'Nested (2+2+2 keys)',
+];
+
+foreach ($cases as $key => $label) {
+    $plain = $results[$key]['plain'];
+    $shaped = $results[$key]['shaped'];
+    $overhead = $shaped - $plain;
+    $percent = (($shaped / $plain) - 1) * 100;
+
+    printf("║ %-18s │ %10.2f │ %11.2f │ %+8.2f │ %+7.1f%% ║\n",
+        $label, $plain, $shaped, $overhead, $percent);
+}
+
+echo "╚══════════════════════════════════════════════════════════════════════╝\n\n";
+
+// Per-call overhead
+echo "Per-call overhead (nanoseconds):\n";
+foreach ($cases as $key => $label) {
+    $plain = $results[$key]['plain'];
+    $shaped = $results[$key]['shaped'];
+    $overheadNs = (($shaped - $plain) / $iterations) * 1_000_000;
+    printf("  %-20s %+.1f ns/call\n", $label . ':', $overheadNs);
+}
+
+echo "\n";
diff --git a/benchmarks/param_shape_overhead.php b/benchmarks/param_shape_overhead.php
new file mode 100644
index 00000000..f114eb9c
--- /dev/null
+++ b/benchmarks/param_shape_overhead.php
@@ -0,0 +1,84 @@
+<?php
+/**
+ * Benchmark: Array Shape Parameter Type Overhead
+ *
+ * Compares performance of:
+ * 1. Regular array parameter (no validation)
+ * 2. Array shape parameter with strict_arrays=1
+ */
+
+// Number of iterations
+$iterations = 1_000_000;
+
+// Test data
+$point = ['x' => 10, 'y' => 20];
+$user = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com', 'active' => true];
+$config = [
+    'host' => 'localhost',
+    'port' => 3306,
+    'database' => 'myapp',
+    'username' => 'root',
+    'password' => 'secret'
+];
+
+// ============================================================================
+// FUNCTIONS WITHOUT STRICT ARRAYS (baseline)
+// ============================================================================
+
+function processPointPlain(array $point): int {
+    return $point['x'] + $point['y'];
+}
+
+function processUserPlain(array $user): string {
+    return $user['name'] . ' <' . $user['email'] . '>';
+}
+
+function processConfigPlain(array $config): string {
+    return $config['host'] . ':' . $config['port'];
+}
+
+// ============================================================================
+// BENCHMARKS
+// ============================================================================
+
+echo "=== Array Shape Parameter Overhead Benchmark ===\n";
+echo "Iterations: " . number_format($iterations) . "\n\n";
+
+// Warm up
+for ($i = 0; $i < 1000; $i++) {
+    processPointPlain($point);
+    processUserPlain($user);
+    processConfigPlain($config);
+}
+
+// Benchmark 1: Simple point (2 keys)
+echo "--- Simple Shape (2 keys: x, y) ---\n";
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    processPointPlain($point);
+}
+$plainTime = (hrtime(true) - $start) / 1_000_000;
+echo "Plain array:        " . number_format($plainTime, 2) . " ms\n";
+
+// Benchmark 2: User (4 keys)
+echo "\n--- Medium Shape (4 keys: id, name, email, active) ---\n";
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    processUserPlain($user);
+}
+$plainTime = (hrtime(true) - $start) / 1_000_000;
+echo "Plain array:        " . number_format($plainTime, 2) . " ms\n";
+
+// Benchmark 3: Config (5 keys)
+echo "\n--- Larger Shape (5 keys: host, port, database, username, password) ---\n";
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    processConfigPlain($config);
+}
+$plainTime = (hrtime(true) - $start) / 1_000_000;
+echo "Plain array:        " . number_format($plainTime, 2) . " ms\n";
+
+echo "\n=== Baseline complete. Now run with strict_arrays... ===\n";
diff --git a/benchmarks/param_shape_realistic.php b/benchmarks/param_shape_realistic.php
new file mode 100644
index 00000000..395d0dee
--- /dev/null
+++ b/benchmarks/param_shape_realistic.php
@@ -0,0 +1,168 @@
+<?php
+/**
+ * Realistic Benchmark: Array Shape Parameter Overhead
+ *
+ * This benchmark simulates more realistic function bodies to show
+ * the relative overhead in context of actual work.
+ */
+
+$iterations = 500_000;
+
+echo "╔══════════════════════════════════════════════════════════════════════╗\n";
+echo "║     Realistic Array Shape Parameter Overhead Benchmark               ║\n";
+echo "║     Iterations: " . str_pad(number_format($iterations), 52) . "║\n";
+echo "╚══════════════════════════════════════════════════════════════════════╝\n\n";
+
+// Test data
+$order = [
+    'id' => 'ORD-12345',
+    'customer' => 'Alice Smith',
+    'items' => [
+        ['sku' => 'WIDGET-A', 'qty' => 2, 'price' => 29.99],
+        ['sku' => 'GADGET-B', 'qty' => 1, 'price' => 49.99],
+        ['sku' => 'THING-C', 'qty' => 3, 'price' => 9.99],
+    ],
+    'discount' => 0.1,
+    'tax_rate' => 0.08,
+];
+
+// ============================================================================
+// PLAIN ARRAY VERSION
+// ============================================================================
+
+function calculateOrderTotalPlain(array $order): array {
+    $subtotal = 0;
+    foreach ($order['items'] as $item) {
+        $subtotal += $item['qty'] * $item['price'];
+    }
+
+    $discount = $subtotal * $order['discount'];
+    $afterDiscount = $subtotal - $discount;
+    $tax = $afterDiscount * $order['tax_rate'];
+    $total = $afterDiscount + $tax;
+
+    return [
+        'subtotal' => round($subtotal, 2),
+        'discount' => round($discount, 2),
+        'tax' => round($tax, 2),
+        'total' => round($total, 2),
+    ];
+}
+
+// ============================================================================
+// RUN PLAIN BENCHMARK
+// ============================================================================
+
+echo "Running plain array benchmark...\n";
+
+// Warm up
+for ($i = 0; $i < 10000; $i++) {
+    calculateOrderTotalPlain($order);
+}
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    calculateOrderTotalPlain($order);
+}
+$plainTime = (hrtime(true) - $start) / 1_000_000;
+
+echo "Done.\n\n";
+
+// ============================================================================
+// SHAPED VERSION (via external file)
+// ============================================================================
+
+echo "Running shaped array benchmark (strict_arrays=1)...\n";
+
+$shapeCode = <<<'PHP'
+<?php
+declare(strict_arrays=1);
+
+$iterations = $argv[1];
+
+$order = [
+    'id' => 'ORD-12345',
+    'customer' => 'Alice Smith',
+    'items' => [
+        ['sku' => 'WIDGET-A', 'qty' => 2, 'price' => 29.99],
+        ['sku' => 'GADGET-B', 'qty' => 1, 'price' => 49.99],
+        ['sku' => 'THING-C', 'qty' => 3, 'price' => 9.99],
+    ],
+    'discount' => 0.1,
+    'tax_rate' => 0.08,
+];
+
+function calculateOrderTotalShaped(array{
+    id: string,
+    customer: string,
+    items: array,
+    discount: float,
+    tax_rate: float
+} $order): array{subtotal: float, discount: float, tax: float, total: float} {
+    $subtotal = 0;
+    foreach ($order['items'] as $item) {
+        $subtotal += $item['qty'] * $item['price'];
+    }
+
+    $discount = $subtotal * $order['discount'];
+    $afterDiscount = $subtotal - $discount;
+    $tax = $afterDiscount * $order['tax_rate'];
+    $total = $afterDiscount + $tax;
+
+    return [
+        'subtotal' => round($subtotal, 2),
+        'discount' => round($discount, 2),
+        'tax' => round($tax, 2),
+        'total' => round($total, 2),
+    ];
+}
+
+// Warm up
+for ($i = 0; $i < 10000; $i++) {
+    calculateOrderTotalShaped($order);
+}
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    calculateOrderTotalShaped($order);
+}
+$time = (hrtime(true) - $start) / 1_000_000;
+
+echo $time;
+PHP;
+
+$tmpFile = sys_get_temp_dir() . '/shape_realistic_' . getmypid() . '.php';
+file_put_contents($tmpFile, $shapeCode);
+
+$shapedTime = (float) trim(shell_exec(PHP_BINARY . " $tmpFile $iterations 2>&1"));
+
+unlink($tmpFile);
+
+echo "Done.\n\n";
+
+// ============================================================================
+// RESULTS
+// ============================================================================
+
+$overhead = $shapedTime - $plainTime;
+$percent = (($shapedTime / $plainTime) - 1) * 100;
+$perCallNs = ($overhead / $iterations) * 1_000_000;
+
+echo "╔══════════════════════════════════════════════════════════════════════╗\n";
+echo "║                     REALISTIC BENCHMARK RESULTS                      ║\n";
+echo "╠══════════════════════════════════════════════════════════════════════╣\n";
+printf("║  Plain array (no validation):     %10.2f ms                     ║\n", $plainTime);
+printf("║  Array shapes (strict_arrays=1): %10.2f ms                     ║\n", $shapedTime);
+echo "╠══════════════════════════════════════════════════════════════════════╣\n";
+printf("║  Absolute overhead:               %+10.2f ms                     ║\n", $overhead);
+printf("║  Relative overhead:               %+10.1f%%                       ║\n", $percent);
+printf("║  Per-call overhead:               %+10.1f ns                      ║\n", $perCallNs);
+echo "╚══════════════════════════════════════════════════════════════════════╝\n\n";
+
+echo "Context: This function performs actual work (loops through items,\n";
+echo "calculates totals). The overhead is the cost of validating 5 shape\n";
+echo "keys on input + 4 shape keys on output.\n\n";
+
+// Verify results are correct
+$result = calculateOrderTotalPlain($order);
+echo "Verification - Order total: \$" . number_format($result['total'], 2) . "\n";
diff --git a/benchmarks/param_shape_strict.php b/benchmarks/param_shape_strict.php
new file mode 100644
index 00000000..305d0771
--- /dev/null
+++ b/benchmarks/param_shape_strict.php
@@ -0,0 +1,81 @@
+<?php
+/**
+ * Benchmark: Array Shape Parameter Type with strict_arrays=1
+ */
+declare(strict_arrays=1);
+
+// Number of iterations
+$iterations = 1_000_000;
+
+// Test data
+$point = ['x' => 10, 'y' => 20];
+$user = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com', 'active' => true];
+$config = [
+    'host' => 'localhost',
+    'port' => 3306,
+    'database' => 'myapp',
+    'username' => 'root',
+    'password' => 'secret'
+];
+
+// ============================================================================
+// FUNCTIONS WITH ARRAY SHAPES
+// ============================================================================
+
+function processPointShape(array{x: int, y: int} $point): int {
+    return $point['x'] + $point['y'];
+}
+
+function processUserShape(array{id: int, name: string, email: string, active: bool} $user): string {
+    return $user['name'] . ' <' . $user['email'] . '>';
+}
+
+function processConfigShape(array{host: string, port: int, database: string, username: string, password: string} $config): string {
+    return $config['host'] . ':' . $config['port'];
+}
+
+// ============================================================================
+// BENCHMARKS
+// ============================================================================
+
+echo "=== Array Shape Parameter with strict_arrays=1 ===\n";
+echo "Iterations: " . number_format($iterations) . "\n\n";
+
+// Warm up
+for ($i = 0; $i < 1000; $i++) {
+    processPointShape($point);
+    processUserShape($user);
+    processConfigShape($config);
+}
+
+// Benchmark 1: Simple point (2 keys)
+echo "--- Simple Shape (2 keys: x, y) ---\n";
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    processPointShape($point);
+}
+$shapeTime = (hrtime(true) - $start) / 1_000_000;
+echo "Array shape:        " . number_format($shapeTime, 2) . " ms\n";
+
+// Benchmark 2: User (4 keys)
+echo "\n--- Medium Shape (4 keys: id, name, email, active) ---\n";
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    processUserShape($user);
+}
+$shapeTime = (hrtime(true) - $start) / 1_000_000;
+echo "Array shape:        " . number_format($shapeTime, 2) . " ms\n";
+
+// Benchmark 3: Config (5 keys)
+echo "\n--- Larger Shape (5 keys: host, port, database, username, password) ---\n";
+
+$start = hrtime(true);
+for ($i = 0; $i < $iterations; $i++) {
+    processConfigShape($config);
+}
+$shapeTime = (hrtime(true) - $start) / 1_000_000;
+echo "Array shape:        " . number_format($shapeTime, 2) . " ms\n";
+
+echo "\n=== Strict arrays benchmark complete ===\n";
diff --git a/docs/RFC-array-shapes.md b/docs/RFC-array-shapes.md
new file mode 100644
index 00000000..cc5a5575
--- /dev/null
+++ b/docs/RFC-array-shapes.md
@@ -0,0 +1,718 @@
+# RFC: Typed Arrays & Array Shapes for PHP
+
+* Version: 1.3
+* Date: 2026-01-04
+* Author: PHP Array Shapes Implementation
+* Status: Implemented (Proof of Concept)
+* New in 1.3: Compile-time validation for shape/class cross-inheritance
+* New in 1.2: Shape inheritance (`extends`) and `::shape` syntax
+
+## Introduction
+
+This RFC proposes adding **Typed Arrays** and **Array Shapes** to PHP—two complementary
+features that bring type safety to PHP's most versatile data structure. These features
+address different use cases: typed arrays for **collections** and array shapes for
+**structured data**.
+
+## Motivation
+
+PHP arrays serve multiple purposes: lists, dictionaries, records, and complex nested
+structures. However, the type system only allows declaring a value as `array` without
+specifying what it contains:
+
+```php
+function getUsers(): array {
+    // What's in this array? Objects? Associative arrays? Integers?
+    // The type system can't tell you.
+}
+```
+
+This leads to:
+
+1. **Runtime errors** - Type mismatches discovered only during execution
+2. **Poor IDE support** - Limited autocomplete and refactoring capabilities
+3. **Documentation burden** - Developers must rely on PHPDoc annotations
+4. **Maintenance issues** - Changing array structures requires manual updates
+
+Static analysis tools like PHPStan and Psalm have introduced PHPDoc-based array
+shape syntax, demonstrating strong community demand for this feature.
+
+## Two Complementary Features
+
+### Typed Arrays — For Collections
+
+When you have a **list of things of the same type**, use typed arrays:
+
+```php
+// A list of integers
+function getIds(): array<int> {
+    return [1, 2, 3];
+}
+
+// A list of User objects
+function getActiveUsers(): array<User> {
+    return $this->repository->findActive();
+}
+```
+
+### Array Shapes — For Structured Data
+
+When you have **structured data with known keys**, like records from a database or
+responses from an API, use array shapes:
+
+```php
+// Data from a database row
+function getUser(int $id): array{id: int, name: string, email: string} {
+    return $this->db->fetch("SELECT id, name, email FROM users WHERE id = ?", $id);
+}
+
+// Response from an external API
+function getWeather(string $city): array{temp: float, humidity: int} {
+    return json_decode(file_get_contents("https://api.weather.com/$city"), true);
+}
+```
+
+### Why Not Just Use Classes/DTOs?
+
+A common question: "With constructor property promotion, classes are almost as concise.
+Why do we need array shapes?"
+
+#### Side-by-Side Comparison
+
+```php
+// With array shapes (this RFC)
+shape UserResponse = array{id: int, name: string, email: ?string};
+
+function getUser(): UserResponse {
+    return ['id' => 1, 'name' => 'Alice', 'email' => null];
+}
+
+// With classes + constructor property promotion
+readonly class UserResponse {
+    public function __construct(
+        public int $id,
+        public string $name,
+        public ?string $email,
+    ) {}
+}
+
+function getUser(): UserResponse {
+    return new UserResponse(id: 1, name: 'Alice', email: null);
+}
+```
+
+At first glance, these look similar. But there are fundamental differences:
+
+#### 1. JSON Serialization
+
+```php
+// Array shapes: direct serialization
+$user = getUser();  // Returns array
+echo json_encode($user);  // {"id":1,"name":"Alice","email":null}
+
+// Classes: requires extra work
+$user = getUser();  // Returns object
+echo json_encode($user);  // {} (empty without JsonSerializable!)
+
+// Must implement JsonSerializable or add toArray():
+readonly class UserResponse implements JsonSerializable {
+    public function __construct(
+        public int $id,
+        public string $name,
+        public ?string $email,
+    ) {}
+
+    public function jsonSerialize(): array {
+        return ['id' => $this->id, 'name' => $this->name, 'email' => $this->email];
+    }
+}
+```
+
+For API responses, you need `json_encode()` to just work. With array shapes, it does.
+With classes, you must implement `JsonSerializable` for **every single DTO**.
+
+#### 2. Working with Existing Data Sources
+
+```php
+// PDO returns arrays
+$row = $pdo->fetch(PDO::FETCH_ASSOC);  // array{id: int, name: string, ...}
+
+// json_decode returns arrays
+$data = json_decode($json, true);  // array{...}
+
+// config files return arrays
+$config = require 'config.php';  // array{...}
+
+// With array shapes: use directly
+function processUser(UserResponse $user): void { ... }
+processUser($row);  // Works!
+
+// With classes: must transform everything
+processUser(new UserResponse(...$row));  // Extra allocation + mapping
+```
+
+Array shapes work with the data you already have. Classes require transformation.
+
+#### 3. Array Functions and Operations
+
+```php
+// Array shapes: native array operations work
+$users = getUsers();  // array<UserResponse>
+$names = array_column($users, 'name');
+$filtered = array_filter($users, fn($u) => $u['id'] > 10);
+$mapped = array_map(fn($u) => $u['name'], $users);
+$merged = [...$user1, ...$user2];  // Spread operator
+['id' => $id, 'name' => $name] = $user;  // Destructuring
+
+// Classes: none of these work directly
+$users = getUsers();  // array<UserResponse>
+$names = array_map(fn($u) => $u->name, $users);  // Must use closures
+$filtered = array_filter($users, fn($u) => $u->id > 10);
+// No spread, no array_column, no destructuring
+```
+
+#### 4. No File/Class Boilerplate
+
+```php
+// Array shapes: define inline or in any file
+function getPoint(): array{x: int, y: int} {
+    return ['x' => 10, 'y' => 20];
+}
+
+// Or define once, use anywhere
+shape Point = array{x: int, y: int};
+
+// Classes: each needs its own file (PSR-4), own namespace, own declaration
+// src/DTO/Point.php
+namespace App\DTO;
+
+readonly class Point {
+    public function __construct(
+        public int $x,
+        public int $y,
+    ) {}
+}
+```
+
+For a complex API with 50+ response types, that's 50+ class files vs one `shapes.php`.
+
+#### 5. Memory and Performance
+
+```php
+// Array: ~400 bytes for small associative array
+$user = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+
+// Object: ~600+ bytes (object overhead, property table, class entry reference)
+$user = new UserResponse(1, 'Alice', 'alice@example.com');
+```
+
+When processing thousands of records, this adds up. Arrays are PHP's most optimized
+data structure.
+
+#### 6. Framework Expectations
+
+Many frameworks expect arrays:
+
+```php
+// Laravel
+return response()->json($data);  // Expects array
+Model::create($attributes);       // Expects array
+DB::table('users')->insert($data); // Expects array
+
+// Symfony
+return $this->json($data);        // Expects array
+$serializer->serialize($data);    // Handles arrays natively
+```
+
+#### When to Use Classes Instead
+
+Classes are the right choice when you need:
+
+- **Behavior** (methods that operate on the data)
+- **Encapsulation** (private properties, validation in constructor)
+- **Identity** (instanceof checks, type hierarchies)
+- **Mutability control** (readonly properties with controlled modification)
+
+Array shapes are the right choice when you have:
+
+- **Pure data** (no behavior needed)
+- **External data sources** (APIs, databases, config files)
+- **Serialization needs** (JSON responses)
+- **Existing array-based code** (gradual typing of legacy code)
+
+#### Summary
+
+| Feature | Array Shapes | Classes (CPP) |
+|---------|--------------|---------------|
+| JSON serialization | Direct | Requires JsonSerializable |
+| PDO/json_decode | Direct | Requires transformation |
+| array_map/filter | Native | Requires closures |
+| Spread operator | Yes | No |
+| Destructuring | Yes | No |
+| Memory overhead | Minimal | Higher |
+| File per type | No | Yes (PSR-4) |
+| Inline definition | Yes | No |
+| Methods | No | Yes |
+| Private properties | No | Yes |
+
+Array shapes and classes serve different purposes. This RFC doesn't replace classes—
+it provides first-class typing for the millions of lines of PHP that already use
+arrays for data interchange.
+
+## Proposal
+
+### 1. Typed Arrays (`array<T>`)
+
+Specify that all elements of an array must be of a certain type:
+
+```php
+function getIds(): array<int> {
+    return [1, 2, 3];
+}
+
+function getUsers(): array<User> {
+    return [new User("Alice"), new User("Bob")];
+}
+
+function getValues(): array<int|string> {
+    return [1, "two", 3];
+}
+```
+
+### 2. Key-Value Typed Arrays (`array<K, V>`)
+
+Specify both key and value types:
+
+```php
+function getScores(): array<string, int> {
+    return ['alice' => 95, 'bob' => 87];
+}
+
+function getUsersById(): array<int, User> {
+    return [1 => new User("Alice"), 2 => new User("Bob")];
+}
+```
+
+### 3. Array Shapes (`array{key: type}`)
+
+Define the exact structure of associative arrays:
+
+```php
+function getUser(): array{id: int, name: string, email: string} {
+    return ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+```
+
+#### Optional Keys
+
+Use `?` after the key name to mark it as optional:
+
+```php
+function getConfig(): array{debug: bool, cache_ttl?: int} {
+    return ['debug' => true];  // cache_ttl is optional
+}
+```
+
+#### Nullable Values
+
+Use `?` before the type to allow null values:
+
+```php
+function getUser(): array{name: string, email: ?string} {
+    return ['name' => 'Alice', 'email' => null];  // email can be null
+}
+```
+
+#### Nested Shapes
+
+Shapes can be nested arbitrarily:
+
+```php
+function getResponse(): array{
+    success: bool,
+    data: array{
+        user: array{id: int, name: string},
+        permissions: array<string>
+    },
+    error: ?string
+} {
+    // ...
+}
+```
+
+### 4. Shape Type Aliases (`shape`)
+
+Define reusable type aliases for array structures using the `shape` keyword:
+
+```php
+shape User = array{id: int, name: string, email: string};
+shape Point = array{x: int, y: int};
+shape Config = array{debug: bool, env: string, cache_ttl?: int};
+
+function getUser(int $id): User {
+    return ['id' => $id, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+
+function processUser(User $user): void {
+    echo "Processing: {$user['name']}";
+}
+```
+
+#### Shape Inheritance
+
+Shapes can extend other shapes using the `extends` keyword. The child shape
+inherits all properties from the parent and can add new ones or override existing ones:
+
+```php
+shape BaseEntity = array{id: int, created_at: string};
+shape User extends BaseEntity = array{name: string, email: string};
+shape Admin extends User = array{role: string, permissions: array<string>};
+
+// User has: id, created_at, name, email
+// Admin has: id, created_at, name, email, role, permissions
+```
+
+Inheritance is resolved at compile time (flattened), so there's no runtime
+overhead. The child shape contains all properties from the entire inheritance chain.
+
+**Property Override:**
+
+Child shapes can override parent properties with a different type:
+
+```php
+shape Base = array{value: string};
+shape Child extends Base = array{value: int};  // Override string to int
+
+// Child's 'value' is now int, not string
+```
+
+**Restrictions:**
+
+Shapes and classes are separate concepts and cannot be mixed in inheritance:
+
+- Shapes cannot extend classes
+- Classes cannot extend shapes
+
+These restrictions are enforced at **compile time** with clear error messages:
+
+```php
+// Shape trying to extend a class
+class MyClass {}
+shape BadShape extends MyClass = array{id: int};
+// Fatal error: Shape BadShape cannot extend class MyClass
+
+// Class trying to extend a shape
+shape MyShape = array{id: int, name: string};
+class BadClass extends MyShape {}
+// Fatal error: Class BadClass cannot extend shape MyShape
+```
+
+#### The `::shape` Syntax
+
+Similar to `::class` for classes, shapes support the `::shape` syntax to get
+the fully qualified name of a shape:
+
+```php
+shape UserShape = array{id: int, name: string};
+
+echo UserShape::shape;  // "UserShape"
+```
+
+With namespaces:
+
+```php
+namespace App\Types;
+
+shape UserShape = array{id: int, name: string};
+
+echo UserShape::shape;  // "App\Types\UserShape"
+```
+
+This is useful for logging, debugging, and working with shape names dynamically.
+
+**Note:** Using `::shape` on a class results in a compile error:
+
+```php
+class MyClass {}
+echo MyClass::shape;  // Error: Cannot use ::shape on class MyClass, use ::class instead
+```
+
+#### Shape Autoloading
+
+Shapes can be autoloaded using the standard `spl_autoload_register()` mechanism:
+
+```php
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// UserShape is autoloaded when first used
+function getUser(): UserShape { ... }
+```
+
+#### shape_exists() Function
+
+Check if a shape type alias is defined:
+
+```php
+// Check without triggering autoload
+if (shape_exists('User', false)) { ... }
+
+// Check with autoloading (default)
+if (shape_exists('User')) { ... }
+```
+
+## Runtime Behavior
+
+### Always-On Validation
+
+Typed array and array shape validation is **always enabled**. When a type constraint
+is declared, it is enforced at runtime:
+
+```php
+function getIds(): array<int> {
+    return [1, "two", 3];  // TypeError at runtime
+}
+
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1];  // TypeError: missing required key 'name'
+}
+```
+
+### Error Messages
+
+Type errors provide detailed, actionable information:
+
+```php
+// For typed arrays
+TypeError: getIds(): Return value must be of type array<int>,
+           array element at index 1 is string
+
+// For array shapes - missing key
+TypeError: getUser(): Return value must be of type array{name: string, ...},
+           array given with missing key "name"
+
+// For array shapes - wrong type
+TypeError: getUser(): Return value must be of type array{id: int, ...},
+           array key "id" is string
+```
+
+## Reflection API
+
+New reflection classes provide runtime introspection:
+
+### ReflectionArrayShapeType
+
+```php
+$ref = new ReflectionFunction('getUser');
+$type = $ref->getReturnType();
+
+if ($type instanceof ReflectionArrayShapeType) {
+    echo $type->getElementCount();          // Number of elements
+    echo $type->getRequiredElementCount();  // Required elements only
+
+    foreach ($type->getElements() as $element) {
+        echo $element->getName();      // Key name
+        echo $element->getType();      // Element type
+        echo $element->isOptional();   // Is optional?
+    }
+}
+```
+
+### ReflectionTypedArrayType
+
+```php
+if ($type instanceof ReflectionTypedArrayType) {
+    echo $type->getElementType();  // Element type (e.g., "int")
+    echo $type->getKeyType();      // Key type for array<K,V>
+}
+```
+
+## Syntax Grammar
+
+```
+array_type:
+    'array' '<' type_list '>'                    // array<T> or array<K,V>
+  | 'array' '{' shape_element_list '}'           // array{...}
+  ;
+
+shape_element_list:
+    shape_element (',' shape_element)* ','?
+  ;
+
+shape_element:
+    T_STRING '?'? ':' type                       // key?: type
+  ;
+
+shape_declaration:
+    'shape' T_STRING shape_extends? '=' array_type ';'
+  ;
+
+shape_extends:
+    'extends' name                               // shape inheritance
+  ;
+
+shape_name_access:
+    name '::' 'shape'                            // MyShape::shape
+  ;
+```
+
+## Comparison with Existing Solutions
+
+### PHPDoc Annotations
+
+```php
+/** @return array{id: int, name: string} */
+function getUser(): array { ... }
+```
+
+**Limitations:**
+- No runtime validation
+- Inconsistent syntax across tools
+- Separated from actual code
+
+### This Proposal
+
+```php
+function getUser(): array{id: int, name: string} { ... }
+```
+
+**Benefits:**
+- Native language syntax
+- Optional runtime validation
+- IDE support via reflection
+- Consistent across all tools
+
+## Implementation Notes
+
+### Compile-Time Validation
+
+The compiler performs several validations at compile time to catch errors early:
+
+| Error Condition | Error Message |
+|----------------|---------------|
+| Shape extends a class | `Shape X cannot extend class Y` |
+| Class extends a shape | `Class X cannot extend shape Y` |
+| Shape redeclaration | `Cannot redeclare shape X` |
+| `::shape` used on a class | `Cannot use ::shape on class X, use ::class instead` |
+| `::class` used on a shape | `Cannot use ::class on shape X, use ::shape instead` |
+
+These compile-time checks ensure that shape inheritance and naming syntax are used correctly, providing immediate feedback during development rather than runtime errors.
+
+### Compile-Time Optimization
+
+The implementation uses escape analysis to optimize constant array validation
+at compile time, avoiding runtime overhead where possible.
+
+### Memory Considerations
+
+Shape type information is stored efficiently:
+- Inline shapes store structure in the type itself
+- Shape aliases store a reference to a global shape table
+- Shapes are interned and shared across functions
+
+### Autoloading Integration
+
+Shape autoloading uses the existing `spl_autoload` infrastructure:
+- Same autoloader handles both classes and shapes
+- Recursive autoload protection
+- Thread-safe implementation
+
+## Backward Compatibility
+
+This proposal is fully backward compatible:
+
+1. New syntax is opt-in via return/parameter type declarations
+2. Existing code without typed array syntax continues to work unchanged
+3. `shape` is a new keyword only valid at file scope for shape declarations
+4. Plain `array` type hints remain valid and unaffected
+
+## Future Scope
+
+Potential future enhancements (not part of this RFC):
+
+1. **Class property types**: `public User $user;`
+2. **Readonly shapes**: Immutable array structures
+3. **Generic shapes**: `shape Result<T> = array{success: bool, data: T}`
+
+**Note:** Shape inheritance (`shape Admin extends User`) and the `::shape` syntax
+are now implemented and documented above.
+
+## Examples
+
+### API Response
+
+```php
+shape ApiResponse = array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    meta: array{timestamp: string, version: string}
+};
+
+function apiSuccess(mixed $data): ApiResponse {
+    return [
+        'success' => true,
+        'data' => $data,
+        'error' => null,
+        'meta' => ['timestamp' => date('c'), 'version' => '1.0']
+    ];
+}
+```
+
+### Configuration
+
+```php
+shape DatabaseConfig = array{
+    host: string,
+    port: int,
+    database: string,
+    username: string,
+    password: string,
+    options?: array<string, mixed>
+};
+
+shape AppConfig = array{
+    debug: bool,
+    environment: string,
+    database: DatabaseConfig,
+    cache: array{driver: string, ttl: int}
+};
+
+function loadConfig(string $path): AppConfig { ... }
+```
+
+### Repository Pattern
+
+```php
+shape UserRecord = array{id: int, name: string, email: string, created_at: string};
+
+class UserRepository {
+    // Single record
+    public function find(int $id): ?UserRecord { ... }
+
+    // Collection of records — combining both features
+    public function findAll(): array<UserRecord> { ... }
+
+    public function save(UserRecord $user): UserRecord { ... }
+    public function delete(int $id): bool { ... }
+}
+```
+
+## Conclusion
+
+This RFC provides two complementary features for typed arrays in PHP:
+
+- **Typed Arrays** (`array<T>`) for collections of the same type
+- **Array Shapes** (`array{key: type}`) for structured data with known keys
+
+Together, they address a long-standing limitation in PHP's type system while
+maintaining full backward compatibility. These features are designed for working
+with arrays—not as a replacement for objects, but as a complement for the many
+situations where arrays are the right tool: database results, API responses,
+configuration files, and more.
+
+The implementation has been tested and all PHP tests pass.
diff --git a/examples/array-shapes/01-basic-shapes.php b/examples/array-shapes/01-basic-shapes.php
new file mode 100644
index 00000000..ded279f2
--- /dev/null
+++ b/examples/array-shapes/01-basic-shapes.php
@@ -0,0 +1,123 @@
+<?php
+/**
+ * Basic Array Shape Examples
+ *
+ * Array shapes define the structure of associative arrays with typed keys.
+ * Syntax: array{key: type, key2: type2, ...}
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC SHAPE WITH REQUIRED KEYS
+// =============================================================================
+
+/**
+ * Simple shape with two required keys
+ */
+function getPoint(): array{x: int, y: int} {
+    return ['x' => 10, 'y' => 20];
+}
+
+$point = getPoint();
+echo "Point: ({$point['x']}, {$point['y']})\n";
+
+
+/**
+ * Shape with different types
+ */
+function getUser(): array{id: int, name: string, balance: float, active: bool} {
+    return [
+        'id' => 1,
+        'name' => 'Alice',
+        'balance' => 100.50,
+        'active' => true
+    ];
+}
+
+$user = getUser();
+echo "User: {$user['name']} (ID: {$user['id']}, Balance: {$user['balance']}, Active: " . ($user['active'] ? 'yes' : 'no') . ")\n";
+
+
+// =============================================================================
+// SHAPES AS PARAMETER TYPES
+// =============================================================================
+
+/**
+ * Function accepting a shaped array as parameter
+ */
+function processOrder(array{product: string, quantity: int, price: float} $order): float {
+    return $order['quantity'] * $order['price'];
+}
+
+$total = processOrder(['product' => 'Widget', 'quantity' => 5, 'price' => 9.99]);
+echo "Order total: \${$total}\n";
+
+
+/**
+ * Function with both shaped parameter and return type
+ */
+function createInvoice(
+    array{customer: string, items: int} $order
+): array{invoice_id: string, customer: string, items: int, created: string} {
+    return [
+        'invoice_id' => uniqid('INV-'),
+        'customer' => $order['customer'],
+        'items' => $order['items'],
+        'created' => date('Y-m-d H:i:s')
+    ];
+}
+
+$invoice = createInvoice(['customer' => 'Acme Corp', 'items' => 3]);
+echo "Invoice: {$invoice['invoice_id']} for {$invoice['customer']}\n";
+
+
+// =============================================================================
+// SINGLE KEY SHAPES
+// =============================================================================
+
+/**
+ * Shape with just one key (useful for wrapper types)
+ */
+function wrapValue(): array{value: mixed} {
+    return ['value' => 'anything goes here'];
+}
+
+$wrapped = wrapValue();
+echo "Wrapped value: {$wrapped['value']}\n";
+
+
+// =============================================================================
+// SHAPES WITH MANY KEYS
+// =============================================================================
+
+/**
+ * Shape with many keys (complex data structure)
+ */
+function getFullProfile(): array{
+    id: int,
+    username: string,
+    email: string,
+    first_name: string,
+    last_name: string,
+    age: int,
+    verified: bool,
+    score: float
+} {
+    return [
+        'id' => 42,
+        'username' => 'johndoe',
+        'email' => 'john@example.com',
+        'first_name' => 'John',
+        'last_name' => 'Doe',
+        'age' => 30,
+        'verified' => true,
+        'score' => 95.5
+    ];
+}
+
+$profile = getFullProfile();
+echo "Profile: {$profile['first_name']} {$profile['last_name']} ({$profile['username']})\n";
+
+
+echo "\n--- All basic shape examples completed successfully! ---\n";
diff --git a/examples/array-shapes/02-optional-keys.php b/examples/array-shapes/02-optional-keys.php
new file mode 100644
index 00000000..190bcc81
--- /dev/null
+++ b/examples/array-shapes/02-optional-keys.php
@@ -0,0 +1,199 @@
+<?php
+/**
+ * Optional Keys in Array Shapes
+ *
+ * Optional keys are marked with a question mark after the key name: key?: type
+ * Optional keys don't need to be present in the returned array.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Shape with one required and one optional key
+ */
+function getUserBasic(): array{name: string, nickname?: string} {
+    // We can omit 'nickname' since it's optional
+    return ['name' => 'Alice'];
+}
+
+$user1 = getUserBasic();
+echo "User: {$user1['name']}, Nickname: " . ($user1['nickname'] ?? 'none') . "\n";
+
+
+/**
+ * Same shape, but this time including the optional key
+ */
+function getUserWithNickname(): array{name: string, nickname?: string} {
+    return ['name' => 'Bob', 'nickname' => 'Bobby'];
+}
+
+$user2 = getUserWithNickname();
+echo "User: {$user2['name']}, Nickname: {$user2['nickname']}\n";
+
+
+// =============================================================================
+// MULTIPLE OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Shape with multiple optional keys
+ */
+function getConfig(): array{
+    host: string,
+    port?: int,
+    timeout?: float,
+    ssl?: bool,
+    username?: string,
+    password?: string
+} {
+    // Only host is required, everything else is optional
+    return ['host' => 'localhost'];
+}
+
+/**
+ * Same shape with some optional keys filled
+ */
+function getSecureConfig(): array{
+    host: string,
+    port?: int,
+    timeout?: float,
+    ssl?: bool,
+    username?: string,
+    password?: string
+} {
+    return [
+        'host' => 'secure.example.com',
+        'port' => 443,
+        'ssl' => true,
+        'timeout' => 30.0
+    ];
+}
+
+$config1 = getConfig();
+$config2 = getSecureConfig();
+echo "Config 1 host: {$config1['host']}, port: " . ($config1['port'] ?? 'default') . "\n";
+echo "Config 2 host: {$config2['host']}, port: {$config2['port']}, ssl: " . ($config2['ssl'] ? 'yes' : 'no') . "\n";
+
+
+// =============================================================================
+// ALL OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Shape where all keys are optional (useful for options/settings)
+ */
+function getOptions(): array{
+    debug?: bool,
+    verbose?: bool,
+    color?: bool,
+    format?: string
+} {
+    // Can return empty array since all keys are optional
+    return [];
+}
+
+/**
+ * Same shape with all options set
+ */
+function getFullOptions(): array{
+    debug?: bool,
+    verbose?: bool,
+    color?: bool,
+    format?: string
+} {
+    return [
+        'debug' => true,
+        'verbose' => false,
+        'color' => true,
+        'format' => 'json'
+    ];
+}
+
+$opts1 = getOptions();
+$opts2 = getFullOptions();
+echo "Options 1 debug: " . (isset($opts1['debug']) ? ($opts1['debug'] ? 'yes' : 'no') : 'not set') . "\n";
+echo "Options 2 debug: " . ($opts2['debug'] ? 'yes' : 'no') . ", format: {$opts2['format']}\n";
+
+
+// =============================================================================
+// MIXED REQUIRED AND OPTIONAL
+// =============================================================================
+
+/**
+ * Real-world example: API response shape
+ */
+function getApiResponse(): array{
+    status: int,
+    message: string,
+    data?: array,
+    error?: string,
+    timestamp?: string
+} {
+    return [
+        'status' => 200,
+        'message' => 'Success',
+        'data' => ['items' => [1, 2, 3]],
+        'timestamp' => date('c')
+        // 'error' is intentionally omitted since this is a success response
+    ];
+}
+
+/**
+ * Error response using the same shape
+ */
+function getErrorResponse(): array{
+    status: int,
+    message: string,
+    data?: array,
+    error?: string,
+    timestamp?: string
+} {
+    return [
+        'status' => 500,
+        'message' => 'Internal Server Error',
+        'error' => 'Database connection failed'
+        // 'data' is omitted since this is an error
+    ];
+}
+
+$success = getApiResponse();
+$error = getErrorResponse();
+echo "Success response: status={$success['status']}, has data: " . (isset($success['data']) ? 'yes' : 'no') . "\n";
+echo "Error response: status={$error['status']}, error: {$error['error']}\n";
+
+
+// =============================================================================
+// OPTIONAL KEYS WITH DEFAULTS PATTERN
+// =============================================================================
+
+/**
+ * Function that merges defaults with optional shape keys
+ */
+function createWidget(array{
+    name: string,
+    width?: int,
+    height?: int,
+    color?: string,
+    visible?: bool
+} $config): array{name: string, width: int, height: int, color: string, visible: bool} {
+    // Merge with defaults
+    return [
+        'name' => $config['name'],
+        'width' => $config['width'] ?? 100,
+        'height' => $config['height'] ?? 50,
+        'color' => $config['color'] ?? 'blue',
+        'visible' => $config['visible'] ?? true
+    ];
+}
+
+$widget1 = createWidget(['name' => 'Button']);
+$widget2 = createWidget(['name' => 'Panel', 'width' => 200, 'color' => 'red']);
+echo "Widget 1: {$widget1['name']} ({$widget1['width']}x{$widget1['height']}) color={$widget1['color']}\n";
+echo "Widget 2: {$widget2['name']} ({$widget2['width']}x{$widget2['height']}) color={$widget2['color']}\n";
+
+
+echo "\n--- All optional key examples completed successfully! ---\n";
diff --git a/examples/array-shapes/03-nested-shapes.php b/examples/array-shapes/03-nested-shapes.php
new file mode 100644
index 00000000..86781e2d
--- /dev/null
+++ b/examples/array-shapes/03-nested-shapes.php
@@ -0,0 +1,272 @@
+<?php
+/**
+ * Nested Array Shapes
+ *
+ * Array shapes can be nested within each other to define complex structures.
+ * Syntax: array{key: array{nested_key: type}}
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// SIMPLE NESTING
+// =============================================================================
+
+/**
+ * Shape with one level of nesting
+ */
+function getUserWithAddress(): array{
+    name: string,
+    address: array{street: string, city: string}
+} {
+    return [
+        'name' => 'Alice',
+        'address' => [
+            'street' => '123 Main St',
+            'city' => 'Boston'
+        ]
+    ];
+}
+
+$user = getUserWithAddress();
+echo "User: {$user['name']}, Lives at: {$user['address']['street']}, {$user['address']['city']}\n";
+
+
+// =============================================================================
+// DEEP NESTING
+// =============================================================================
+
+/**
+ * Shape with multiple levels of nesting
+ */
+function getCompanyInfo(): array{
+    name: string,
+    headquarters: array{
+        address: array{
+            street: string,
+            city: string,
+            country: string
+        },
+        contact: array{
+            phone: string,
+            email: string
+        }
+    }
+} {
+    return [
+        'name' => 'Acme Corp',
+        'headquarters' => [
+            'address' => [
+                'street' => '456 Corporate Blvd',
+                'city' => 'New York',
+                'country' => 'USA'
+            ],
+            'contact' => [
+                'phone' => '+1-555-0123',
+                'email' => 'info@acme.com'
+            ]
+        ]
+    ];
+}
+
+$company = getCompanyInfo();
+echo "Company: {$company['name']}\n";
+echo "  Location: {$company['headquarters']['address']['city']}, {$company['headquarters']['address']['country']}\n";
+echo "  Contact: {$company['headquarters']['contact']['email']}\n";
+
+
+// =============================================================================
+// NESTED WITH OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Nested shapes with optional keys at various levels
+ */
+function getProfile(): array{
+    user: array{
+        id: int,
+        name: string,
+        email?: string
+    },
+    settings?: array{
+        theme?: string,
+        notifications?: bool
+    }
+} {
+    return [
+        'user' => [
+            'id' => 1,
+            'name' => 'Bob'
+            // email is optional
+        ]
+        // settings is optional
+    ];
+}
+
+/**
+ * Same shape with all optional keys filled
+ */
+function getFullProfile(): array{
+    user: array{
+        id: int,
+        name: string,
+        email?: string
+    },
+    settings?: array{
+        theme?: string,
+        notifications?: bool
+    }
+} {
+    return [
+        'user' => [
+            'id' => 2,
+            'name' => 'Carol',
+            'email' => 'carol@example.com'
+        ],
+        'settings' => [
+            'theme' => 'dark',
+            'notifications' => true
+        ]
+    ];
+}
+
+$profile1 = getProfile();
+$profile2 = getFullProfile();
+echo "Profile 1: {$profile1['user']['name']}, email: " . ($profile1['user']['email'] ?? 'not set') . "\n";
+echo "Profile 2: {$profile2['user']['name']}, theme: {$profile2['settings']['theme']}\n";
+
+
+// =============================================================================
+// MULTIPLE NESTED STRUCTURES
+// =============================================================================
+
+/**
+ * Shape with multiple nested structures at the same level
+ */
+function getOrder(): array{
+    order_id: string,
+    customer: array{name: string, email: string},
+    shipping: array{address: string, city: string},
+    billing: array{address: string, city: string},
+    items: array{count: int, total: float}
+} {
+    return [
+        'order_id' => 'ORD-001',
+        'customer' => ['name' => 'Dave', 'email' => 'dave@example.com'],
+        'shipping' => ['address' => '789 Ship Lane', 'city' => 'Portland'],
+        'billing' => ['address' => '789 Ship Lane', 'city' => 'Portland'],
+        'items' => ['count' => 3, 'total' => 149.99]
+    ];
+}
+
+$order = getOrder();
+echo "Order {$order['order_id']} for {$order['customer']['name']}\n";
+echo "  Ship to: {$order['shipping']['city']}\n";
+echo "  Total: \${$order['items']['total']} ({$order['items']['count']} items)\n";
+
+
+// =============================================================================
+// NESTED SHAPE AS PARAMETER
+// =============================================================================
+
+/**
+ * Function accepting nested shape as parameter
+ */
+function processPayment(array{
+    amount: float,
+    card: array{
+        number: string,
+        expiry: string,
+        cvv: string
+    },
+    billing: array{
+        name: string,
+        address: string
+    }
+} $payment): array{success: bool, transaction_id: string} {
+    // Simulate payment processing
+    return [
+        'success' => true,
+        'transaction_id' => 'TXN-' . substr(md5($payment['card']['number']), 0, 8)
+    ];
+}
+
+$result = processPayment([
+    'amount' => 99.99,
+    'card' => [
+        'number' => '4111111111111111',
+        'expiry' => '12/25',
+        'cvv' => '123'
+    ],
+    'billing' => [
+        'name' => 'Eve Smith',
+        'address' => '321 Pay St'
+    ]
+]);
+echo "Payment result: " . ($result['success'] ? 'Success' : 'Failed') . ", ID: {$result['transaction_id']}\n";
+
+
+// =============================================================================
+// DEEPLY NESTED REAL-WORLD EXAMPLE
+// =============================================================================
+
+/**
+ * Complex nested structure: API configuration
+ */
+function getApiConfig(): array{
+    api: array{
+        version: string,
+        endpoints: array{
+            base: string,
+            auth: string
+        }
+    },
+    auth: array{
+        type: string,
+        credentials: array{
+            key: string,
+            secret?: string
+        }
+    },
+    options: array{
+        timeout: int,
+        retry: array{
+            enabled: bool,
+            max_attempts: int
+        }
+    }
+} {
+    return [
+        'api' => [
+            'version' => 'v2',
+            'endpoints' => [
+                'base' => 'https://api.example.com',
+                'auth' => 'https://auth.example.com'
+            ]
+        ],
+        'auth' => [
+            'type' => 'api_key',
+            'credentials' => [
+                'key' => 'my-api-key'
+            ]
+        ],
+        'options' => [
+            'timeout' => 30,
+            'retry' => [
+                'enabled' => true,
+                'max_attempts' => 3
+            ]
+        ]
+    ];
+}
+
+$config = getApiConfig();
+echo "API Config:\n";
+echo "  Version: {$config['api']['version']}\n";
+echo "  Base URL: {$config['api']['endpoints']['base']}\n";
+echo "  Auth type: {$config['auth']['type']}\n";
+echo "  Timeout: {$config['options']['timeout']}s\n";
+echo "  Retry enabled: " . ($config['options']['retry']['enabled'] ? 'yes' : 'no') . "\n";
+
+
+echo "\n--- All nested shape examples completed successfully! ---\n";
diff --git a/examples/array-shapes/04-union-and-nullable-types.php b/examples/array-shapes/04-union-and-nullable-types.php
new file mode 100644
index 00000000..32dbf667
--- /dev/null
+++ b/examples/array-shapes/04-union-and-nullable-types.php
@@ -0,0 +1,265 @@
+<?php
+/**
+ * Union Types and Nullable Types in Array Shapes
+ *
+ * Shape values can use union types (type1|type2) and nullable types (?type).
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// UNION TYPES IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with union type values
+ */
+function getFlexibleId(): array{id: int|string} {
+    return ['id' => 'ABC-123']; // Can be string
+}
+
+function getNumericId(): array{id: int|string} {
+    return ['id' => 42]; // Can also be int
+}
+
+$flex = getFlexibleId();
+$num = getNumericId();
+echo "Flexible ID: {$flex['id']} (type: " . gettype($flex['id']) . ")\n";
+echo "Numeric ID: {$num['id']} (type: " . gettype($num['id']) . ")\n";
+
+
+/**
+ * Multiple union types in a shape
+ */
+function getMixedData(): array{
+    value: int|float|string,
+    status: bool|string,
+    code: int|null
+} {
+    return [
+        'value' => 3.14,
+        'status' => 'active',
+        'code' => null
+    ];
+}
+
+$data = getMixedData();
+echo "Mixed data - value: {$data['value']}, status: {$data['status']}, code: " . ($data['code'] ?? 'null') . "\n";
+
+
+// =============================================================================
+// NULLABLE TYPES IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with nullable type values using ? syntax
+ */
+function getUserWithOptionalEmail(): array{name: string, email: ?string} {
+    return [
+        'name' => 'Alice',
+        'email' => null // Explicitly null
+    ];
+}
+
+function getUserWithEmail(): array{name: string, email: ?string} {
+    return [
+        'name' => 'Bob',
+        'email' => 'bob@example.com'
+    ];
+}
+
+$user1 = getUserWithOptionalEmail();
+$user2 = getUserWithEmail();
+echo "User 1: {$user1['name']}, email: " . ($user1['email'] ?? 'null') . "\n";
+echo "User 2: {$user2['name']}, email: {$user2['email']}\n";
+
+
+/**
+ * Shape with multiple nullable types
+ */
+function getNullableConfig(): array{
+    host: string,
+    port: ?int,
+    timeout: ?float,
+    proxy: ?string
+} {
+    return [
+        'host' => 'localhost',
+        'port' => 8080,
+        'timeout' => null,
+        'proxy' => null
+    ];
+}
+
+$config = getNullableConfig();
+echo "Config - host: {$config['host']}, port: {$config['port']}, timeout: " . ($config['timeout'] ?? 'null') . "\n";
+
+
+// =============================================================================
+// COMBINING UNION AND NULLABLE
+// =============================================================================
+
+/**
+ * Nullable union types
+ */
+function getResult(): array{
+    success: bool,
+    data: string|int|null,
+    error: ?string
+} {
+    return [
+        'success' => true,
+        'data' => 42,
+        'error' => null
+    ];
+}
+
+function getErrorResult(): array{
+    success: bool,
+    data: string|int|null,
+    error: ?string
+} {
+    return [
+        'success' => false,
+        'data' => null,
+        'error' => 'Something went wrong'
+    ];
+}
+
+$success = getResult();
+$error = getErrorResult();
+echo "Success result - data: {$success['data']}\n";
+echo "Error result - error: {$error['error']}\n";
+
+
+// =============================================================================
+// UNION TYPES WITH OBJECTS
+// =============================================================================
+
+class User {
+    public function __construct(public string $name) {}
+}
+
+class Admin {
+    public function __construct(public string $name, public string $role) {}
+}
+
+/**
+ * Shape with object union types
+ */
+function getAccount(): array{
+    id: int,
+    principal: User|Admin
+} {
+    return [
+        'id' => 1,
+        'principal' => new Admin('Alice', 'super')
+    ];
+}
+
+$account = getAccount();
+echo "Account ID: {$account['id']}, Principal: {$account['principal']->name}\n";
+
+
+// =============================================================================
+// COMPLEX UNION EXAMPLES
+// =============================================================================
+
+/**
+ * Real-world example: Database column value
+ */
+function getColumnValue(): array{
+    column: string,
+    value: int|float|string|bool|null,
+    type: string
+} {
+    return [
+        'column' => 'price',
+        'value' => 29.99,
+        'type' => 'decimal'
+    ];
+}
+
+$col = getColumnValue();
+echo "Column '{$col['column']}' = {$col['value']} (type: {$col['type']})\n";
+
+
+/**
+ * Union with array types
+ */
+function getItems(): array{
+    items: array|null,
+    count: int
+} {
+    return [
+        'items' => [1, 2, 3],
+        'count' => 3
+    ];
+}
+
+function getEmptyItems(): array{
+    items: array|null,
+    count: int
+} {
+    return [
+        'items' => null,
+        'count' => 0
+    ];
+}
+
+$items = getItems();
+$empty = getEmptyItems();
+echo "Items: " . ($items['items'] ? implode(', ', $items['items']) : 'none') . "\n";
+echo "Empty items: " . ($empty['items'] ? implode(', ', $empty['items']) : 'none') . "\n";
+
+
+// =============================================================================
+// OPTIONAL VS NULLABLE
+// =============================================================================
+
+/**
+ * Demonstrates the difference between optional keys and nullable types:
+ * - Optional key (key?): The key may be absent from the array
+ * - Nullable type (?type): The key must be present but can have null value
+ */
+
+// Optional: key may not exist
+function withOptionalKey(): array{name: string, age?: int} {
+    return ['name' => 'Alice']; // 'age' key is completely absent
+}
+
+// Nullable: key exists but value is null
+function withNullableValue(): array{name: string, age: ?int} {
+    return ['name' => 'Bob', 'age' => null]; // 'age' key must exist, but value can be null
+}
+
+$opt = withOptionalKey();
+$null = withNullableValue();
+echo "Optional - has 'age' key: " . (array_key_exists('age', $opt) ? 'yes' : 'no') . "\n";
+echo "Nullable - has 'age' key: " . (array_key_exists('age', $null) ? 'yes' : 'no') . ", value: " . ($null['age'] ?? 'null') . "\n";
+
+
+// =============================================================================
+// COMBINING OPTIONAL AND NULLABLE
+// =============================================================================
+
+/**
+ * Optional key with nullable type: key may be absent, or present with null/value
+ */
+function getContact(): array{
+    phone: string,
+    fax?: ?string,  // Optional AND nullable
+    email?: string  // Just optional (if present, must be string)
+} {
+    return [
+        'phone' => '555-0100',
+        'fax' => null  // Present but null
+        // email is absent
+    ];
+}
+
+$contact = getContact();
+echo "Contact - phone: {$contact['phone']}, fax: " . (array_key_exists('fax', $contact) ? ($contact['fax'] ?? 'null') : 'not set') . "\n";
+
+
+echo "\n--- All union and nullable type examples completed successfully! ---\n";
diff --git a/examples/array-shapes/05-shapes-with-typed-arrays.php b/examples/array-shapes/05-shapes-with-typed-arrays.php
new file mode 100644
index 00000000..ad4ad6da
--- /dev/null
+++ b/examples/array-shapes/05-shapes-with-typed-arrays.php
@@ -0,0 +1,290 @@
+<?php
+/**
+ * Combining Array Shapes with Typed Arrays (array<T>)
+ *
+ * Array shapes can contain typed array values, and typed arrays can contain shapes.
+ * This allows for powerful type definitions like array<array{id: int, name: string}>
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// TYPED ARRAYS INSIDE SHAPES
+// =============================================================================
+
+/**
+ * Shape with a typed array value
+ */
+function getNumberList(): array{name: string, values: array<int>} {
+    return [
+        'name' => 'Prime numbers',
+        'values' => [2, 3, 5, 7, 11, 13]
+    ];
+}
+
+$list = getNumberList();
+echo "List '{$list['name']}': " . implode(', ', $list['values']) . "\n";
+
+
+/**
+ * Shape with multiple typed array values
+ */
+function getDataSets(): array{
+    integers: array<int>,
+    floats: array<float>,
+    strings: array<string>
+} {
+    return [
+        'integers' => [1, 2, 3],
+        'floats' => [1.1, 2.2, 3.3],
+        'strings' => ['a', 'b', 'c']
+    ];
+}
+
+$sets = getDataSets();
+echo "Integers: " . implode(', ', $sets['integers']) . "\n";
+echo "Floats: " . implode(', ', $sets['floats']) . "\n";
+echo "Strings: " . implode(', ', $sets['strings']) . "\n";
+
+
+// =============================================================================
+// TYPED ARRAYS OF SHAPES (Lists of Objects)
+// =============================================================================
+
+/**
+ * Typed array containing shapes - perfect for list of records
+ */
+function getUsers(): array<array{id: int, name: string, active: bool}> {
+    return [
+        ['id' => 1, 'name' => 'Alice', 'active' => true],
+        ['id' => 2, 'name' => 'Bob', 'active' => false],
+        ['id' => 3, 'name' => 'Carol', 'active' => true]
+    ];
+}
+
+$users = getUsers();
+echo "Users:\n";
+foreach ($users as $user) {
+    echo "  - {$user['name']} (ID: {$user['id']}, " . ($user['active'] ? 'active' : 'inactive') . ")\n";
+}
+
+
+/**
+ * Typed array with more complex shapes
+ */
+function getOrders(): array<array{
+    order_id: string,
+    amount: float,
+    status: string,
+    created: string
+}> {
+    return [
+        ['order_id' => 'ORD-001', 'amount' => 99.99, 'status' => 'pending', 'created' => '2024-01-15'],
+        ['order_id' => 'ORD-002', 'amount' => 149.50, 'status' => 'shipped', 'created' => '2024-01-16'],
+        ['order_id' => 'ORD-003', 'amount' => 29.99, 'status' => 'delivered', 'created' => '2024-01-17']
+    ];
+}
+
+$orders = getOrders();
+echo "Orders:\n";
+foreach ($orders as $order) {
+    echo "  - {$order['order_id']}: \${$order['amount']} ({$order['status']})\n";
+}
+
+
+// =============================================================================
+// SHAPES WITH OPTIONAL KEYS IN TYPED ARRAYS
+// =============================================================================
+
+/**
+ * Typed array of shapes with optional keys
+ */
+function getContacts(): array<array{name: string, email: string, phone?: string}> {
+    return [
+        ['name' => 'Alice', 'email' => 'alice@example.com', 'phone' => '555-0101'],
+        ['name' => 'Bob', 'email' => 'bob@example.com'], // phone is optional
+        ['name' => 'Carol', 'email' => 'carol@example.com', 'phone' => '555-0103']
+    ];
+}
+
+$contacts = getContacts();
+echo "Contacts:\n";
+foreach ($contacts as $contact) {
+    echo "  - {$contact['name']}: {$contact['email']}" . (isset($contact['phone']) ? " ({$contact['phone']})" : "") . "\n";
+}
+
+
+// =============================================================================
+// NESTED: SHAPE WITH TYPED ARRAY OF SHAPES
+// =============================================================================
+
+/**
+ * Shape containing a typed array of shapes
+ */
+function getDepartment(): array{
+    name: string,
+    budget: float,
+    employees: array<array{id: int, name: string, role: string}>
+} {
+    return [
+        'name' => 'Engineering',
+        'budget' => 500000.00,
+        'employees' => [
+            ['id' => 1, 'name' => 'Alice', 'role' => 'Lead'],
+            ['id' => 2, 'name' => 'Bob', 'role' => 'Senior'],
+            ['id' => 3, 'name' => 'Carol', 'role' => 'Junior']
+        ]
+    ];
+}
+
+$dept = getDepartment();
+echo "Department: {$dept['name']} (Budget: \${$dept['budget']})\n";
+echo "  Employees:\n";
+foreach ($dept['employees'] as $emp) {
+    echo "    - {$emp['name']} ({$emp['role']})\n";
+}
+
+
+// =============================================================================
+// COMPLEX: MULTIPLE TYPED ARRAYS IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with multiple typed array fields
+ */
+function getProject(): array{
+    id: string,
+    name: string,
+    tags: array<string>,
+    members: array<array{user_id: int, role: string}>,
+    milestones: array<array{name: string, date: string, completed: bool}>
+} {
+    return [
+        'id' => 'PRJ-001',
+        'name' => 'Website Redesign',
+        'tags' => ['web', 'design', 'frontend'],
+        'members' => [
+            ['user_id' => 1, 'role' => 'lead'],
+            ['user_id' => 2, 'role' => 'developer']
+        ],
+        'milestones' => [
+            ['name' => 'Design', 'date' => '2024-02-01', 'completed' => true],
+            ['name' => 'Development', 'date' => '2024-03-01', 'completed' => false]
+        ]
+    ];
+}
+
+$project = getProject();
+echo "Project: {$project['name']}\n";
+echo "  Tags: " . implode(', ', $project['tags']) . "\n";
+echo "  Members: " . count($project['members']) . "\n";
+echo "  Milestones:\n";
+foreach ($project['milestones'] as $ms) {
+    echo "    - {$ms['name']}: " . ($ms['completed'] ? 'done' : 'pending') . "\n";
+}
+
+
+// =============================================================================
+// KEYED TYPED ARRAYS IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with keyed (associative) typed array
+ */
+function getSettings(): array{
+    app_name: string,
+    features: array<string, bool>,
+    limits: array<string, int>
+} {
+    return [
+        'app_name' => 'MyApp',
+        'features' => [
+            'dark_mode' => true,
+            'notifications' => false,
+            'analytics' => true
+        ],
+        'limits' => [
+            'max_users' => 100,
+            'max_storage' => 1024,
+            'max_requests' => 1000
+        ]
+    ];
+}
+
+$settings = getSettings();
+echo "App: {$settings['app_name']}\n";
+echo "  Features:\n";
+foreach ($settings['features'] as $feature => $enabled) {
+    echo "    - {$feature}: " . ($enabled ? 'on' : 'off') . "\n";
+}
+echo "  Limits:\n";
+foreach ($settings['limits'] as $limit => $value) {
+    echo "    - {$limit}: {$value}\n";
+}
+
+
+// =============================================================================
+// KEYED TYPED ARRAYS OF SHAPES
+// =============================================================================
+
+/**
+ * Associative array of shapes (keyed by string)
+ */
+function getUsersById(): array<string, array{name: string, email: string}> {
+    return [
+        'user_1' => ['name' => 'Alice', 'email' => 'alice@example.com'],
+        'user_2' => ['name' => 'Bob', 'email' => 'bob@example.com'],
+        'user_3' => ['name' => 'Carol', 'email' => 'carol@example.com']
+    ];
+}
+
+$usersById = getUsersById();
+echo "Users by ID:\n";
+foreach ($usersById as $id => $user) {
+    echo "  - {$id}: {$user['name']} <{$user['email']}>\n";
+}
+
+
+/**
+ * Integer-keyed array of shapes
+ */
+function getIndexedProducts(): array<int, array{sku: string, name: string, price: float}> {
+    return [
+        100 => ['sku' => 'WIDGET-A', 'name' => 'Widget A', 'price' => 9.99],
+        200 => ['sku' => 'WIDGET-B', 'name' => 'Widget B', 'price' => 19.99],
+        300 => ['sku' => 'WIDGET-C', 'name' => 'Widget C', 'price' => 29.99]
+    ];
+}
+
+$products = getIndexedProducts();
+echo "Products by index:\n";
+foreach ($products as $idx => $product) {
+    echo "  - [{$idx}] {$product['name']} (\${$product['price']})\n";
+}
+
+
+// =============================================================================
+// PARAMETER: TYPED ARRAY OF SHAPES
+// =============================================================================
+
+/**
+ * Function accepting typed array of shapes as parameter
+ */
+function calculateTotal(array<array{quantity: int, price: float}> $items): float {
+    $total = 0.0;
+    foreach ($items as $item) {
+        $total += $item['quantity'] * $item['price'];
+    }
+    return $total;
+}
+
+$cart = [
+    ['quantity' => 2, 'price' => 10.00],
+    ['quantity' => 1, 'price' => 25.50],
+    ['quantity' => 3, 'price' => 5.00]
+];
+$total = calculateTotal($cart);
+echo "Cart total: \${$total}\n";
+
+
+echo "\n--- All typed array with shapes examples completed successfully! ---\n";
diff --git a/examples/array-shapes/06-classes-and-interfaces.php b/examples/array-shapes/06-classes-and-interfaces.php
new file mode 100644
index 00000000..9cc96cc2
--- /dev/null
+++ b/examples/array-shapes/06-classes-and-interfaces.php
@@ -0,0 +1,353 @@
+<?php
+/**
+ * Array Shapes with Classes, Interfaces, and Traits
+ *
+ * Array shapes can be used in class methods, properties, interfaces, and traits.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// CLASS METHODS WITH ARRAY SHAPES
+// =============================================================================
+
+class UserRepository
+{
+    /**
+     * Method returning an array shape
+     */
+    public function findById(int $id): array{id: int, name: string, email: string} {
+        return [
+            'id' => $id,
+            'name' => 'User ' . $id,
+            'email' => "user{$id}@example.com"
+        ];
+    }
+
+    /**
+     * Method accepting array shape as parameter
+     */
+    public function create(array{name: string, email: string, password?: string} $data): array{id: int, name: string, email: string} {
+        return [
+            'id' => rand(1000, 9999),
+            'name' => $data['name'],
+            'email' => $data['email']
+        ];
+    }
+
+    /**
+     * Method returning array of shapes
+     */
+    public function findAll(): array<array{id: int, name: string, email: string}> {
+        return [
+            ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'],
+            ['id' => 2, 'name' => 'Bob', 'email' => 'bob@example.com']
+        ];
+    }
+}
+
+$repo = new UserRepository();
+$user = $repo->findById(42);
+echo "Found user: {$user['name']} <{$user['email']}>\n";
+
+$newUser = $repo->create(['name' => 'Carol', 'email' => 'carol@example.com']);
+echo "Created user: {$newUser['name']} (ID: {$newUser['id']})\n";
+
+$all = $repo->findAll();
+echo "All users: " . count($all) . "\n";
+
+
+// =============================================================================
+// INTERFACE WITH ARRAY SHAPES
+// =============================================================================
+
+interface ConfigProviderInterface
+{
+    /**
+     * Interface method with shape return type
+     */
+    public function getConfig(): array{
+        debug: bool,
+        environment: string,
+        features: array<string>
+    };
+
+    /**
+     * Interface method with shape parameter
+     */
+    public function setConfig(array{
+        debug?: bool,
+        environment?: string,
+        features?: array<string>
+    } $config): void;
+}
+
+class AppConfigProvider implements ConfigProviderInterface
+{
+    private bool $debug = false;
+    private string $environment = 'production';
+    private array $features = [];
+
+    public function getConfig(): array{
+        debug: bool,
+        environment: string,
+        features: array<string>
+    } {
+        return [
+            'debug' => $this->debug,
+            'environment' => $this->environment,
+            'features' => $this->features
+        ];
+    }
+
+    public function setConfig(array{
+        debug?: bool,
+        environment?: string,
+        features?: array<string>
+    } $config): void {
+        if (isset($config['debug'])) {
+            $this->debug = $config['debug'];
+        }
+        if (isset($config['environment'])) {
+            $this->environment = $config['environment'];
+        }
+        if (isset($config['features'])) {
+            $this->features = $config['features'];
+        }
+    }
+}
+
+$configProvider = new AppConfigProvider();
+$configProvider->setConfig(['debug' => true, 'environment' => 'development']);
+$config = $configProvider->getConfig();
+echo "Config - debug: " . ($config['debug'] ? 'yes' : 'no') . ", env: {$config['environment']}\n";
+
+
+// =============================================================================
+// ABSTRACT CLASS WITH ARRAY SHAPES
+// =============================================================================
+
+abstract class BaseApiClient
+{
+    /**
+     * Abstract method with shape return type
+     */
+    abstract public function request(string $method, string $endpoint): array{
+        status: int,
+        body: mixed,
+        headers: array<string>
+    };
+
+    /**
+     * Concrete method using shapes
+     */
+    protected function buildResponse(
+        int $status,
+        mixed $body
+    ): array{status: int, body: mixed, headers: array<string>} {
+        return [
+            'status' => $status,
+            'body' => $body,
+            'headers' => ['Content-Type: application/json']
+        ];
+    }
+}
+
+class MockApiClient extends BaseApiClient
+{
+    public function request(string $method, string $endpoint): array{
+        status: int,
+        body: mixed,
+        headers: array<string>
+    } {
+        return $this->buildResponse(200, ['success' => true]);
+    }
+}
+
+$client = new MockApiClient();
+$response = $client->request('GET', '/users');
+echo "API response status: {$response['status']}\n";
+
+
+// =============================================================================
+// TRAIT WITH ARRAY SHAPES
+// =============================================================================
+
+trait Auditable
+{
+    /**
+     * Trait method returning shape
+     */
+    public function getAuditInfo(): array{
+        created_at: string,
+        updated_at: string,
+        created_by: ?int,
+        updated_by: ?int
+    } {
+        return [
+            'created_at' => '2024-01-15 10:00:00',
+            'updated_at' => '2024-01-16 15:30:00',
+            'created_by' => 1,
+            'updated_by' => 2
+        ];
+    }
+}
+
+class Document
+{
+    use Auditable;
+
+    public function __construct(
+        public string $title
+    ) {}
+}
+
+$doc = new Document('My Document');
+$audit = $doc->getAuditInfo();
+echo "Document '{$doc->title}' created at: {$audit['created_at']}\n";
+
+
+// =============================================================================
+// STATIC METHODS WITH ARRAY SHAPES
+// =============================================================================
+
+class Factory
+{
+    /**
+     * Static factory method returning shape
+     */
+    public static function createProduct(
+        string $name,
+        float $price
+    ): array{id: string, name: string, price: float, created: string} {
+        return [
+            'id' => uniqid('prod_'),
+            'name' => $name,
+            'price' => $price,
+            'created' => date('Y-m-d H:i:s')
+        ];
+    }
+
+    /**
+     * Static method returning array of shapes
+     */
+    public static function createBatch(
+        array<string> $names,
+        float $price
+    ): array<array{id: string, name: string, price: float, created: string}> {
+        $products = [];
+        foreach ($names as $name) {
+            $products[] = self::createProduct($name, $price);
+        }
+        return $products;
+    }
+}
+
+$product = Factory::createProduct('Widget', 9.99);
+echo "Product: {$product['name']} - \${$product['price']}\n";
+
+$batch = Factory::createBatch(['A', 'B', 'C'], 5.99);
+echo "Batch created: " . count($batch) . " products\n";
+
+
+// =============================================================================
+// CLASS WITH TYPED PROPERTIES (Array Shapes in Properties)
+// =============================================================================
+
+class Order
+{
+    /**
+     * Property with array shape type
+     */
+    public array $customer; // Type enforced at runtime when strict_arrays=1
+
+    /**
+     * Property with typed array of shapes
+     */
+    public array $items;
+
+    public function __construct(
+        array $customer,
+        array $items
+    ) {
+        $this->customer = $customer;
+        $this->items = $items;
+    }
+
+    public function getCustomer(): array{name: string, email: string} {
+        return $this->customer;
+    }
+
+    public function getItems(): array<array{sku: string, qty: int, price: float}> {
+        return $this->items;
+    }
+
+    public function getTotal(): float {
+        $total = 0.0;
+        foreach ($this->items as $item) {
+            $total += $item['qty'] * $item['price'];
+        }
+        return $total;
+    }
+}
+
+$order = new Order(
+    ['name' => 'John', 'email' => 'john@example.com'],
+    [
+        ['sku' => 'ABC', 'qty' => 2, 'price' => 10.00],
+        ['sku' => 'DEF', 'qty' => 1, 'price' => 25.00]
+    ]
+);
+echo "Order for: {$order->getCustomer()['name']}\n";
+echo "Total: \${$order->getTotal()}\n";
+
+
+// =============================================================================
+// FLUENT INTERFACE WITH ARRAY SHAPES
+// =============================================================================
+
+class QueryBuilder
+{
+    private array $conditions = [];
+    private array $orderBy = [];
+    private ?int $limit = null;
+
+    public function where(array{field: string, operator: string, value: mixed} $condition): self {
+        $this->conditions[] = $condition;
+        return $this;
+    }
+
+    public function orderBy(array{field: string, direction: string} $order): self {
+        $this->orderBy[] = $order;
+        return $this;
+    }
+
+    public function limit(int $limit): self {
+        $this->limit = $limit;
+        return $this;
+    }
+
+    public function build(): array{
+        conditions: array<array{field: string, operator: string, value: mixed}>,
+        order_by: array<array{field: string, direction: string}>,
+        limit: ?int
+    } {
+        return [
+            'conditions' => $this->conditions,
+            'order_by' => $this->orderBy,
+            'limit' => $this->limit
+        ];
+    }
+}
+
+$query = (new QueryBuilder())
+    ->where(['field' => 'status', 'operator' => '=', 'value' => 'active'])
+    ->where(['field' => 'age', 'operator' => '>', 'value' => 18])
+    ->orderBy(['field' => 'name', 'direction' => 'ASC'])
+    ->limit(10)
+    ->build();
+
+echo "Query - conditions: " . count($query['conditions']) . ", limit: {$query['limit']}\n";
+
+
+echo "\n--- All class and interface examples completed successfully! ---\n";
diff --git a/examples/array-shapes/07-closures-and-callables.php b/examples/array-shapes/07-closures-and-callables.php
new file mode 100644
index 00000000..3c251c46
--- /dev/null
+++ b/examples/array-shapes/07-closures-and-callables.php
@@ -0,0 +1,294 @@
+<?php
+/**
+ * Array Shapes with Closures and Callable Types
+ *
+ * Array shapes can be used with closures, arrow functions, and callable parameters.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// CLOSURES WITH ARRAY SHAPE RETURN TYPES
+// =============================================================================
+
+/**
+ * Closure returning an array shape
+ */
+$createUser = function(string $name, string $email): array{id: int, name: string, email: string} {
+    return [
+        'id' => rand(1, 1000),
+        'name' => $name,
+        'email' => $email
+    ];
+};
+
+$user = $createUser('Alice', 'alice@example.com');
+echo "Created user: {$user['name']} <{$user['email']}>\n";
+
+
+/**
+ * Closure with array shape parameter
+ */
+$formatUser = function(array{name: string, email: string} $user): string {
+    return "{$user['name']} <{$user['email']}>";
+};
+
+echo "Formatted: " . $formatUser(['name' => 'Bob', 'email' => 'bob@example.com']) . "\n";
+
+
+// =============================================================================
+// ARROW FUNCTIONS WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Arrow function returning array shape
+ */
+$getPoint = fn(int $x, int $y): array{x: int, y: int} => ['x' => $x, 'y' => $y];
+
+$point = $getPoint(10, 20);
+echo "Point: ({$point['x']}, {$point['y']})\n";
+
+
+/**
+ * Arrow function with array shape parameter
+ */
+$distance = fn(array{x: int, y: int} $p): float => sqrt($p['x'] ** 2 + $p['y'] ** 2);
+
+echo "Distance from origin: " . round($distance(['x' => 3, 'y' => 4]), 2) . "\n";
+
+
+// =============================================================================
+// HIGHER-ORDER FUNCTIONS WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Function accepting closure that returns array shape
+ */
+function processWithTransformer(
+    array $data,
+    Closure $transformer
+): array<array{id: int, value: string}> {
+    $results = [];
+    foreach ($data as $key => $value) {
+        $results[] = $transformer($key, $value);
+    }
+    return $results;
+}
+
+$items = ['foo' => 'bar', 'baz' => 'qux'];
+$transformed = processWithTransformer(
+    $items,
+    fn($k, $v): array{id: int, value: string} => ['id' => crc32($k), 'value' => $v]
+);
+echo "Transformed items: " . count($transformed) . "\n";
+
+
+/**
+ * Function returning a closure that uses array shapes
+ */
+function createValidator(array{min: int, max: int} $range): Closure {
+    return function(int $value) use ($range): array{valid: bool, message: string} {
+        if ($value < $range['min']) {
+            return ['valid' => false, 'message' => "Value must be at least {$range['min']}"];
+        }
+        if ($value > $range['max']) {
+            return ['valid' => false, 'message' => "Value must be at most {$range['max']}"];
+        }
+        return ['valid' => true, 'message' => 'OK'];
+    };
+}
+
+$validateAge = createValidator(['min' => 0, 'max' => 150]);
+$result = $validateAge(25);
+echo "Validation: " . ($result['valid'] ? 'passed' : 'failed') . " - {$result['message']}\n";
+
+
+// =============================================================================
+// ARRAY_MAP WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Using array_map with closures that have array shape types
+ */
+$numbers = [1, 2, 3, 4, 5];
+
+$wrapped = array_map(
+    fn(int $n): array{value: int, squared: int} => ['value' => $n, 'squared' => $n * $n],
+    $numbers
+);
+
+echo "Wrapped numbers:\n";
+foreach ($wrapped as $item) {
+    echo "  {$item['value']} => {$item['squared']}\n";
+}
+
+
+// =============================================================================
+// ARRAY_FILTER WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Filtering an array of shapes
+ */
+$users = [
+    ['id' => 1, 'name' => 'Alice', 'active' => true],
+    ['id' => 2, 'name' => 'Bob', 'active' => false],
+    ['id' => 3, 'name' => 'Carol', 'active' => true]
+];
+
+/** @var array<array{id: int, name: string, active: bool}> $activeUsers */
+$activeUsers = array_filter(
+    $users,
+    fn(array{id: int, name: string, active: bool} $user): bool => $user['active']
+);
+
+echo "Active users: " . count($activeUsers) . "\n";
+
+
+// =============================================================================
+// ARRAY_REDUCE WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Reducing array of shapes to a single shape
+ */
+$orders = [
+    ['product' => 'Widget', 'qty' => 2, 'price' => 10.0],
+    ['product' => 'Gadget', 'qty' => 1, 'price' => 25.0],
+    ['product' => 'Thing', 'qty' => 3, 'price' => 5.0]
+];
+
+$summary = array_reduce(
+    $orders,
+    function(array{total_items: int, total_amount: float} $carry, array{product: string, qty: int, price: float} $item): array{total_items: int, total_amount: float} {
+        return [
+            'total_items' => $carry['total_items'] + $item['qty'],
+            'total_amount' => $carry['total_amount'] + ($item['qty'] * $item['price'])
+        ];
+    },
+    ['total_items' => 0, 'total_amount' => 0.0]
+);
+
+echo "Order summary: {$summary['total_items']} items, \${$summary['total_amount']}\n";
+
+
+// =============================================================================
+// USORT WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Sorting array of shapes
+ */
+$products = [
+    ['name' => 'Banana', 'price' => 0.50],
+    ['name' => 'Apple', 'price' => 1.00],
+    ['name' => 'Cherry', 'price' => 2.50]
+];
+
+usort($products, fn(array{name: string, price: float} $a, array{name: string, price: float} $b): int =>
+    $a['price'] <=> $b['price']
+);
+
+echo "Products by price:\n";
+foreach ($products as $p) {
+    echo "  {$p['name']}: \${$p['price']}\n";
+}
+
+
+// =============================================================================
+// CALLABLE RETURNING CLOSURES WITH SHAPES
+// =============================================================================
+
+/**
+ * Factory function returning typed closures
+ */
+function createCounter(int $start = 0): Closure {
+    $count = $start;
+    return function() use (&$count): array{current: int, next: int} {
+        $current = $count++;
+        return ['current' => $current, 'next' => $count];
+    };
+}
+
+$counter = createCounter(10);
+$step1 = $counter();
+$step2 = $counter();
+echo "Counter: step1={$step1['current']}, step2={$step2['current']}, next={$step2['next']}\n";
+
+
+// =============================================================================
+// CLOSURE WITH USE AND ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Closure capturing external variables
+ */
+$config = ['prefix' => 'USER_', 'suffix' => '_ID'];
+
+$formatId = function(int $id) use ($config): array{raw: int, formatted: string} {
+    return [
+        'raw' => $id,
+        'formatted' => $config['prefix'] . $id . $config['suffix']
+    ];
+};
+
+$formatted = $formatId(42);
+echo "ID: {$formatted['raw']} => {$formatted['formatted']}\n";
+
+
+// =============================================================================
+// RECURSIVE CLOSURES WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Recursive closure building a tree structure
+ */
+$buildTree = function(int $depth, string $prefix = '') use (&$buildTree): array{
+    name: string,
+    children: array
+} {
+    $name = $prefix . 'Node_' . $depth;
+    $children = [];
+
+    if ($depth > 0) {
+        $children[] = $buildTree($depth - 1, $prefix . 'L');
+        $children[] = $buildTree($depth - 1, $prefix . 'R');
+    }
+
+    return [
+        'name' => $name,
+        'children' => $children
+    ];
+};
+
+$tree = $buildTree(2);
+echo "Tree root: {$tree['name']}, children: " . count($tree['children']) . "\n";
+
+
+// =============================================================================
+// FIRST-CLASS CALLABLES WITH ARRAY SHAPES
+// =============================================================================
+
+class Formatter
+{
+    public function formatUser(array{name: string, email: string} $user): string {
+        return "{$user['name']} <{$user['email']}>";
+    }
+}
+
+$formatter = new Formatter();
+$formatFn = $formatter->formatUser(...);  // First-class callable
+
+$users = [
+    ['name' => 'Alice', 'email' => 'alice@example.com'],
+    ['name' => 'Bob', 'email' => 'bob@example.com']
+];
+
+$formatted = array_map($formatFn, $users);
+echo "Formatted users:\n";
+foreach ($formatted as $f) {
+    echo "  - {$f}\n";
+}
+
+
+echo "\n--- All closure and callable examples completed successfully! ---\n";
diff --git a/examples/array-shapes/08-reflection-api.php b/examples/array-shapes/08-reflection-api.php
new file mode 100644
index 00000000..cad597d5
--- /dev/null
+++ b/examples/array-shapes/08-reflection-api.php
@@ -0,0 +1,331 @@
+<?php
+/**
+ * Reflection API for Array Shapes
+ *
+ * The ReflectionArrayShapeType and ReflectionArrayShapeElement classes
+ * allow runtime inspection of array shape types.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC REFLECTION OF ARRAY SHAPES
+// =============================================================================
+
+function getUserProfile(): array{id: int, name: string, email: string, active: bool} {
+    return ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com', 'active' => true];
+}
+
+// Get reflection of the function
+$reflection = new ReflectionFunction('getUserProfile');
+$returnType = $reflection->getReturnType();
+
+echo "=== Basic Reflection ===\n";
+echo "Return type class: " . get_class($returnType) . "\n";
+echo "Is array shape: " . ($returnType instanceof ReflectionArrayShapeType ? 'yes' : 'no') . "\n";
+echo "Type as string: " . (string)$returnType . "\n";
+echo "\n";
+
+
+// =============================================================================
+// INSPECTING SHAPE ELEMENTS
+// =============================================================================
+
+echo "=== Shape Elements ===\n";
+
+$elements = $returnType->getElements();
+echo "Number of elements: " . count($elements) . "\n";
+echo "Element count method: " . $returnType->getElementCount() . "\n";
+echo "Required elements: " . $returnType->getRequiredElementCount() . "\n";
+echo "\n";
+
+echo "Elements:\n";
+foreach ($elements as $element) {
+    echo "  - Name: " . $element->getName() . "\n";
+    echo "    Type: " . (string)$element->getType() . "\n";
+    echo "    Optional: " . ($element->isOptional() ? 'yes' : 'no') . "\n";
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION WITH OPTIONAL KEYS
+// =============================================================================
+
+function getConfig(): array{host: string, port?: int, ssl?: bool, timeout?: float} {
+    return ['host' => 'localhost'];
+}
+
+echo "=== Optional Keys Reflection ===\n";
+
+$configReflection = new ReflectionFunction('getConfig');
+$configType = $configReflection->getReturnType();
+
+echo "Total elements: " . $configType->getElementCount() . "\n";
+echo "Required elements: " . $configType->getRequiredElementCount() . "\n";
+echo "\n";
+
+foreach ($configType->getElements() as $elem) {
+    $status = $elem->isOptional() ? 'optional' : 'required';
+    echo "  - {$elem->getName()}: {$elem->getType()} ({$status})\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// REFLECTION OF NESTED SHAPES
+// =============================================================================
+
+function getNestedData(): array{
+    user: array{id: int, name: string},
+    settings: array{theme: string, language: string}
+} {
+    return [
+        'user' => ['id' => 1, 'name' => 'Alice'],
+        'settings' => ['theme' => 'dark', 'language' => 'en']
+    ];
+}
+
+echo "=== Nested Shapes Reflection ===\n";
+
+$nestedReflection = new ReflectionFunction('getNestedData');
+$nestedType = $nestedReflection->getReturnType();
+
+foreach ($nestedType->getElements() as $elem) {
+    echo "Element: {$elem->getName()}\n";
+    $elemType = $elem->getType();
+    echo "  Type class: " . get_class($elemType) . "\n";
+
+    if ($elemType instanceof ReflectionArrayShapeType) {
+        echo "  Nested elements:\n";
+        foreach ($elemType->getElements() as $nested) {
+            echo "    - {$nested->getName()}: {$nested->getType()}\n";
+        }
+    }
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION OF UNION TYPES IN SHAPES
+// =============================================================================
+
+function getFlexibleData(): array{id: int|string, value: float|int|null} {
+    return ['id' => 'ABC', 'value' => null];
+}
+
+echo "=== Union Types in Shapes ===\n";
+
+$flexReflection = new ReflectionFunction('getFlexibleData');
+$flexType = $flexReflection->getReturnType();
+
+foreach ($flexType->getElements() as $elem) {
+    $elemType = $elem->getType();
+    echo "Element: {$elem->getName()}\n";
+    echo "  Type: {$elemType}\n";
+    echo "  Type class: " . get_class($elemType) . "\n";
+
+    if ($elemType instanceof ReflectionUnionType) {
+        echo "  Union members:\n";
+        foreach ($elemType->getTypes() as $unionMember) {
+            echo "    - {$unionMember}\n";
+        }
+    }
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION OF PARAMETER TYPES
+// =============================================================================
+
+function processOrder(array{product: string, quantity: int, price: float} $order): float {
+    return $order['quantity'] * $order['price'];
+}
+
+echo "=== Parameter Type Reflection ===\n";
+
+$orderReflection = new ReflectionFunction('processOrder');
+$params = $orderReflection->getParameters();
+
+foreach ($params as $param) {
+    echo "Parameter: \${$param->getName()}\n";
+    $paramType = $param->getType();
+    echo "  Type class: " . get_class($paramType) . "\n";
+
+    if ($paramType instanceof ReflectionArrayShapeType) {
+        echo "  Shape elements:\n";
+        foreach ($paramType->getElements() as $elem) {
+            echo "    - {$elem->getName()}: {$elem->getType()}\n";
+        }
+    }
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION OF CLASS METHODS
+// =============================================================================
+
+class UserService
+{
+    public function create(
+        array{name: string, email: string, password?: string} $data
+    ): array{id: int, name: string, email: string, created_at: string} {
+        return [
+            'id' => 1,
+            'name' => $data['name'],
+            'email' => $data['email'],
+            'created_at' => date('c')
+        ];
+    }
+}
+
+echo "=== Class Method Reflection ===\n";
+
+$methodReflection = new ReflectionMethod(UserService::class, 'create');
+
+// Reflect parameter
+$paramType = $methodReflection->getParameters()[0]->getType();
+echo "Parameter type (create):\n";
+if ($paramType instanceof ReflectionArrayShapeType) {
+    foreach ($paramType->getElements() as $elem) {
+        $opt = $elem->isOptional() ? '?' : '';
+        echo "  - {$elem->getName()}{$opt}: {$elem->getType()}\n";
+    }
+}
+
+// Reflect return type
+$returnType = $methodReflection->getReturnType();
+echo "\nReturn type:\n";
+if ($returnType instanceof ReflectionArrayShapeType) {
+    foreach ($returnType->getElements() as $elem) {
+        echo "  - {$elem->getName()}: {$elem->getType()}\n";
+    }
+}
+echo "\n";
+
+
+// =============================================================================
+// DYNAMIC TYPE CHECKING USING REFLECTION
+// =============================================================================
+
+echo "=== Dynamic Type Checking ===\n";
+
+function validateAgainstShape(array $data, ReflectionArrayShapeType $shape): array {
+    $errors = [];
+
+    foreach ($shape->getElements() as $elem) {
+        $key = $elem->getName();
+
+        // Check if required key is missing
+        if (!array_key_exists($key, $data)) {
+            if (!$elem->isOptional()) {
+                $errors[] = "Missing required key: {$key}";
+            }
+            continue;
+        }
+
+        // Get the expected type as string
+        $expectedType = (string)$elem->getType();
+        $actualType = gettype($data[$key]);
+
+        echo "  Checking '{$key}': expected={$expectedType}, actual={$actualType}\n";
+    }
+
+    return $errors;
+}
+
+// Test validation
+$testData = ['id' => 1, 'name' => 'Test'];
+$shapeType = (new ReflectionFunction('getUserProfile'))->getReturnType();
+
+echo "Validating test data against getUserProfile shape:\n";
+$errors = validateAgainstShape($testData, $shapeType);
+if ($errors) {
+    echo "Errors found:\n";
+    foreach ($errors as $error) {
+        echo "  - {$error}\n";
+    }
+}
+echo "\n";
+
+
+// =============================================================================
+// BUILDING DOCUMENTATION FROM REFLECTION
+// =============================================================================
+
+echo "=== Auto-Generated Documentation ===\n";
+
+function generateShapeDoc(ReflectionArrayShapeType $shape): string {
+    $doc = "Shape structure:\n";
+    $doc .= "```\n";
+    $doc .= "array{\n";
+
+    foreach ($shape->getElements() as $elem) {
+        $optional = $elem->isOptional() ? '?' : '';
+        $doc .= "    {$elem->getName()}{$optional}: {$elem->getType()},\n";
+    }
+
+    $doc .= "}\n";
+    $doc .= "```\n";
+    $doc .= "\nTotal elements: " . $shape->getElementCount() . "\n";
+    $doc .= "Required elements: " . $shape->getRequiredElementCount() . "\n";
+
+    return $doc;
+}
+
+$docType = (new ReflectionFunction('getConfig'))->getReturnType();
+echo generateShapeDoc($docType);
+
+
+// =============================================================================
+// COMPARING SHAPE TYPES
+// =============================================================================
+
+function getUserA(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'A'];
+}
+
+function getUserB(): array{id: int, name: string} {
+    return ['id' => 2, 'name' => 'B'];
+}
+
+function getUserC(): array{id: int, name: string, email: string} {
+    return ['id' => 3, 'name' => 'C', 'email' => 'c@example.com'];
+}
+
+echo "=== Comparing Shape Types ===\n";
+
+$typeA = (new ReflectionFunction('getUserA'))->getReturnType();
+$typeB = (new ReflectionFunction('getUserB'))->getReturnType();
+$typeC = (new ReflectionFunction('getUserC'))->getReturnType();
+
+function shapesMatch(ReflectionArrayShapeType $a, ReflectionArrayShapeType $b): bool {
+    if ($a->getElementCount() !== $b->getElementCount()) {
+        return false;
+    }
+
+    $aElements = $a->getElements();
+    $bElements = $b->getElements();
+
+    for ($i = 0; $i < count($aElements); $i++) {
+        if ($aElements[$i]->getName() !== $bElements[$i]->getName()) {
+            return false;
+        }
+        if ((string)$aElements[$i]->getType() !== (string)$bElements[$i]->getType()) {
+            return false;
+        }
+        if ($aElements[$i]->isOptional() !== $bElements[$i]->isOptional()) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+echo "getUserA matches getUserB: " . (shapesMatch($typeA, $typeB) ? 'yes' : 'no') . "\n";
+echo "getUserA matches getUserC: " . (shapesMatch($typeA, $typeC) ? 'yes' : 'no') . "\n";
+
+
+echo "\n--- All reflection examples completed successfully! ---\n";
diff --git a/examples/array-shapes/09-validation-and-errors.php b/examples/array-shapes/09-validation-and-errors.php
new file mode 100644
index 00000000..afbbc5af
--- /dev/null
+++ b/examples/array-shapes/09-validation-and-errors.php
@@ -0,0 +1,360 @@
+<?php
+/**
+ * Validation and Error Handling with Array Shapes
+ *
+ * When declare(strict_arrays=1) is enabled, PHP validates array shapes
+ * at runtime and throws TypeError on mismatches.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC TYPE VALIDATION
+// =============================================================================
+
+echo "=== Basic Type Validation ===\n";
+
+function getValidUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice']; // Valid
+}
+
+$user = getValidUser();
+echo "Valid user: ID={$user['id']}, Name={$user['name']}\n\n";
+
+
+// =============================================================================
+// CATCHING TYPE ERRORS - MISSING REQUIRED KEY
+// =============================================================================
+
+echo "=== Missing Required Key ===\n";
+
+function getMissingKeyUser(): array{id: int, name: string, email: string} {
+    // This would cause a TypeError because 'email' is missing
+    // Uncommenting will throw: TypeError: Return value must have key 'email'
+    // return ['id' => 1, 'name' => 'Alice'];
+
+    // Correct version:
+    return ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+
+try {
+    $user = getMissingKeyUser();
+    echo "User retrieved successfully: {$user['email']}\n";
+} catch (TypeError $e) {
+    echo "TypeError caught: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// CATCHING TYPE ERRORS - WRONG VALUE TYPE
+// =============================================================================
+
+echo "=== Wrong Value Type ===\n";
+
+function getTypedUser(int $id, string $name): array{id: int, name: string} {
+    // Parameters ensure correct types
+    return ['id' => $id, 'name' => $name];
+}
+
+try {
+    // This works
+    $user = getTypedUser(1, 'Bob');
+    echo "User: ID={$user['id']} (type: " . gettype($user['id']) . ")\n";
+
+    // This would fail at parameter level
+    // $user = getTypedUser('not-an-int', 'Carol');
+} catch (TypeError $e) {
+    echo "TypeError caught: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// OPTIONAL KEYS DON'T REQUIRE VALUES
+// =============================================================================
+
+echo "=== Optional Keys ===\n";
+
+function getPartialConfig(): array{host: string, port?: int, ssl?: bool} {
+    // Only 'host' is required - this is valid
+    return ['host' => 'localhost'];
+}
+
+function getFullConfig(): array{host: string, port?: int, ssl?: bool} {
+    // All keys provided - also valid
+    return ['host' => 'secure.example.com', 'port' => 443, 'ssl' => true];
+}
+
+$partial = getPartialConfig();
+$full = getFullConfig();
+echo "Partial config - host: {$partial['host']}, port: " . ($partial['port'] ?? 'not set') . "\n";
+echo "Full config - host: {$full['host']}, port: {$full['port']}, ssl: " . ($full['ssl'] ? 'yes' : 'no') . "\n\n";
+
+
+// =============================================================================
+// VALIDATION WITH NULLABLE TYPES
+// =============================================================================
+
+echo "=== Nullable Types ===\n";
+
+function getNullableData(): array{value: ?string, count: ?int} {
+    return [
+        'value' => null,  // Valid - nullable
+        'count' => null   // Valid - nullable
+    ];
+}
+
+function getMixedNullable(): array{value: ?string, count: ?int} {
+    return [
+        'value' => 'hello',  // Valid - string
+        'count' => null      // Valid - null
+    ];
+}
+
+$null = getNullableData();
+$mixed = getMixedNullable();
+echo "Nullable data - value: " . ($null['value'] ?? 'null') . ", count: " . ($null['count'] ?? 'null') . "\n";
+echo "Mixed data - value: {$mixed['value']}, count: " . ($mixed['count'] ?? 'null') . "\n\n";
+
+
+// =============================================================================
+// PARAMETER VALIDATION
+// =============================================================================
+
+echo "=== Parameter Validation ===\n";
+
+function processData(array{x: int, y: int} $point): int {
+    return $point['x'] + $point['y'];
+}
+
+try {
+    // Valid call
+    $sum = processData(['x' => 10, 'y' => 20]);
+    echo "Sum: {$sum}\n";
+
+    // Invalid call would be caught here
+    // $sum = processData(['x' => 10]); // Missing 'y'
+    // $sum = processData(['x' => 'ten', 'y' => 20]); // Wrong type
+} catch (TypeError $e) {
+    echo "TypeError caught: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// NESTED SHAPE VALIDATION
+// =============================================================================
+
+echo "=== Nested Shape Validation ===\n";
+
+function getNestedValid(): array{
+    user: array{id: int, name: string},
+    meta: array{created: string}
+} {
+    return [
+        'user' => ['id' => 1, 'name' => 'Alice'],
+        'meta' => ['created' => '2024-01-15']
+    ];
+}
+
+$nested = getNestedValid();
+echo "Nested user: {$nested['user']['name']}, created: {$nested['meta']['created']}\n\n";
+
+
+// =============================================================================
+// SAFE WRAPPER PATTERN
+// =============================================================================
+
+echo "=== Safe Wrapper Pattern ===\n";
+
+/**
+ * Wrapper that catches validation errors and returns a result shape
+ */
+function safeGetUser(int $id): array{success: bool, data: ?array, error: ?string} {
+    try {
+        // Simulate fetching user
+        if ($id <= 0) {
+            throw new InvalidArgumentException("Invalid user ID: {$id}");
+        }
+
+        $user = [
+            'id' => $id,
+            'name' => 'User ' . $id,
+            'email' => "user{$id}@example.com"
+        ];
+
+        return [
+            'success' => true,
+            'data' => $user,
+            'error' => null
+        ];
+    } catch (Throwable $e) {
+        return [
+            'success' => false,
+            'data' => null,
+            'error' => $e->getMessage()
+        ];
+    }
+}
+
+$result1 = safeGetUser(42);
+$result2 = safeGetUser(-1);
+
+echo "Result 1: " . ($result1['success'] ? "success - {$result1['data']['name']}" : "failed - {$result1['error']}") . "\n";
+echo "Result 2: " . ($result2['success'] ? "success - {$result2['data']['name']}" : "failed - {$result2['error']}") . "\n\n";
+
+
+// =============================================================================
+// VALIDATION HELPER FUNCTIONS
+// =============================================================================
+
+echo "=== Custom Validation Helpers ===\n";
+
+/**
+ * Validate array has required keys before using as shape
+ */
+function validateShape(array $data, array $requiredKeys): bool {
+    foreach ($requiredKeys as $key) {
+        if (!array_key_exists($key, $data)) {
+            return false;
+        }
+    }
+    return true;
+}
+
+/**
+ * Validate and coerce to shape
+ */
+function toUserShape(array $data): array{id: int, name: string, email: string} {
+    // Validate required keys
+    $required = ['id', 'name', 'email'];
+    foreach ($required as $key) {
+        if (!isset($data[$key])) {
+            throw new InvalidArgumentException("Missing required key: {$key}");
+        }
+    }
+
+    // Coerce types if needed
+    return [
+        'id' => (int) $data['id'],
+        'name' => (string) $data['name'],
+        'email' => (string) $data['email']
+    ];
+}
+
+try {
+    $userData = ['id' => '123', 'name' => 'Test', 'email' => 'test@example.com'];
+    $user = toUserShape($userData);
+    echo "Coerced user: ID={$user['id']} (type: " . gettype($user['id']) . ")\n";
+} catch (InvalidArgumentException $e) {
+    echo "Validation failed: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// ASSERTION STYLE VALIDATION
+// =============================================================================
+
+echo "=== Assertion Style Validation ===\n";
+
+/**
+ * Assert function for shape validation
+ */
+function assertValidUser(array $user): void {
+    assert(isset($user['id']) && is_int($user['id']), 'id must be an integer');
+    assert(isset($user['name']) && is_string($user['name']), 'name must be a string');
+    assert(isset($user['email']) && is_string($user['email']), 'email must be a string');
+}
+
+$validUser = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+assertValidUser($validUser);
+echo "User validated successfully\n\n";
+
+
+// =============================================================================
+// TYPED ARRAYS VALIDATION
+// =============================================================================
+
+echo "=== Typed Arrays Validation ===\n";
+
+function getTypedList(): array<int> {
+    return [1, 2, 3, 4, 5]; // Valid - all integers
+}
+
+function getTypedShapeList(): array<array{id: int, name: string}> {
+    return [
+        ['id' => 1, 'name' => 'Alice'],
+        ['id' => 2, 'name' => 'Bob'],
+        ['id' => 3, 'name' => 'Carol']
+    ];
+}
+
+$numbers = getTypedList();
+$users = getTypedShapeList();
+echo "Numbers: " . implode(', ', $numbers) . "\n";
+echo "Users: " . count($users) . " valid user shapes\n\n";
+
+
+// =============================================================================
+// DEFENSIVE CODING PATTERNS
+// =============================================================================
+
+echo "=== Defensive Coding Patterns ===\n";
+
+class UserRepository
+{
+    /**
+     * Returns user or throws exception
+     */
+    public function findOrFail(int $id): array{id: int, name: string, email: string} {
+        $user = $this->find($id);
+        if ($user === null) {
+            throw new RuntimeException("User not found: {$id}");
+        }
+        return $user;
+    }
+
+    /**
+     * Returns user or null
+     */
+    public function find(int $id): ?array {
+        if ($id <= 0) {
+            return null;
+        }
+        return ['id' => $id, 'name' => "User {$id}", 'email' => "user{$id}@example.com"];
+    }
+
+    /**
+     * Returns result shape for safer error handling
+     */
+    public function findSafe(int $id): array{found: bool, user: ?array} {
+        $user = $this->find($id);
+        return [
+            'found' => $user !== null,
+            'user' => $user
+        ];
+    }
+}
+
+$repo = new UserRepository();
+
+// Pattern 1: Try-catch with findOrFail
+try {
+    $user = $repo->findOrFail(1);
+    echo "Found user: {$user['name']}\n";
+} catch (RuntimeException $e) {
+    echo "Error: {$e->getMessage()}\n";
+}
+
+// Pattern 2: Check result shape
+$result = $repo->findSafe(999);
+if ($result['found']) {
+    echo "User found: {$result['user']['name']}\n";
+} else {
+    echo "User not found\n";
+}
+
+
+echo "\n--- All validation and error examples completed successfully! ---\n";
diff --git a/examples/array-shapes/10-real-world-patterns.php b/examples/array-shapes/10-real-world-patterns.php
new file mode 100644
index 00000000..d8c0fdc8
--- /dev/null
+++ b/examples/array-shapes/10-real-world-patterns.php
@@ -0,0 +1,590 @@
+<?php
+/**
+ * Real-World Patterns and Use Cases for Array Shapes
+ *
+ * Common patterns you'll encounter in production applications.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// PATTERN 1: API RESPONSES
+// =============================================================================
+
+echo "=== API Response Pattern ===\n";
+
+/**
+ * Standard API response wrapper
+ */
+function apiSuccess(mixed $data): array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    meta: array{timestamp: string, version: string}
+} {
+    return [
+        'success' => true,
+        'data' => $data,
+        'error' => null,
+        'meta' => [
+            'timestamp' => date('c'),
+            'version' => '1.0'
+        ]
+    ];
+}
+
+function apiError(string $message, int $code = 500): array{
+    success: bool,
+    data: ?array,
+    error: string,
+    meta: array{timestamp: string, code: int}
+} {
+    return [
+        'success' => false,
+        'data' => null,
+        'error' => $message,
+        'meta' => [
+            'timestamp' => date('c'),
+            'code' => $code
+        ]
+    ];
+}
+
+$success = apiSuccess(['user' => ['id' => 1, 'name' => 'Alice']]);
+$error = apiError('User not found', 404);
+echo "Success response: " . json_encode($success) . "\n";
+echo "Error response: " . json_encode($error) . "\n\n";
+
+
+// =============================================================================
+// PATTERN 2: CONFIGURATION OBJECTS
+// =============================================================================
+
+echo "=== Configuration Pattern ===\n";
+
+/**
+ * Database configuration
+ */
+function getDatabaseConfig(): array{
+    driver: string,
+    host: string,
+    port: int,
+    database: string,
+    username: string,
+    password: string,
+    options?: array{
+        charset?: string,
+        collation?: string,
+        timeout?: int,
+        persistent?: bool
+    }
+} {
+    return [
+        'driver' => 'mysql',
+        'host' => 'localhost',
+        'port' => 3306,
+        'database' => 'myapp',
+        'username' => 'root',
+        'password' => 'secret',
+        'options' => [
+            'charset' => 'utf8mb4',
+            'timeout' => 30
+        ]
+    ];
+}
+
+/**
+ * Cache configuration
+ */
+function getCacheConfig(): array{
+    driver: string,
+    prefix: string,
+    ttl: int,
+    redis?: array{host: string, port: int, password?: string},
+    memcached?: array{servers: array<array{host: string, port: int}>}
+} {
+    return [
+        'driver' => 'redis',
+        'prefix' => 'myapp_',
+        'ttl' => 3600,
+        'redis' => [
+            'host' => '127.0.0.1',
+            'port' => 6379
+        ]
+    ];
+}
+
+$dbConfig = getDatabaseConfig();
+$cacheConfig = getCacheConfig();
+echo "DB: {$dbConfig['driver']}://{$dbConfig['host']}:{$dbConfig['port']}/{$dbConfig['database']}\n";
+echo "Cache: {$cacheConfig['driver']} (prefix: {$cacheConfig['prefix']}, ttl: {$cacheConfig['ttl']}s)\n\n";
+
+
+// =============================================================================
+// PATTERN 3: DATA TRANSFER OBJECTS (DTOs) AS SHAPES
+// =============================================================================
+
+echo "=== DTO Pattern ===\n";
+
+/**
+ * User DTO
+ */
+function createUserDTO(
+    int $id,
+    string $name,
+    string $email
+): array{id: int, name: string, email: string, created_at: string} {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email,
+        'created_at' => date('c')
+    ];
+}
+
+/**
+ * Order DTO with nested structures
+ */
+function createOrderDTO(
+    string $orderId,
+    array{id: int, name: string, email: string} $customer,
+    array<array{sku: string, name: string, qty: int, price: float}> $items
+): array{
+    order_id: string,
+    customer: array{id: int, name: string, email: string},
+    items: array<array{sku: string, name: string, qty: int, price: float}>,
+    total: float,
+    created_at: string
+} {
+    $total = array_reduce($items, fn($sum, $item) => $sum + ($item['qty'] * $item['price']), 0.0);
+
+    return [
+        'order_id' => $orderId,
+        'customer' => $customer,
+        'items' => $items,
+        'total' => $total,
+        'created_at' => date('c')
+    ];
+}
+
+$user = createUserDTO(1, 'Alice', 'alice@example.com');
+$order = createOrderDTO(
+    'ORD-001',
+    $user,
+    [
+        ['sku' => 'WIDGET-A', 'name' => 'Widget A', 'qty' => 2, 'price' => 10.00],
+        ['sku' => 'GADGET-B', 'name' => 'Gadget B', 'qty' => 1, 'price' => 25.00]
+    ]
+);
+echo "Order {$order['order_id']} for {$order['customer']['name']}: \${$order['total']}\n\n";
+
+
+// =============================================================================
+// PATTERN 4: EVENT PAYLOADS
+// =============================================================================
+
+echo "=== Event Payload Pattern ===\n";
+
+/**
+ * User registered event
+ */
+function userRegisteredEvent(
+    int $userId,
+    string $email
+): array{event: string, payload: array{user_id: int, email: string}, timestamp: string} {
+    return [
+        'event' => 'user.registered',
+        'payload' => [
+            'user_id' => $userId,
+            'email' => $email
+        ],
+        'timestamp' => date('c')
+    ];
+}
+
+/**
+ * Order placed event
+ */
+function orderPlacedEvent(
+    string $orderId,
+    int $customerId,
+    float $total
+): array{event: string, payload: array{order_id: string, customer_id: int, total: float}, timestamp: string} {
+    return [
+        'event' => 'order.placed',
+        'payload' => [
+            'order_id' => $orderId,
+            'customer_id' => $customerId,
+            'total' => $total
+        ],
+        'timestamp' => date('c')
+    ];
+}
+
+$regEvent = userRegisteredEvent(42, 'new@example.com');
+$orderEvent = orderPlacedEvent('ORD-123', 42, 99.99);
+echo "Event: {$regEvent['event']} at {$regEvent['timestamp']}\n";
+echo "Event: {$orderEvent['event']} - Order {$orderEvent['payload']['order_id']}\n\n";
+
+
+// =============================================================================
+// PATTERN 5: FORM DATA VALIDATION
+// =============================================================================
+
+echo "=== Form Validation Pattern ===\n";
+
+/**
+ * Registration form data
+ */
+function validateRegistrationForm(array $input): array{
+    valid: bool,
+    data?: array{name: string, email: string, password: string},
+    errors: array<string>
+} {
+    $errors = [];
+
+    if (empty($input['name'])) {
+        $errors[] = 'Name is required';
+    }
+    if (empty($input['email']) || !str_contains($input['email'], '@')) {
+        $errors[] = 'Valid email is required';
+    }
+    if (empty($input['password']) || strlen($input['password']) < 8) {
+        $errors[] = 'Password must be at least 8 characters';
+    }
+
+    if (empty($errors)) {
+        return [
+            'valid' => true,
+            'data' => [
+                'name' => $input['name'],
+                'email' => $input['email'],
+                'password' => $input['password']
+            ],
+            'errors' => []
+        ];
+    }
+
+    return [
+        'valid' => false,
+        'errors' => $errors
+    ];
+}
+
+$validForm = validateRegistrationForm([
+    'name' => 'Alice',
+    'email' => 'alice@example.com',
+    'password' => 'securepassword'
+]);
+
+$invalidForm = validateRegistrationForm([
+    'name' => '',
+    'email' => 'not-an-email',
+    'password' => 'short'
+]);
+
+echo "Valid form: " . ($validForm['valid'] ? 'yes' : 'no') . "\n";
+echo "Invalid form errors: " . implode(', ', $invalidForm['errors']) . "\n\n";
+
+
+// =============================================================================
+// PATTERN 6: PAGINATION RESULTS
+// =============================================================================
+
+echo "=== Pagination Pattern ===\n";
+
+/**
+ * Paginated result wrapper
+ */
+function paginatedResult(
+    array $items,
+    int $page,
+    int $perPage,
+    int $total
+): array{
+    data: array,
+    pagination: array{
+        current_page: int,
+        per_page: int,
+        total_items: int,
+        total_pages: int,
+        has_next: bool,
+        has_prev: bool
+    }
+} {
+    $totalPages = (int) ceil($total / $perPage);
+
+    return [
+        'data' => $items,
+        'pagination' => [
+            'current_page' => $page,
+            'per_page' => $perPage,
+            'total_items' => $total,
+            'total_pages' => $totalPages,
+            'has_next' => $page < $totalPages,
+            'has_prev' => $page > 1
+        ]
+    ];
+}
+
+$result = paginatedResult(
+    [['id' => 1], ['id' => 2], ['id' => 3]],
+    2, 10, 45
+);
+echo "Page {$result['pagination']['current_page']} of {$result['pagination']['total_pages']}\n";
+echo "Has next: " . ($result['pagination']['has_next'] ? 'yes' : 'no') . "\n\n";
+
+
+// =============================================================================
+// PATTERN 7: REPOSITORY METHODS
+// =============================================================================
+
+echo "=== Repository Pattern ===\n";
+
+class ProductRepository
+{
+    private array $products = [];
+
+    public function __construct()
+    {
+        $this->products = [
+            ['id' => 1, 'sku' => 'PROD-001', 'name' => 'Widget', 'price' => 9.99, 'stock' => 100],
+            ['id' => 2, 'sku' => 'PROD-002', 'name' => 'Gadget', 'price' => 19.99, 'stock' => 50],
+            ['id' => 3, 'sku' => 'PROD-003', 'name' => 'Thing', 'price' => 29.99, 'stock' => 25]
+        ];
+    }
+
+    public function findById(int $id): ?array {
+        foreach ($this->products as $product) {
+            if ($product['id'] === $id) {
+                return $product;
+            }
+        }
+        return null;
+    }
+
+    public function findAll(): array<array{id: int, sku: string, name: string, price: float, stock: int}> {
+        return $this->products;
+    }
+
+    public function findBySku(string $sku): ?array {
+        foreach ($this->products as $product) {
+            if ($product['sku'] === $sku) {
+                return $product;
+            }
+        }
+        return null;
+    }
+
+    public function search(
+        array{min_price?: float, max_price?: float, in_stock?: bool} $criteria
+    ): array<array{id: int, sku: string, name: string, price: float, stock: int}> {
+        return array_filter($this->products, function($p) use ($criteria) {
+            if (isset($criteria['min_price']) && $p['price'] < $criteria['min_price']) {
+                return false;
+            }
+            if (isset($criteria['max_price']) && $p['price'] > $criteria['max_price']) {
+                return false;
+            }
+            if (isset($criteria['in_stock']) && $criteria['in_stock'] && $p['stock'] <= 0) {
+                return false;
+            }
+            return true;
+        });
+    }
+}
+
+$repo = new ProductRepository();
+$all = $repo->findAll();
+$searched = $repo->search(['min_price' => 15.00, 'in_stock' => true]);
+
+echo "All products: " . count($all) . "\n";
+echo "Filtered products: " . count($searched) . "\n\n";
+
+
+// =============================================================================
+// PATTERN 8: SERVICE LAYER RESPONSES
+// =============================================================================
+
+echo "=== Service Layer Pattern ===\n";
+
+class PaymentService
+{
+    public function processPayment(
+        array{amount: float, currency: string, card_token: string} $payment
+    ): array{
+        success: bool,
+        transaction_id: ?string,
+        error_code: ?string,
+        error_message: ?string
+    } {
+        // Simulate payment processing
+        if ($payment['amount'] <= 0) {
+            return [
+                'success' => false,
+                'transaction_id' => null,
+                'error_code' => 'INVALID_AMOUNT',
+                'error_message' => 'Amount must be greater than zero'
+            ];
+        }
+
+        return [
+            'success' => true,
+            'transaction_id' => 'TXN-' . uniqid(),
+            'error_code' => null,
+            'error_message' => null
+        ];
+    }
+
+    public function refund(
+        string $transactionId,
+        float $amount
+    ): array{success: bool, refund_id: ?string, error: ?string} {
+        return [
+            'success' => true,
+            'refund_id' => 'REF-' . uniqid(),
+            'error' => null
+        ];
+    }
+}
+
+$paymentService = new PaymentService();
+$result = $paymentService->processPayment([
+    'amount' => 99.99,
+    'currency' => 'USD',
+    'card_token' => 'tok_visa'
+]);
+
+echo "Payment: " . ($result['success'] ? "Success - {$result['transaction_id']}" : "Failed - {$result['error_message']}") . "\n\n";
+
+
+// =============================================================================
+// PATTERN 9: BUILDER PATTERN WITH SHAPES
+// =============================================================================
+
+echo "=== Builder Pattern ===\n";
+
+class EmailBuilder
+{
+    private array $data = [
+        'to' => [],
+        'cc' => [],
+        'bcc' => [],
+        'subject' => '',
+        'body' => '',
+        'attachments' => []
+    ];
+
+    public function to(string $email, string $name = ''): self {
+        $this->data['to'][] = ['email' => $email, 'name' => $name];
+        return $this;
+    }
+
+    public function cc(string $email): self {
+        $this->data['cc'][] = $email;
+        return $this;
+    }
+
+    public function subject(string $subject): self {
+        $this->data['subject'] = $subject;
+        return $this;
+    }
+
+    public function body(string $body): self {
+        $this->data['body'] = $body;
+        return $this;
+    }
+
+    public function attach(array{filename: string, content: string, mime: string} $attachment): self {
+        $this->data['attachments'][] = $attachment;
+        return $this;
+    }
+
+    public function build(): array{
+        to: array<array{email: string, name: string}>,
+        cc: array<string>,
+        bcc: array<string>,
+        subject: string,
+        body: string,
+        attachments: array<array{filename: string, content: string, mime: string}>
+    } {
+        return $this->data;
+    }
+}
+
+$email = (new EmailBuilder())
+    ->to('alice@example.com', 'Alice')
+    ->to('bob@example.com', 'Bob')
+    ->cc('manager@example.com')
+    ->subject('Weekly Report')
+    ->body('Please find attached the weekly report.')
+    ->attach(['filename' => 'report.pdf', 'content' => '...', 'mime' => 'application/pdf'])
+    ->build();
+
+echo "Email to: " . count($email['to']) . " recipients, Subject: {$email['subject']}\n\n";
+
+
+// =============================================================================
+// PATTERN 10: JSON API RESOURCES
+// =============================================================================
+
+echo "=== JSON:API Resource Pattern ===\n";
+
+/**
+ * JSON:API compliant resource wrapper
+ */
+function jsonApiResource(
+    string $type,
+    string|int $id,
+    array $attributes,
+    array $relationships = []
+): array{
+    type: string,
+    id: string,
+    attributes: array,
+    relationships: array,
+    links: array{self: string}
+} {
+    return [
+        'type' => $type,
+        'id' => (string) $id,
+        'attributes' => $attributes,
+        'relationships' => $relationships,
+        'links' => [
+            'self' => "/{$type}/{$id}"
+        ]
+    ];
+}
+
+/**
+ * JSON:API collection wrapper
+ */
+function jsonApiCollection(
+    array $resources,
+    array{page: int, per_page: int, total: int} $meta
+): array{
+    data: array,
+    meta: array{page: int, per_page: int, total: int, total_pages: int}
+} {
+    return [
+        'data' => $resources,
+        'meta' => [
+            'page' => $meta['page'],
+            'per_page' => $meta['per_page'],
+            'total' => $meta['total'],
+            'total_pages' => (int) ceil($meta['total'] / $meta['per_page'])
+        ]
+    ];
+}
+
+$userResource = jsonApiResource('users', 1, ['name' => 'Alice', 'email' => 'alice@example.com']);
+$collection = jsonApiCollection(
+    [$userResource],
+    ['page' => 1, 'per_page' => 10, 'total' => 1]
+);
+
+echo "Resource type: {$userResource['type']}, id: {$userResource['id']}\n";
+echo "Collection total: {$collection['meta']['total']}\n\n";
+
+
+echo "--- All real-world pattern examples completed successfully! ---\n";
diff --git a/examples/array-shapes/11-shape-type-aliases.php b/examples/array-shapes/11-shape-type-aliases.php
new file mode 100644
index 00000000..d5d338ce
--- /dev/null
+++ b/examples/array-shapes/11-shape-type-aliases.php
@@ -0,0 +1,209 @@
+<?php
+/**
+ * Example 11: Shape Type Aliases
+ *
+ * The `shape` keyword allows you to define reusable array structure type aliases.
+ * Shapes work similarly to typedefs or type aliases in other languages.
+ */
+declare(strict_arrays=1);
+
+echo "=== Shape Type Aliases ===\n\n";
+
+// ============================================================================
+// DEFINING SHAPES
+// ============================================================================
+
+echo "--- Defining Shapes ---\n";
+
+// Define a shape type alias for a User structure
+shape User = array{id: int, name: string, email: string};
+
+// Define a shape for a Point
+shape Point = array{x: int, y: int};
+
+// Define a shape with optional keys
+shape Config = array{debug: bool, env: string, cache_ttl?: int};
+
+// Shapes can include nullable types
+shape ApiResponse = array{success: bool, data: mixed, error: ?string};
+
+echo "Defined shapes: User, Point, Config, ApiResponse\n\n";
+
+// ============================================================================
+// USING SHAPES IN FUNCTION SIGNATURES
+// ============================================================================
+
+echo "--- Using Shapes in Functions ---\n";
+
+// Use shape as return type
+function createUser(int $id, string $name, string $email): User {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email
+    ];
+}
+
+// Use shape as parameter type
+function processUser(User $user): void {
+    echo "Processing user: {$user['name']} (ID: {$user['id']})\n";
+}
+
+// Multiple shapes in signature
+function calculateDistance(Point $a, Point $b): float {
+    $dx = $b['x'] - $a['x'];
+    $dy = $b['y'] - $a['y'];
+    return sqrt($dx * $dx + $dy * $dy);
+}
+
+$user = createUser(1, 'Alice', 'alice@example.com');
+processUser($user);
+var_dump($user);
+
+$pointA = ['x' => 0, 'y' => 0];
+$pointB = ['x' => 3, 'y' => 4];
+$distance = calculateDistance($pointA, $pointB);
+echo "Distance: $distance\n\n";
+
+// ============================================================================
+// SHAPES WITH OPTIONAL KEYS
+// ============================================================================
+
+echo "--- Shapes with Optional Keys ---\n";
+
+function getConfig(bool $useCache = false): Config {
+    $config = [
+        'debug' => true,
+        'env' => 'development'
+    ];
+
+    if ($useCache) {
+        $config['cache_ttl'] = 3600;
+    }
+
+    return $config;
+}
+
+$minimalConfig = getConfig(false);
+$fullConfig = getConfig(true);
+
+echo "Minimal config:\n";
+var_dump($minimalConfig);
+
+echo "Full config:\n";
+var_dump($fullConfig);
+echo "\n";
+
+// ============================================================================
+// SHAPES IN CLASSES
+// ============================================================================
+
+echo "--- Shapes in Classes ---\n";
+
+// Define shapes for class usage
+shape ProductData = array{id: int, name: string, price: float, stock?: int};
+
+class ProductRepository {
+    private array $products = [];
+
+    public function save(ProductData $product): void {
+        $this->products[$product['id']] = $product;
+        echo "Saved product: {$product['name']}\n";
+    }
+
+    public function find(int $id): ?ProductData {
+        return $this->products[$id] ?? null;
+    }
+
+    /** @return array<ProductData> */
+    public function all(): array {
+        return array_values($this->products);
+    }
+}
+
+$repo = new ProductRepository();
+$repo->save(['id' => 1, 'name' => 'Widget', 'price' => 29.99, 'stock' => 100]);
+$repo->save(['id' => 2, 'name' => 'Gadget', 'price' => 49.99]);
+
+$product = $repo->find(1);
+if ($product) {
+    echo "Found: {$product['name']} - \${$product['price']}\n";
+}
+echo "\n";
+
+// ============================================================================
+// NESTED SHAPES
+// ============================================================================
+
+echo "--- Nested Shapes ---\n";
+
+// Shapes can reference other shapes
+shape Address = array{street: string, city: string, zip: string};
+shape Person = array{name: string, age: int, address: Address};
+
+function describePerson(Person $person): string {
+    return sprintf(
+        "%s, age %d, lives at %s, %s %s",
+        $person['name'],
+        $person['age'],
+        $person['address']['street'],
+        $person['address']['city'],
+        $person['address']['zip']
+    );
+}
+
+$person = [
+    'name' => 'Bob',
+    'age' => 30,
+    'address' => [
+        'street' => '123 Main St',
+        'city' => 'Springfield',
+        'zip' => '12345'
+    ]
+];
+
+echo describePerson($person) . "\n\n";
+
+// ============================================================================
+// SHAPES WITH TYPED ARRAYS
+// ============================================================================
+
+echo "--- Shapes with Typed Arrays ---\n";
+
+// Shape containing typed arrays
+shape TeamData = array{
+    name: string,
+    members: array<string>,
+    scores: array<int>
+};
+
+function printTeam(TeamData $team): void {
+    echo "Team: {$team['name']}\n";
+    echo "Members: " . implode(', ', $team['members']) . "\n";
+    echo "Scores: " . implode(', ', $team['scores']) . "\n";
+}
+
+$team = [
+    'name' => 'Alpha Squad',
+    'members' => ['Alice', 'Bob', 'Charlie'],
+    'scores' => [95, 87, 92]
+];
+
+printTeam($team);
+echo "\n";
+
+// ============================================================================
+// CHECKING SHAPE EXISTENCE
+// ============================================================================
+
+echo "--- Checking Shape Existence ---\n";
+
+// Use shape_exists() to check if a shape is defined
+echo "User shape exists: " . (shape_exists('User') ? 'yes' : 'no') . "\n";
+echo "Point shape exists: " . (shape_exists('Point') ? 'yes' : 'no') . "\n";
+echo "NonExistent shape exists: " . (shape_exists('NonExistent') ? 'yes' : 'no') . "\n";
+
+// Case-insensitive check
+echo "user (lowercase) exists: " . (shape_exists('user') ? 'yes' : 'no') . "\n";
+
+echo "\n=== Example Complete ===\n";
diff --git a/examples/array-shapes/12-shape-autoloading.php b/examples/array-shapes/12-shape-autoloading.php
new file mode 100644
index 00000000..124ea968
--- /dev/null
+++ b/examples/array-shapes/12-shape-autoloading.php
@@ -0,0 +1,206 @@
+<?php
+/**
+ * Example 12: Shape Autoloading
+ *
+ * Shapes can be autoloaded just like classes using spl_autoload_register().
+ * This enables modular code organization where shapes are defined in
+ * separate files and loaded on demand.
+ */
+declare(strict_arrays=1);
+
+echo "=== Shape Autoloading ===\n\n";
+
+// ============================================================================
+// SETUP: Create temporary shape files for demonstration
+// ============================================================================
+
+$tempDir = sys_get_temp_dir() . '/php_shape_example_' . getmypid();
+if (!is_dir($tempDir)) {
+    mkdir($tempDir, 0755, true);
+}
+
+// Create shape definition files
+file_put_contents($tempDir . '/UserShape.php', '<?php
+declare(strict_arrays=1);
+shape UserShape = array{id: int, username: string, email: string, active: bool};
+');
+
+file_put_contents($tempDir . '/OrderShape.php', '<?php
+declare(strict_arrays=1);
+shape OrderShape = array{
+    id: int,
+    user_id: int,
+    items: array<array{product: string, quantity: int, price: float}>,
+    total: float,
+    status: string
+};
+');
+
+file_put_contents($tempDir . '/ApiResponseShape.php', '<?php
+declare(strict_arrays=1);
+shape ApiResponseShape = array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    meta: array{timestamp: string, version: string}
+};
+');
+
+echo "Created shape files in: $tempDir\n\n";
+
+// ============================================================================
+// AUTOLOADER REGISTRATION
+// ============================================================================
+
+echo "--- Registering Autoloader ---\n";
+
+$autoloadedShapes = [];
+
+spl_autoload_register(function($name) use ($tempDir, &$autoloadedShapes) {
+    // Check if this looks like a shape (ends with 'Shape')
+    $file = "$tempDir/$name.php";
+    if (file_exists($file)) {
+        $autoloadedShapes[] = $name;
+        echo "  Autoloading: $name from $file\n";
+        require_once $file;
+        return true;
+    }
+    return false;
+});
+
+echo "Autoloader registered.\n\n";
+
+// ============================================================================
+// USING shape_exists() WITH AUTOLOADING
+// ============================================================================
+
+echo "--- Checking Shape Existence ---\n";
+
+// Without autoload (second parameter = false)
+echo "UserShape exists (no autoload): " .
+    (shape_exists('UserShape', false) ? 'yes' : 'no') . "\n";
+
+// With autoload (default behavior)
+echo "UserShape exists (with autoload): " .
+    (shape_exists('UserShape', true) ? 'yes' : 'no') . "\n";
+
+// Now it's loaded, so no-autoload check returns true
+echo "UserShape exists (no autoload, after load): " .
+    (shape_exists('UserShape', false) ? 'yes' : 'no') . "\n\n";
+
+// ============================================================================
+// USING AUTOLOADED SHAPES
+// ============================================================================
+
+echo "--- Using Autoloaded Shapes ---\n";
+
+// Function using autoloaded UserShape
+function createUser(int $id, string $username, string $email): UserShape {
+    return [
+        'id' => $id,
+        'username' => $username,
+        'email' => $email,
+        'active' => true
+    ];
+}
+
+$user = createUser(1, 'alice', 'alice@example.com');
+echo "Created user: {$user['username']}\n";
+var_dump($user);
+echo "\n";
+
+// ============================================================================
+// COMPLEX AUTOLOADED SHAPE
+// ============================================================================
+
+echo "--- Complex Autoloaded Shape (OrderShape) ---\n";
+
+function createOrder(int $id, int $userId, array $items): OrderShape {
+    $total = array_reduce($items, function($sum, $item) {
+        return $sum + ($item['quantity'] * $item['price']);
+    }, 0.0);
+
+    return [
+        'id' => $id,
+        'user_id' => $userId,
+        'items' => $items,
+        'total' => $total,
+        'status' => 'pending'
+    ];
+}
+
+$order = createOrder(101, 1, [
+    ['product' => 'Widget', 'quantity' => 2, 'price' => 29.99],
+    ['product' => 'Gadget', 'quantity' => 1, 'price' => 49.99]
+]);
+
+echo "Created order #{$order['id']} for user #{$order['user_id']}\n";
+echo "Total: \${$order['total']}\n";
+echo "Items:\n";
+foreach ($order['items'] as $item) {
+    echo "  - {$item['quantity']}x {$item['product']} @ \${$item['price']}\n";
+}
+echo "\n";
+
+// ============================================================================
+// API RESPONSE PATTERN
+// ============================================================================
+
+echo "--- API Response Shape ---\n";
+
+function apiSuccess(mixed $data): ApiResponseShape {
+    return [
+        'success' => true,
+        'data' => $data,
+        'error' => null,
+        'meta' => [
+            'timestamp' => date('c'),
+            'version' => '1.0.0'
+        ]
+    ];
+}
+
+function apiError(string $message): ApiResponseShape {
+    return [
+        'success' => false,
+        'data' => null,
+        'error' => $message,
+        'meta' => [
+            'timestamp' => date('c'),
+            'version' => '1.0.0'
+        ]
+    ];
+}
+
+$successResponse = apiSuccess(['users' => [$user]]);
+$errorResponse = apiError('User not found');
+
+echo "Success response:\n";
+var_dump($successResponse['success'], $successResponse['error']);
+
+echo "Error response:\n";
+var_dump($errorResponse['success'], $errorResponse['error']);
+echo "\n";
+
+// ============================================================================
+// SUMMARY
+// ============================================================================
+
+echo "--- Autoload Summary ---\n";
+echo "Shapes autoloaded during this example:\n";
+foreach ($autoloadedShapes as $shape) {
+    echo "  - $shape\n";
+}
+echo "\n";
+
+// ============================================================================
+// CLEANUP
+// ============================================================================
+
+unlink($tempDir . '/UserShape.php');
+unlink($tempDir . '/OrderShape.php');
+unlink($tempDir . '/ApiResponseShape.php');
+rmdir($tempDir);
+echo "Cleaned up temporary files.\n";
+
+echo "\n=== Example Complete ===\n";
diff --git a/examples/array-shapes/README.md b/examples/array-shapes/README.md
new file mode 100644
index 00000000..5bd1f44c
--- /dev/null
+++ b/examples/array-shapes/README.md
@@ -0,0 +1,357 @@
+# Array Shape Examples
+
+This directory contains comprehensive examples demonstrating all features of PHP's array shape type syntax.
+
+## What Are Array Shapes?
+
+Array shapes allow you to define the structure of associative arrays with typed keys:
+
+```php
+declare(strict_arrays=1);
+
+function getUser(): array{id: int, name: string, email?: string} {
+    return ['id' => 1, 'name' => 'Alice'];
+}
+```
+
+## Shape Type Aliases
+
+The `shape` keyword lets you define reusable type aliases for array structures:
+
+```php
+declare(strict_arrays=1);
+
+// Define a shape type alias
+shape User = array{id: int, name: string, email: string};
+
+// Use it like a type
+function getUser(int $id): User {
+    return ['id' => $id, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+
+function processUser(User $user): void {
+    echo "Hello, {$user['name']}!";
+}
+
+// Check if a shape exists
+if (shape_exists('User')) {
+    echo "User shape is defined";
+}
+```
+
+Shapes can be autoloaded just like classes:
+
+```php
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// UserShape will be autoloaded from shapes/UserShape.php
+function getUser(): UserShape { ... }
+```
+
+## Quick Reference
+
+### Basic Syntax
+
+```php
+// Required keys
+array{key: type}
+
+// Optional keys (may be absent)
+array{key?: type}
+
+// Nullable values (key present, value can be null)
+array{key: ?type}
+
+// Multiple keys
+array{key1: type1, key2: type2, key3?: type3}
+```
+
+### Type Options
+
+```php
+// Scalar types
+array{id: int, name: string, price: float, active: bool}
+
+// Nullable types
+array{value: ?string}
+
+// Union types
+array{id: int|string, value: float|null}
+
+// Mixed type
+array{data: mixed}
+
+// Array types
+array{items: array}
+array{numbers: array<int>}
+array{users: array<array{id: int, name: string}>}
+
+// Object types
+array{user: User, admin: ?Admin}
+```
+
+### Where You Can Use Array Shapes
+
+```php
+// Return types
+function getUser(): array{id: int, name: string} { ... }
+
+// Parameter types
+function process(array{x: int, y: int} $point): void { ... }
+
+// Closures and arrow functions
+$fn = fn(): array{value: int} => ['value' => 42];
+
+// Class methods
+class UserService {
+    public function find(int $id): array{id: int, name: string} { ... }
+}
+
+// Interface methods
+interface ConfigProvider {
+    public function getConfig(): array{debug: bool, env: string};
+}
+```
+
+## Examples Index
+
+| File | Description |
+|------|-------------|
+| `01-basic-shapes.php` | Basic array shape syntax with required keys |
+| `02-optional-keys.php` | Optional keys with `key?: type` syntax |
+| `03-nested-shapes.php` | Nested array shapes for complex structures |
+| `04-union-and-nullable-types.php` | Union types and nullable values in shapes |
+| `05-shapes-with-typed-arrays.php` | Combining shapes with `array<T>` syntax |
+| `06-classes-and-interfaces.php` | Using shapes in classes, interfaces, traits |
+| `07-closures-and-callables.php` | Shapes with closures and arrow functions |
+| `08-reflection-api.php` | Runtime inspection with Reflection API |
+| `09-validation-and-errors.php` | Error handling and validation patterns |
+| `10-real-world-patterns.php` | Production-ready patterns and use cases |
+| `11-shape-type-aliases.php` | Defining reusable shapes with the `shape` keyword |
+| `12-shape-autoloading.php` | Autoloading shapes like classes |
+
+## Running Examples
+
+```bash
+# Run any example
+./sapi/cli/php examples/array-shapes/01-basic-shapes.php
+
+# Run all examples
+for f in examples/array-shapes/*.php; do echo "=== $f ==="; ./sapi/cli/php "$f"; done
+```
+
+## Key Concepts
+
+### Optional vs Nullable
+
+```php
+// Optional: key may not exist in array
+array{name: string, email?: string}
+// Valid: ['name' => 'Alice']
+// Valid: ['name' => 'Alice', 'email' => 'alice@example.com']
+
+// Nullable: key must exist but value can be null
+array{name: string, email: ?string}
+// Valid: ['name' => 'Alice', 'email' => null]
+// Valid: ['name' => 'Alice', 'email' => 'alice@example.com']
+// Invalid: ['name' => 'Alice'] - missing 'email' key
+
+// Both: key is optional, and if present can be null
+array{name: string, email?: ?string}
+```
+
+### Nested Shapes
+
+```php
+array{
+    user: array{
+        id: int,
+        profile: array{
+            name: string,
+            avatar?: string
+        }
+    },
+    settings: array{
+        theme: string,
+        notifications: bool
+    }
+}
+```
+
+### Shapes with Typed Arrays
+
+```php
+// Shape containing typed array
+array{
+    name: string,
+    tags: array<string>,
+    scores: array<int>
+}
+
+// Typed array of shapes (list of records)
+array<array{id: int, name: string}>
+
+// Keyed array of shapes (dictionary)
+array<string, array{value: mixed, type: string}>
+```
+
+## Reflection API
+
+```php
+$reflection = new ReflectionFunction('getUser');
+$returnType = $reflection->getReturnType();
+
+if ($returnType instanceof ReflectionArrayShapeType) {
+    echo "Element count: " . $returnType->getElementCount() . "\n";
+    echo "Required count: " . $returnType->getRequiredElementCount() . "\n";
+
+    foreach ($returnType->getElements() as $element) {
+        echo $element->getName() . ": " . $element->getType();
+        if ($element->isOptional()) {
+            echo " (optional)";
+        }
+        echo "\n";
+    }
+}
+```
+
+## Shape Type Alias Details
+
+### Defining Shapes
+
+```php
+// Simple shape
+shape Point = array{x: int, y: int};
+
+// Shape with optional keys
+shape Config = array{debug: bool, env: string, cache_ttl?: int};
+
+// Shape with nullable values
+shape ApiResponse = array{success: bool, data: mixed, error: ?string};
+
+// Nested shapes (shapes can reference other shapes)
+shape Address = array{street: string, city: string, zip: string};
+shape Person = array{name: string, address: Address};
+
+// Shape with typed arrays
+shape Team = array{name: string, members: array<string>, scores: array<int>};
+```
+
+### Using Shapes
+
+```php
+// As return type
+function getUser(): User { ... }
+
+// As parameter type
+function processUser(User $user): void { ... }
+
+// In classes
+class UserRepository {
+    public function find(int $id): ?User { ... }
+    public function save(User $user): void { ... }
+}
+```
+
+### Shape Autoloading
+
+Shapes can be autoloaded using `spl_autoload_register()`:
+
+```php
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+```
+
+### shape_exists() Function
+
+Check if a shape is defined:
+
+```php
+// Check without triggering autoload
+if (shape_exists('User', false)) { ... }
+
+// Check with autoloading (default)
+if (shape_exists('User')) { ... }
+
+// Case-insensitive
+shape_exists('user');  // Same as shape_exists('User')
+```
+
+## Common Patterns
+
+### API Response Wrapper
+
+```php
+function apiResponse(mixed $data, ?string $error = null): array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    timestamp: string
+} {
+    return [
+        'success' => $error === null,
+        'data' => $data,
+        'error' => $error,
+        'timestamp' => date('c')
+    ];
+}
+```
+
+### Configuration Object
+
+```php
+function getConfig(): array{
+    database: array{host: string, port: int, name: string},
+    cache: array{driver: string, ttl: int},
+    debug?: bool
+} { ... }
+```
+
+### DTO Factory
+
+```php
+function createUserDTO(
+    int $id,
+    string $name,
+    string $email
+): array{id: int, name: string, email: string, created_at: string} {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email,
+        'created_at' => date('c')
+    ];
+}
+```
+
+### Paginated Results
+
+```php
+function paginate(array $items, int $page, int $total): array{
+    data: array,
+    meta: array{page: int, total: int, has_more: bool}
+} {
+    return [
+        'data' => $items,
+        'meta' => [
+            'page' => $page,
+            'total' => $total,
+            'has_more' => count($items) < $total
+        ]
+    ];
+}
+```
+
+## Requirements
+
+- PHP 8.5+ with array shape support
+- `declare(strict_arrays=1)` for runtime validation
diff --git a/ext/opcache/zend_file_cache.c b/ext/opcache/zend_file_cache.c
index d430f483..6bd586e8 100644
--- a/ext/opcache/zend_file_cache.c
+++ b/ext/opcache/zend_file_cache.c
@@ -484,6 +484,34 @@ static void zend_file_cache_serialize_type(
 		SERIALIZE_STR(type_name);
 		ZEND_TYPE_SET_PTR(*type, type_name);
 	}
+
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		SERIALIZE_PTR(elem);
+		ZEND_TYPE_SET_PTR(*type, elem);
+		UNSERIALIZE_PTR(elem);
+		zend_file_cache_serialize_type(&elem->element_type, script, info, buf);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_file_cache_serialize_type(&elem->key_type, script, info, buf);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		SERIALIZE_PTR(shape);
+		ZEND_TYPE_SET_PTR(*type, shape);
+		UNSERIALIZE_PTR(shape);
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				SERIALIZE_STR(elem->key);
+			}
+			zend_file_cache_serialize_type(&elem->type, script, info, buf);
+		}
+	}
 }
 
 static void zend_file_cache_serialize_op_array(zend_op_array            *op_array,
@@ -1399,6 +1427,32 @@ static void zend_file_cache_unserialize_type(
 			zend_alloc_ce_cache(type_name);
 		}
 	}
+
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		UNSERIALIZE_PTR(elem);
+		ZEND_TYPE_SET_PTR(*type, elem);
+		zend_file_cache_unserialize_type(&elem->element_type, scope, script, buf);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_file_cache_unserialize_type(&elem->key_type, scope, script, buf);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		UNSERIALIZE_PTR(shape);
+		ZEND_TYPE_SET_PTR(*type, shape);
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				UNSERIALIZE_STR(elem->key);
+			}
+			zend_file_cache_unserialize_type(&elem->type, scope, script, buf);
+		}
+	}
 }
 
 static void zend_file_cache_unserialize_op_array(zend_op_array           *op_array,
diff --git a/ext/opcache/zend_persist.c b/ext/opcache/zend_persist.c
index 38e58d5a..a201117e 100644
--- a/ext/opcache/zend_persist.c
+++ b/ext/opcache/zend_persist.c
@@ -371,6 +371,40 @@ static void zend_persist_type(zend_type *type) {
 		ZEND_TYPE_SET_PTR(*type, list);
 	}
 
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		if (!zend_accel_in_shm(elem)) {
+			elem = zend_shared_memdup_put(elem, sizeof(zend_typed_array_element));
+			ZEND_TYPE_SET_PTR(*type, elem);
+		}
+		/* Recursively persist element and key types */
+		zend_persist_type(&elem->element_type);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_persist_type(&elem->key_type);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		if (!zend_accel_in_shm(shape)) {
+			size_t shape_size = sizeof(zend_array_shape)
+				+ shape->num_elements * sizeof(zend_array_shape_element);
+			shape = zend_shared_memdup_put(shape, shape_size);
+			ZEND_TYPE_SET_PTR(*type, shape);
+		}
+		/* Persist each element's key string and type */
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				zend_accel_store_interned_string(elem->key);
+			}
+			zend_persist_type(&elem->type);
+		}
+	}
+
 	zend_type *single_type;
 	ZEND_TYPE_FOREACH_MUTABLE(*type, single_type) {
 		if (ZEND_TYPE_HAS_LIST(*single_type)) {
diff --git a/ext/opcache/zend_persist_calc.c b/ext/opcache/zend_persist_calc.c
index 106a69f5..74ad1129 100644
--- a/ext/opcache/zend_persist_calc.c
+++ b/ext/opcache/zend_persist_calc.c
@@ -201,6 +201,30 @@ static void zend_persist_type_calc(zend_type *type)
 		ADD_SIZE(ZEND_TYPE_LIST_SIZE(ZEND_TYPE_LIST(*type)->num_types));
 	}
 
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		ADD_SIZE(sizeof(zend_typed_array_element));
+		zend_persist_type_calc(&elem->element_type);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_persist_type_calc(&elem->key_type);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		ADD_SIZE(sizeof(zend_array_shape) + shape->num_elements * sizeof(zend_array_shape_element));
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				ADD_INTERNED_STRING(elem->key);
+			}
+			zend_persist_type_calc(&elem->type);
+		}
+	}
+
 	zend_type *single_type;
 	ZEND_TYPE_FOREACH_MUTABLE(*type, single_type) {
 		if (ZEND_TYPE_HAS_LIST(*single_type)) {
diff --git a/ext/reflection/php_reflection.c b/ext/reflection/php_reflection.c
index 583717a6..585e7972 100644
--- a/ext/reflection/php_reflection.c
+++ b/ext/reflection/php_reflection.c
@@ -90,6 +90,9 @@ PHPAPI zend_class_entry *reflection_type_ptr;
 PHPAPI zend_class_entry *reflection_named_type_ptr;
 PHPAPI zend_class_entry *reflection_intersection_type_ptr;
 PHPAPI zend_class_entry *reflection_union_type_ptr;
+PHPAPI zend_class_entry *reflection_array_type_ptr;
+PHPAPI zend_class_entry *reflection_array_shape_type_ptr;
+PHPAPI zend_class_entry *reflection_array_shape_element_ptr;
 PHPAPI zend_class_entry *reflection_class_ptr;
 PHPAPI zend_class_entry *reflection_object_ptr;
 PHPAPI zend_class_entry *reflection_method_ptr;
@@ -159,6 +162,13 @@ typedef struct _attribute_reference {
 	uint32_t target;
 } attribute_reference;
 
+/* Struct to store array shape element reference for ReflectionArrayShapeElement */
+typedef struct _array_shape_element_reference {
+	zend_string *key;
+	zend_type type;
+	bool is_optional;
+} array_shape_element_reference;
+
 typedef enum {
 	REF_TYPE_OTHER,      /* Must be 0 */
 	REF_TYPE_FUNCTION,
@@ -168,7 +178,8 @@ typedef enum {
 	REF_TYPE_TYPE,
 	REF_TYPE_PROPERTY,
 	REF_TYPE_CLASS_CONSTANT,
-	REF_TYPE_ATTRIBUTE
+	REF_TYPE_ATTRIBUTE,
+	REF_TYPE_ARRAY_SHAPE_ELEMENT
 } reflection_type_t;
 
 /* Struct for reflection objects */
@@ -270,6 +281,12 @@ static void reflection_free_objects_storage(zend_object *object) /* {{{ */
 			efree(intern->ptr);
 			break;
 		}
+		case REF_TYPE_ARRAY_SHAPE_ELEMENT: {
+			array_shape_element_reference *elem_ref = intern->ptr;
+			zend_string_release(elem_ref->key);
+			efree(elem_ref);
+			break;
+		}
 		case REF_TYPE_GENERATOR:
 		case REF_TYPE_FIBER:
 		case REF_TYPE_CLASS_CONSTANT:
@@ -1480,7 +1497,9 @@ static void reflection_parameter_factory(zend_function *fptr, zval *closure_obje
 typedef enum {
 	NAMED_TYPE = 0,
 	UNION_TYPE = 1,
-	INTERSECTION_TYPE = 2
+	INTERSECTION_TYPE = 2,
+	ARRAY_TYPE = 3,
+	ARRAY_SHAPE_TYPE = 4
 } reflection_type_kind;
 
 /* For backwards compatibility reasons, we need to return T|null style unions
@@ -1490,6 +1509,16 @@ typedef enum {
 static reflection_type_kind get_type_kind(zend_type type) {
 	uint32_t type_mask_without_null = ZEND_TYPE_PURE_MASK_WITHOUT_NULL(type);
 
+	/* Check for array shapes (array{key: type, ...}) first */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+		return ARRAY_SHAPE_TYPE;
+	}
+
+	/* Check for typed arrays (array<T> or array<K, V>) */
+	if (ZEND_TYPE_HAS_ARRAY_ELEMENT(type)) {
+		return ARRAY_TYPE;
+	}
+
 	if (ZEND_TYPE_HAS_LIST(type)) {
 		if (ZEND_TYPE_IS_INTERSECTION(type)) {
 			return INTERSECTION_TYPE;
@@ -1537,6 +1566,12 @@ static void reflection_type_factory(zend_type type, zval *object, bool legacy_be
 		case NAMED_TYPE:
 			object_init_ex(object, reflection_named_type_ptr);
 			break;
+		case ARRAY_TYPE:
+			object_init_ex(object, reflection_array_type_ptr);
+			break;
+		case ARRAY_SHAPE_TYPE:
+			object_init_ex(object, reflection_array_shape_type_ptr);
+			break;
 		EMPTY_SWITCH_DEFAULT_CASE();
 	}
 
@@ -3262,6 +3297,188 @@ ZEND_METHOD(ReflectionIntersectionType, getTypes)
 }
 /* }}} */
 
+/* {{{ Returns the element (value) type of the typed array */
+ZEND_METHOD(ReflectionArrayType, getElementType)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_typed_array_element *elem_type;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_ELEMENT(param->type));
+	elem_type = ZEND_TYPED_ARRAY_ELEMENT(param->type);
+
+	reflection_type_factory(elem_type->element_type, return_value, 0);
+}
+/* }}} */
+
+/* {{{ Returns the key type of the typed array, or null if not specified */
+ZEND_METHOD(ReflectionArrayType, getKeyType)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_typed_array_element *elem_type;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_ELEMENT(param->type));
+	elem_type = ZEND_TYPED_ARRAY_ELEMENT(param->type);
+
+	if (!ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		RETURN_NULL();
+	}
+
+	reflection_type_factory(elem_type->key_type, return_value, 0);
+}
+/* }}} */
+
+/* {{{ Returns whether a key type was explicitly specified */
+ZEND_METHOD(ReflectionArrayType, hasKeyType)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_typed_array_element *elem_type;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_ELEMENT(param->type));
+	elem_type = ZEND_TYPED_ARRAY_ELEMENT(param->type);
+
+	RETURN_BOOL(ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type));
+}
+/* }}} */
+
+/* {{{ Returns an array of ReflectionArrayShapeElement objects */
+ZEND_METHOD(ReflectionArrayShapeType, getElements)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	array_init_size(return_value, shape->num_elements);
+
+	for (uint32_t i = 0; i < shape->num_elements; i++) {
+		const zend_array_shape_element *elem = &shape->elements[i];
+		zval element_obj;
+		reflection_object *elem_intern;
+		array_shape_element_reference *elem_ref;
+
+		object_init_ex(&element_obj, reflection_array_shape_element_ptr);
+		elem_intern = Z_REFLECTION_P(&element_obj);
+
+		elem_ref = emalloc(sizeof(array_shape_element_reference));
+		elem_ref->key = zend_string_copy(elem->key);
+		elem_ref->type = elem->type;
+		elem_ref->is_optional = elem->is_optional;
+
+		elem_intern->ptr = elem_ref;
+		elem_intern->ref_type = REF_TYPE_ARRAY_SHAPE_ELEMENT;
+
+		zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &element_obj);
+	}
+}
+/* }}} */
+
+/* {{{ Returns the number of elements in the shape */
+ZEND_METHOD(ReflectionArrayShapeType, getElementCount)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	RETURN_LONG(shape->num_elements);
+}
+/* }}} */
+
+/* {{{ Returns the number of required (non-optional) elements in the shape */
+ZEND_METHOD(ReflectionArrayShapeType, getRequiredElementCount)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	RETURN_LONG(shape->num_required);
+}
+/* }}} */
+
+/* {{{ Returns whether this is a closed shape (no extra keys allowed) */
+ZEND_METHOD(ReflectionArrayShapeType, isClosed)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	RETURN_BOOL(shape->is_closed);
+}
+/* }}} */
+
+/* {{{ Returns the key name of this array shape element */
+ZEND_METHOD(ReflectionArrayShapeElement, getName)
+{
+	reflection_object *intern;
+	array_shape_element_reference *elem_ref;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(elem_ref);
+
+	RETURN_STR_COPY(elem_ref->key);
+}
+/* }}} */
+
+/* {{{ Returns the type of this array shape element */
+ZEND_METHOD(ReflectionArrayShapeElement, getType)
+{
+	reflection_object *intern;
+	array_shape_element_reference *elem_ref;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(elem_ref);
+
+	reflection_type_factory(elem_ref->type, return_value, 0);
+}
+/* }}} */
+
+/* {{{ Returns whether this array shape element is optional */
+ZEND_METHOD(ReflectionArrayShapeElement, isOptional)
+{
+	reflection_object *intern;
+	array_shape_element_reference *elem_ref;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(elem_ref);
+
+	RETURN_BOOL(elem_ref->is_optional);
+}
+/* }}} */
+
 /* {{{ Constructor. Throws an Exception in case the given method does not exist */
 static void instantiate_reflection_method(INTERNAL_FUNCTION_PARAMETERS, bool is_constructor)
 {
@@ -7975,6 +8192,18 @@ PHP_MINIT_FUNCTION(reflection) /* {{{ */
 	reflection_intersection_type_ptr->create_object = reflection_objects_new;
 	reflection_intersection_type_ptr->default_object_handlers = &reflection_object_handlers;
 
+	reflection_array_type_ptr = register_class_ReflectionArrayType(reflection_type_ptr);
+	reflection_array_type_ptr->create_object = reflection_objects_new;
+	reflection_array_type_ptr->default_object_handlers = &reflection_object_handlers;
+
+	reflection_array_shape_type_ptr = register_class_ReflectionArrayShapeType(reflection_type_ptr);
+	reflection_array_shape_type_ptr->create_object = reflection_objects_new;
+	reflection_array_shape_type_ptr->default_object_handlers = &reflection_object_handlers;
+
+	reflection_array_shape_element_ptr = register_class_ReflectionArrayShapeElement();
+	reflection_array_shape_element_ptr->create_object = reflection_objects_new;
+	reflection_array_shape_element_ptr->default_object_handlers = &reflection_object_handlers;
+
 	reflection_method_ptr = register_class_ReflectionMethod(reflection_function_abstract_ptr);
 	reflection_method_ptr->create_object = reflection_objects_new;
 	reflection_method_ptr->default_object_handlers = &reflection_object_handlers;
diff --git a/ext/reflection/php_reflection.h b/ext/reflection/php_reflection.h
index d676597f..e5cf169d 100644
--- a/ext/reflection/php_reflection.h
+++ b/ext/reflection/php_reflection.h
@@ -35,6 +35,7 @@ extern PHPAPI zend_class_entry *reflection_function_ptr;
 extern PHPAPI zend_class_entry *reflection_parameter_ptr;
 extern PHPAPI zend_class_entry *reflection_type_ptr;
 extern PHPAPI zend_class_entry *reflection_named_type_ptr;
+extern PHPAPI zend_class_entry *reflection_array_type_ptr;
 extern PHPAPI zend_class_entry *reflection_class_ptr;
 extern PHPAPI zend_class_entry *reflection_object_ptr;
 extern PHPAPI zend_class_entry *reflection_method_ptr;
diff --git a/ext/reflection/php_reflection.stub.php b/ext/reflection/php_reflection.stub.php
index 91c70d6f..bcca2c4f 100644
--- a/ext/reflection/php_reflection.stub.php
+++ b/ext/reflection/php_reflection.stub.php
@@ -744,6 +744,47 @@ class ReflectionIntersectionType extends ReflectionType
     public function getTypes(): array {}
 }
 
+class ReflectionArrayType extends ReflectionType
+{
+    /** Get the element (value) type of the array */
+    public function getElementType(): ReflectionType {}
+
+    /** Get the key type of the array, or null if not specified */
+    public function getKeyType(): ?ReflectionType {}
+
+    /** Check if a key type was explicitly specified */
+    public function hasKeyType(): bool {}
+}
+
+/** Represents an array shape type like array{name: string, age?: int} */
+class ReflectionArrayShapeType extends ReflectionType
+{
+    /** Get the elements defined in the shape */
+    public function getElements(): array {}
+
+    /** Get the number of elements in the shape */
+    public function getElementCount(): int {}
+
+    /** Get the number of required (non-optional) elements */
+    public function getRequiredElementCount(): int {}
+
+    /** Check if this is a closed shape (no extra keys allowed) */
+    public function isClosed(): bool {}
+}
+
+/** Represents an element in an array shape type */
+class ReflectionArrayShapeElement
+{
+    /** Get the key name */
+    public function getName(): string {}
+
+    /** Get the type of this element */
+    public function getType(): ReflectionType {}
+
+    /** Check if this element is optional */
+    public function isOptional(): bool {}
+}
+
 /** @not-serializable */
 class ReflectionExtension implements Reflector
 {
diff --git a/ext/reflection/php_reflection_arginfo.h b/ext/reflection/php_reflection_arginfo.h
index bee9cbfc..32e9589d 100644
Binary files a/ext/reflection/php_reflection_arginfo.h and b/ext/reflection/php_reflection_arginfo.h differ
diff --git a/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt b/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt
index 8ba243a5..dc32bbda 100644
--- a/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt
+++ b/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt
@@ -8,7 +8,7 @@
 var_dump($ext->getClasses());
 ?>
 --EXPECTF--
-array(26) {
+array(29) {
   ["ReflectionException"]=>
   object(ReflectionClass)#%d (1) {
     ["name"]=>
@@ -64,6 +64,21 @@
     ["name"]=>
     string(26) "ReflectionIntersectionType"
   }
+  ["ReflectionArrayType"]=>
+  object(ReflectionClass)#%d (1) {
+    ["name"]=>
+    string(19) "ReflectionArrayType"
+  }
+  ["ReflectionArrayShapeType"]=>
+  object(ReflectionClass)#%d (1) {
+    ["name"]=>
+    string(24) "ReflectionArrayShapeType"
+  }
+  ["ReflectionArrayShapeElement"]=>
+  object(ReflectionClass)#%d (1) {
+    ["name"]=>
+    string(27) "ReflectionArrayShapeElement"
+  }
   ["ReflectionMethod"]=>
   object(ReflectionClass)#%d (1) {
     ["name"]=>
diff --git a/ext/tokenizer/tokenizer_data.c b/ext/tokenizer/tokenizer_data.c
index 0900c51d..61b9acf1 100644
--- a/ext/tokenizer/tokenizer_data.c
+++ b/ext/tokenizer/tokenizer_data.c
@@ -105,11 +105,13 @@ char *get_token_type_name(int token_type)
 		case T_TRAIT: return "T_TRAIT";
 		case T_INTERFACE: return "T_INTERFACE";
 		case T_ENUM: return "T_ENUM";
+		case T_SHAPE: return "T_SHAPE";
 		case T_EXTENDS: return "T_EXTENDS";
 		case T_IMPLEMENTS: return "T_IMPLEMENTS";
 		case T_NAMESPACE: return "T_NAMESPACE";
 		case T_LIST: return "T_LIST";
 		case T_ARRAY: return "T_ARRAY";
+		case T_ARRAY_SHAPE_START: return "T_ARRAY_SHAPE_START";
 		case T_CALLABLE: return "T_CALLABLE";
 		case T_LINE: return "T_LINE";
 		case T_FILE: return "T_FILE";
diff --git a/ext/tokenizer/tokenizer_data.stub.php b/ext/tokenizer/tokenizer_data.stub.php
index 57c8edad..07ba208f 100644
--- a/ext/tokenizer/tokenizer_data.stub.php
+++ b/ext/tokenizer/tokenizer_data.stub.php
@@ -402,6 +402,11 @@
  * @cvalue T_ENUM
  */
 const T_ENUM = UNKNOWN;
+/**
+ * @var int
+ * @cvalue T_SHAPE
+ */
+const T_SHAPE = UNKNOWN;
 /**
  * @var int
  * @cvalue T_EXTENDS
@@ -427,6 +432,11 @@
  * @cvalue T_ARRAY
  */
 const T_ARRAY = UNKNOWN;
+/**
+ * @var int
+ * @cvalue T_ARRAY_SHAPE_START
+ */
+const T_ARRAY_SHAPE_START = UNKNOWN;
 /**
  * @var int
  * @cvalue T_CALLABLE
diff --git a/ext/tokenizer/tokenizer_data_arginfo.h b/ext/tokenizer/tokenizer_data_arginfo.h
index 3a3cdaa4..90d409f0 100644
Binary files a/ext/tokenizer/tokenizer_data_arginfo.h and b/ext/tokenizer/tokenizer_data_arginfo.h differ
