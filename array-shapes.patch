diff --git a/Zend/zend_execute.c b/Zend/zend_execute.c
index a4b29b60..8bc38d17 100644
--- a/Zend/zend_execute.c
+++ b/Zend/zend_execute.c
@@ -2460,23 +2460,25 @@ static zend_always_inline zend_shape_check_result zend_check_array_shape(
 	/* For closed shapes, check that no extra keys exist */
 	if (UNEXPECTED(shape->is_closed)) {
 		if (zend_hash_num_elements(ht) != shape->num_elements) {
+			/* Build a temporary hash set of expected keys for O(1) lookup.
+			 * This optimizes from O(n*m) to O(n+m) where n = array keys, m = shape elements */
+			HashTable expected_keys;
+			zend_hash_init(&expected_keys, shape->num_elements, NULL, NULL, 0);
+			for (uint32_t i = 0; i < shape->num_elements; i++) {
+				zend_hash_add_empty_element(&expected_keys, shape->elements[i].key);
+			}
+
 			/* Find the first extra key for error message */
 			zend_string *key;
 			ZEND_HASH_FOREACH_STR_KEY(ht, key) {
-				if (key) {
-					bool found = false;
-					for (uint32_t i = 0; i < shape->num_elements; i++) {
-						if (zend_string_equals(key, shape->elements[i].key)) {
-							found = true;
-							break;
-						}
-					}
-					if (!found) {
-						*extra_key = key;
-						return SHAPE_EXTRA_KEY;
-					}
+				if (key && !zend_hash_exists(&expected_keys, key)) {
+					*extra_key = key;
+					zend_hash_destroy(&expected_keys);
+					return SHAPE_EXTRA_KEY;
 				}
 			} ZEND_HASH_FOREACH_END();
+
+			zend_hash_destroy(&expected_keys);
 		}
 	}
 
@@ -2616,9 +2618,21 @@ ZEND_API bool zend_verify_array_prop_shape(
 
 /* ZEND_SHAPE_MAX_RECURSION_DEPTH is defined in zend_compile.h */
 
-/* Thread-local recursion depth counter for shape validation */
+/* Thread-local recursion depth counter for shape validation.
+ * SAFETY: This counter is incremented before validation and decremented after.
+ * The code between increment and decrement must NOT throw exceptions or longjmp.
+ * Currently safe because: zend_check_array_shape, zend_check_type, and hash
+ * iteration all return values rather than throwing. If future modifications
+ * add exception-throwing code, use zend_try/zend_catch for cleanup. */
 ZEND_TLS int zend_shape_recursion_depth = 0;
 
+/* Reset shape recursion depth - called at request startup as defensive measure */
+ZEND_API void zend_reset_shape_recursion_depth(void)
+{
+	zend_shape_recursion_depth = 0;
+	zend_typed_array_recursion_depth = 0;
+}
+
 /* Check if a type name is actually a shape and validate accordingly */
 static bool zend_check_shape_type(const zend_type *type, zval *arg, bool is_return_type ZEND_ATTRIBUTE_UNUSED)
 {
@@ -2626,7 +2640,8 @@ static bool zend_check_shape_type(const zend_type *type, zval *arg, bool is_retu
 		return false;
 	}
 
-	/* Check for excessive recursion depth (circular shape references) */
+	/* Check for excessive recursion depth (circular shape references).
+	 * This check happens BEFORE incrementing to avoid counter imbalance on error. */
 	if (UNEXPECTED(zend_shape_recursion_depth >= ZEND_SHAPE_MAX_RECURSION_DEPTH)) {
 		zend_error_noreturn(E_ERROR,
 			"Maximum shape nesting level of %d exceeded, possible circular reference",
@@ -2645,7 +2660,8 @@ static bool zend_check_shape_type(const zend_type *type, zval *arg, bool is_retu
 		return false;  /* Shapes require arrays */
 	}
 
-	/* Track recursion depth to detect circular references */
+	/* Track recursion depth to detect circular references.
+	 * All code paths after this MUST go through 'done' label to decrement. */
 	zend_shape_recursion_depth++;
 	bool result = false;
 
diff --git a/Zend/zend_execute.h b/Zend/zend_execute.h
index f2808903..a3d6cfb9 100644
--- a/Zend/zend_execute.h
+++ b/Zend/zend_execute.h
@@ -52,6 +52,7 @@ ZEND_API bool zend_is_valid_class_name(zend_string *name);
 ZEND_API zend_class_entry *zend_lookup_class(zend_string *name);
 ZEND_API zend_class_entry *zend_lookup_class_ex(zend_string *name, zend_string *lcname, uint32_t flags);
 ZEND_API zend_shape_entry *zend_lookup_shape(zend_string *name);
+ZEND_API void zend_reset_shape_recursion_depth(void);
 ZEND_API zend_shape_entry *zend_lookup_shape_ex(zend_string *name, zend_string *lcname, uint32_t flags);
 ZEND_API zend_class_entry *zend_get_called_scope(zend_execute_data *ex);
 ZEND_API zend_object *zend_get_this_object(zend_execute_data *ex);
diff --git a/Zend/zend_execute_API.c b/Zend/zend_execute_API.c
index 14849046..a3102216 100644
--- a/Zend/zend_execute_API.c
+++ b/Zend/zend_execute_API.c
@@ -129,6 +129,9 @@ void init_executor(void) /* {{{ */
 {
 	zend_init_fpu();
 
+	/* Reset shape/typed array recursion counters (defensive measure) */
+	zend_reset_shape_recursion_depth();
+
 	ZVAL_NULL(&EG(uninitialized_zval));
 	ZVAL_ERROR(&EG(error_zval));
 /* destroys stack frame, therefore makes core dumps worthless */
diff --git a/Zend/zend_opcode.c b/Zend/zend_opcode.c
index f3631104..036da43e 100644
--- a/Zend/zend_opcode.c
+++ b/Zend/zend_opcode.c
@@ -121,6 +121,12 @@ ZEND_API void zend_type_release(zend_type type, bool persistent) {
 	} else if (ZEND_TYPE_HAS_NAME(type)) {
 		zend_string_release(ZEND_TYPE_NAME(type));
 	}
+	/* Note: Array shapes and typed arrays are NOT freed here.
+	 * They are either:
+	 * 1. Arena-allocated (inline shapes like array{x: int}) - freed by arena cleanup
+	 * 2. Shape-table-owned (named shapes like MyShape) - freed by zend_shape_dtor
+	 * Freeing here would cause double-free since function arg_info shares
+	 * the same pointer as shape table entries for named shapes. */
 }
 
 void zend_free_internal_arg_info(zend_internal_function *function) {
