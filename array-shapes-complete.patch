diff --git a/README.md b/README.md
index 5b8ec6f0..fabe5902 100644
--- a/README.md
+++ b/README.md
@@ -14,6 +14,78 @@ web development. Fast, flexible and pragmatic, PHP powers everything from your
 blog to the most popular websites in the world. PHP is distributed under the
 [PHP License v3.01](LICENSE).
 
+---
+
+## Array Shape Return Types (RFC Implementation)
+
+This fork implements **Array Shape Return Types** for PHP, allowing you to specify
+element types for array return values using the `array<T>` syntax.
+
+### Features
+
+- **Basic typed arrays**: `array<int>`, `array<string>`, `array<float>`, `array<bool>`
+- **Object typed arrays**: `array<MyClass>`, `array<DateTime>`
+- **Union types**: `array<int|string>`, `array<MyClass|OtherClass|int>`
+- **Nested arrays**: `array<array<int>>`, `array<array<array<string>>>` (up to 4 levels)
+- **Compile-time validation** for constant arrays (escape analysis optimization)
+- **Runtime validation** with detailed error messages
+
+### Usage
+
+Enable strict array checking with the `strict_arrays` declare:
+
+```php
+<?php
+declare(strict_arrays=1);
+
+// Basic typed array
+function getIds(): array<int> {
+    return [1, 2, 3];
+}
+
+// Union types
+function getValues(): array<int|string> {
+    return [1, "two", 3];
+}
+
+// Object types
+function getUsers(): array<User> {
+    return [new User("Alice"), new User("Bob")];
+}
+
+// Nested arrays (matrix)
+function getMatrix(): array<array<int>> {
+    return [[1, 2], [3, 4], [5, 6]];
+}
+
+// Mixed union with objects
+function getItems(): array<Product|Service|int> {
+    return [new Product(), 42, new Service()];
+}
+```
+
+### Error Handling
+
+When validation fails, a `TypeError` is thrown with details about the failing element:
+
+```php
+function getInts(): array<int> {
+    return [1, "two", 3];  // TypeError: array element at index 1 is string
+}
+```
+
+### Implementation Status
+
+- [x] Parser support for `array<T>` syntax
+- [x] Single type validation (`array<int>`, `array<string>`, etc.)
+- [x] Object/class type validation (`array<MyClass>`)
+- [x] Union type support (`array<int|string|MyClass>`)
+- [x] Nested array support (`array<array<T>>`)
+- [x] Compile-time escape analysis optimization
+- [x] Runtime validation with error reporting
+
+---
+
 [![Push](https://github.com/php/php-src/actions/workflows/push.yml/badge.svg)](https://github.com/php/php-src/actions/workflows/push.yml)
 [![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/php.svg)](https://issues.oss-fuzz.com/issues?q=project:php)
 
diff --git a/Zend/zend_ast.h b/Zend/zend_ast.h
index fb48b187..5b60d0df 100644
--- a/Zend/zend_ast.h
+++ b/Zend/zend_ast.h
@@ -70,6 +70,7 @@ enum _zend_ast_kind {
 	ZEND_AST_ATTRIBUTE_GROUP,
 	ZEND_AST_MATCH_ARM_LIST,
 	ZEND_AST_MODIFIER_LIST,
+	ZEND_AST_SHAPE_ELEMENT_LIST,
 
 	/* 0 child nodes */
 	ZEND_AST_MAGIC_CONST = 0 << ZEND_AST_NUM_CHILDREN_SHIFT,
@@ -80,6 +81,8 @@ enum _zend_ast_kind {
 	/* 1 child node */
 	ZEND_AST_VAR = 1 << ZEND_AST_NUM_CHILDREN_SHIFT,
 	ZEND_AST_CONST,
+	ZEND_AST_TYPE_ARRAY_OF,
+	ZEND_AST_TYPE_ARRAY_SHAPE,
 	ZEND_AST_UNPACK,
 	ZEND_AST_UNARY_PLUS,
 	ZEND_AST_UNARY_MINUS,
@@ -115,6 +118,8 @@ enum _zend_ast_kind {
 	/* 2 child nodes */
 	ZEND_AST_DIM = 2 << ZEND_AST_NUM_CHILDREN_SHIFT,
 	ZEND_AST_PROP,
+	ZEND_AST_SHAPE_ELEMENT,
+	ZEND_AST_TYPE_ARRAY_MAP,
 	ZEND_AST_NULLSAFE_PROP,
 	ZEND_AST_STATIC_PROP,
 	ZEND_AST_CALL,
diff --git a/Zend/zend_compile.c b/Zend/zend_compile.c
index 8be1ee14..cf995f7d 100644
--- a/Zend/zend_compile.c
+++ b/Zend/zend_compile.c
@@ -2617,6 +2617,83 @@ static void zend_compile_memoized_expr(znode *result, zend_ast *expr) /* {{{ */
 }
 /* }}} */
 
+/* Forward declaration for recursive compile-time array validation */
+static bool zend_const_array_elements_match_type(zval *arr, const zend_type *element_type);
+
+/* Check if a constant value matches a type at compile time (for escape analysis) */
+static bool zend_const_value_matches_type(zval *val, const zend_type *type)
+{
+	uint32_t type_mask = ZEND_TYPE_PURE_MASK(*type);
+	uint8_t val_type = Z_TYPE_P(val);
+
+	/* Handle nested array types: array<T> where T might be another array<U> */
+	if (ZEND_TYPE_HAS_ARRAY_ELEMENT(*type)) {
+		/* This type is array<T> - value must be an array with matching elements */
+		if (val_type != IS_ARRAY) {
+			return false;
+		}
+		/* Recursively validate inner elements */
+		const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		return zend_const_array_elements_match_type(val, &elem_type->element_type);
+	}
+
+	/* Check simple type masks */
+	if (type_mask & (1u << val_type)) {
+		return true;
+	}
+
+	/* Special case: int can match float type */
+	if ((type_mask & MAY_BE_DOUBLE) && val_type == IS_LONG) {
+		return true;
+	}
+
+	/* Special case: bool matches both TRUE and FALSE */
+	if ((type_mask & MAY_BE_BOOL) && (val_type == IS_TRUE || val_type == IS_FALSE)) {
+		return true;
+	}
+
+	/* Can't verify object/class types at compile time */
+	if (ZEND_TYPE_HAS_NAME(*type) || ZEND_TYPE_HAS_LIST(*type)) {
+		/* Check if it's a union of simple types only */
+		if (ZEND_TYPE_HAS_LIST(*type)) {
+			const zend_type_list *list = ZEND_TYPE_LIST(*type);
+			/* Check each type in the union */
+			for (uint32_t i = 0; i < list->num_types; i++) {
+				const zend_type *single = &list->types[i];
+				/* If any type in union is a class, we can't verify at compile time */
+				if (ZEND_TYPE_HAS_NAME(*single)) {
+					return false;
+				}
+			}
+			/* All types in union are simple - check if value matches any */
+			return (type_mask & (1u << val_type)) ||
+			       ((type_mask & MAY_BE_DOUBLE) && val_type == IS_LONG) ||
+			       ((type_mask & MAY_BE_BOOL) && (val_type == IS_TRUE || val_type == IS_FALSE));
+		}
+		return false;
+	}
+
+	return false;
+}
+
+/* Check if a constant array's elements all match the expected type (compile-time escape analysis) */
+static bool zend_const_array_elements_match_type(zval *arr, const zend_type *element_type)
+{
+	zval *val;
+
+	/* Can't verify object/class types at compile time (unless it's a union of scalars) */
+	if (ZEND_TYPE_HAS_NAME(*element_type)) {
+		return false;
+	}
+
+	ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(arr), val) {
+		if (!zend_const_value_matches_type(val, element_type)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
 static void zend_emit_return_type_check(
 		znode *expr, zend_arg_info *return_info, bool implicit) /* {{{ */
 {
@@ -2669,8 +2746,21 @@ static void zend_emit_return_type_check(
 		}
 
 		if (expr && expr->op_type == IS_CONST && ZEND_TYPE_CONTAINS_CODE(type, Z_TYPE(expr->u.constant))) {
-			/* we don't need run-time check */
-			return;
+			/* we don't need run-time check, unless we have array element type info or shape to validate */
+			if (!ZEND_TYPE_HAS_ARRAY_ELEMENT(type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+				return;
+			}
+			/* Escape analysis: if constant array elements all match the type, skip runtime check */
+			/* Note: Only apply escape analysis to array<T> types, not array shapes */
+			if (Z_TYPE(expr->u.constant) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(type)) {
+				const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(type);
+				if (elem_type) {
+					/* Try to verify at compile time (works for primitive types and unions of primitives) */
+					if (zend_const_array_elements_match_type(&expr->u.constant, &elem_type->element_type)) {
+						return; /* All elements match - no runtime check needed */
+					}
+				}
+			}
 		}
 
 		opline = zend_emit_op(NULL, ZEND_VERIFY_RETURN_TYPE, expr, NULL);
@@ -7028,6 +7118,29 @@ static void zend_compile_declare(zend_ast *ast) /* {{{ */
 				CG(active_op_array)->fn_flags |= ZEND_ACC_STRICT_TYPES;
 			}
 
+		} else if (zend_string_equals_literal_ci(name, "strict_arrays")) {
+			zval value_zv;
+
+			if (FAILURE == zend_is_first_statement(ast, /* allow_nop */ true)) {
+				zend_error_noreturn(E_COMPILE_ERROR, "strict_arrays declaration must be "
+					"the very first statement in the script");
+			}
+
+			if (ast->child[1] != NULL) {
+				zend_error_noreturn(E_COMPILE_ERROR, "strict_arrays declaration must not "
+					"use block mode");
+			}
+
+			zend_const_expr_to_zval(&value_zv, value_ast_ptr, /* allow_dynamic */ false);
+
+			if (Z_TYPE(value_zv) != IS_LONG || (Z_LVAL(value_zv) != 0 && Z_LVAL(value_zv) != 1)) {
+				zend_error_noreturn(E_COMPILE_ERROR, "strict_arrays declaration must have 0 or 1 as its value");
+			}
+
+			if (Z_LVAL(value_zv) == 1) {
+				CG(active_op_array)->fn_flags |= ZEND_ACC_STRICT_ARRAYS;
+			}
+
 		} else {
 			zend_error(E_COMPILE_WARNING, "Unsupported declare '%s'", ZSTR_VAL(name));
 		}
@@ -7076,6 +7189,9 @@ ZEND_API void zend_set_function_arg_flags(zend_function *func) /* {{{ */
 }
 /* }}} */
 
+/* Forward declaration for recursive type compilation */
+static zend_type zend_compile_typename(zend_ast *ast);
+
 static zend_type zend_compile_single_typename(zend_ast *ast)
 {
 	ZEND_ASSERT(!(ast->attr & ZEND_TYPE_NULLABLE));
@@ -7086,6 +7202,80 @@ static zend_type zend_compile_single_typename(zend_ast *ast)
 		}
 
 		return (zend_type) ZEND_TYPE_INIT_CODE(ast->attr, 0, 0);
+	} else if (ast->kind == ZEND_AST_TYPE_ARRAY_OF) {
+		/* array<T> syntax - store element type info (supports unions, intersections) */
+		zend_ast *element_type_ast = ast->child[0];
+		zend_typed_array_element *elem_type = zend_arena_alloc(&CG(arena), sizeof(zend_typed_array_element));
+
+		/* Use zend_compile_typename to handle all type kinds including unions */
+		elem_type->element_type = zend_compile_typename(element_type_ast);
+		/* No key type constraint - initialize to empty */
+		elem_type->key_type = (zend_type) ZEND_TYPE_INIT_NONE(0);
+
+		zend_type type;
+		type.type_mask = (1u << IS_ARRAY);
+		type.ptr = elem_type;
+		return type;
+	} else if (ast->kind == ZEND_AST_TYPE_ARRAY_MAP) {
+		/* array<K, V> syntax - store both key and value type info */
+		zend_ast *key_type_ast = ast->child[0];
+		zend_ast *value_type_ast = ast->child[1];
+		zend_typed_array_element *elem_type = zend_arena_alloc(&CG(arena), sizeof(zend_typed_array_element));
+
+		/* Compile key type - only int, string, or int|string allowed */
+		zend_type key_type = zend_compile_typename(key_type_ast);
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(key_type);
+
+		/* Validate key type - must be int, string, or int|string */
+		if (!ZEND_TYPE_IS_ONLY_MASK(key_type) ||
+		    (key_mask != MAY_BE_LONG && key_mask != MAY_BE_STRING &&
+		     key_mask != (MAY_BE_LONG | MAY_BE_STRING))) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Array key type must be int, string, or int|string");
+		}
+
+		elem_type->key_type = key_type;
+		elem_type->element_type = zend_compile_typename(value_type_ast);
+
+		zend_type type;
+		type.type_mask = (1u << IS_ARRAY);
+		type.ptr = elem_type;
+		return type;
+	} else if (ast->kind == ZEND_AST_TYPE_ARRAY_SHAPE) {
+		/* array{key: type, key?: type, ...} syntax */
+		zend_ast *element_list = ast->child[0];
+		uint32_t num_elements = element_list ? zend_ast_get_list(element_list)->children : 0;
+		uint32_t num_required = 0;
+
+		/* Allocate shape structure with flexible array member */
+		size_t shape_size = sizeof(zend_array_shape) + num_elements * sizeof(zend_array_shape_element);
+		zend_array_shape *shape = zend_arena_alloc(&CG(arena), shape_size);
+		shape->num_elements = num_elements;
+
+		/* Compile each shape element */
+		if (element_list) {
+			zend_ast_list *list = zend_ast_get_list(element_list);
+			for (uint32_t i = 0; i < num_elements; i++) {
+				zend_ast *elem_ast = list->child[i];
+				zend_ast *key_ast = elem_ast->child[0];
+				zend_ast *type_ast = elem_ast->child[1];
+				bool is_optional = (elem_ast->attr != 0);
+
+				shape->elements[i].key = zend_string_copy(zend_ast_get_str(key_ast));
+				shape->elements[i].type = zend_compile_typename(type_ast);
+				shape->elements[i].is_optional = is_optional;
+
+				if (!is_optional) {
+					num_required++;
+				}
+			}
+		}
+		shape->num_required = num_required;
+
+		zend_type type;
+		type.type_mask = (1u << IS_ARRAY) | _ZEND_TYPE_ARRAY_SHAPE_BIT;
+		type.ptr = shape;
+		return type;
 	} else {
 		zend_string *type_name = zend_ast_get_str(ast);
 		uint8_t type_code = zend_lookup_builtin_type_by_name(type_name);
@@ -8460,6 +8650,7 @@ static zend_op_array *zend_compile_func_decl_ex(
 	}
 
 	op_array->fn_flags |= (orig_op_array->fn_flags & ZEND_ACC_STRICT_TYPES);
+	op_array->fn_flags |= (orig_op_array->fn_flags & ZEND_ACC_STRICT_ARRAYS);
 	op_array->fn_flags |= decl->flags;
 	op_array->line_start = decl->start_lineno;
 	op_array->line_end = decl->end_lineno;
diff --git a/Zend/zend_compile.h b/Zend/zend_compile.h
index c07fa9bf..3bb612c8 100644
--- a/Zend/zend_compile.h
+++ b/Zend/zend_compile.h
@@ -107,6 +107,46 @@ typedef struct _zend_declarables {
 	zend_long ticks;
 } zend_declarables;
 
+/* Array element type info for array<T> and array<K, V> syntax */
+typedef struct _zend_typed_array_element {
+	zend_type element_type;  /* Value type info - supports unions, intersections, classes */
+	zend_type key_type;      /* Key type (int, string, or int|string) - if unset, any key allowed */
+} zend_typed_array_element;
+
+/* Check if key type is specified */
+#define ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem) \
+	(ZEND_TYPE_IS_SET((elem)->key_type))
+
+#define ZEND_TYPED_ARRAY_ELEMENT(t) \
+	((zend_typed_array_element *) (t).ptr)
+
+/* Helper to get simple type code (for caching optimization) */
+#define ZEND_TYPED_ARRAY_SIMPLE_TYPE(elem) \
+	(ZEND_TYPE_IS_ONLY_MASK((elem)->element_type) ? \
+		(uint8_t)ZEND_TYPE_PURE_MASK((elem)->element_type) : 0)
+
+/* Array shape element for array{key: type, key?: type} syntax */
+typedef struct _zend_array_shape_element {
+	zend_string *key;        /* Key name */
+	zend_type type;          /* Value type */
+	bool is_optional;        /* Whether this key is optional (key?: type) */
+} zend_array_shape_element;
+
+/* Array shape info for array{...} syntax */
+typedef struct _zend_array_shape {
+	uint32_t num_elements;               /* Number of shape elements */
+	uint32_t num_required;               /* Number of required (non-optional) elements */
+	zend_array_shape_element elements[]; /* Flexible array member */
+} zend_array_shape;
+
+/* Check if type has array shape */
+#define ZEND_TYPE_HAS_ARRAY_SHAPE(t) \
+	(((t).type_mask & _ZEND_TYPE_ARRAY_SHAPE_BIT) != 0)
+
+/* Get array shape from type */
+#define ZEND_ARRAY_SHAPE(t) \
+	((zend_array_shape *) (t).ptr)
+
 /* Compilation context that is different for each file, but shared between op arrays. */
 typedef struct _zend_file_context {
 	zend_declarables declarables;
@@ -407,6 +447,9 @@ typedef struct _zend_oparray_context {
 /*                                                        |     |     |     */
 /* op_array uses strict mode types                        |     |     |     */
 #define ZEND_ACC_STRICT_TYPES            (1U << 31) /*    |  X  |     |     */
+/*                                                        |     |     |     */
+/* op_array uses strict array element types               |     |     |     */
+#define ZEND_ACC_STRICT_ARRAYS           (1U << 30) /*    |  X  |     |     */
 
 #define ZEND_ACC_PPP_MASK  (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)
 #define ZEND_ACC_PPP_SET_MASK  (ZEND_ACC_PUBLIC_SET | ZEND_ACC_PROTECTED_SET | ZEND_ACC_PRIVATE_SET)
@@ -719,6 +762,15 @@ ZEND_STATIC_ASSERT(ZEND_MM_ALIGNED_SIZE(sizeof(zval)) == sizeof(zval),
 #define EX_USES_STRICT_TYPES() \
 	ZEND_CALL_USES_STRICT_TYPES(execute_data)
 
+#define ZEND_CALL_USES_STRICT_ARRAYS(call) \
+	(((call)->func->common.fn_flags & ZEND_ACC_STRICT_ARRAYS) != 0)
+
+#define EX_USES_STRICT_ARRAYS() \
+	ZEND_CALL_USES_STRICT_ARRAYS(execute_data)
+
+#define ZEND_RET_USES_STRICT_ARRAYS() \
+	ZEND_CALL_USES_STRICT_ARRAYS(EG(current_execute_data))
+
 #define ZEND_ARG_USES_STRICT_TYPES() \
 	(EG(current_execute_data)->prev_execute_data && \
 	 EG(current_execute_data)->prev_execute_data->func && \
diff --git a/Zend/zend_execute.c b/Zend/zend_execute.c
index 5665cc0c..b7844638 100644
--- a/Zend/zend_execute.c
+++ b/Zend/zend_execute.c
@@ -1091,6 +1091,15 @@ static zend_never_inline zval* zend_assign_to_typed_prop(const zend_property_inf
 		return &EG(uninitialized_zval);
 	}
 
+	/* Check array element types if strict_arrays is enabled */
+	if (EX_USES_STRICT_ARRAYS() && Z_TYPE(tmp) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(info->type)) {
+		zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(info->type);
+		if (!zend_verify_array_prop_element_types(info, &tmp, elem_type)) {
+			zval_ptr_dtor(&tmp);
+			return &EG(uninitialized_zval);
+		}
+	}
+
 	Z_PROP_FLAG_P(property_val) &= ~IS_PROP_REINITABLE;
 
 	return zend_assign_to_variable_ex(property_val, &tmp, IS_TMP_VAR, EX_USES_STRICT_TYPES(), garbage_ptr);
@@ -1434,6 +1443,894 @@ ZEND_API ZEND_COLD void zend_verify_return_error(const zend_function *zf, const
 	zend_string_release(need_msg);
 }
 
+/* Array element type validation for array<T> with strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_element_type_error(
+	const zend_function *zf, zend_long index, const zval *element,
+	const char *expected_type, const char *actual_type)
+{
+	const char *fname = ZSTR_VAL(zf->common.function_name);
+	const char *fsep = zf->common.scope ? "::" : "";
+	const char *fclass = zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "";
+
+	zend_type_error("%s%s%s(): Return value must be of type array<%s>, "
+		"array element at index " ZEND_LONG_FMT " is %s",
+		fclass, fsep, fname, expected_type, index, actual_type);
+}
+
+/* Array element type validation for argument with array<T> and strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_arg_element_type_error(
+	const zend_function *zf, uint32_t arg_num, zend_long index, const zval *element,
+	const char *expected_type, const char *actual_type)
+{
+	zend_argument_type_error(arg_num,
+		"must be of type array<%s>, array element at index " ZEND_LONG_FMT " is %s",
+		expected_type, index, actual_type);
+}
+
+/* Array element type validation for property with array<T> and strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_prop_element_type_error(
+	const zend_property_info *info, zend_long index, const zval *element,
+	const char *expected_type, const char *actual_type)
+{
+	zend_type_error("Cannot assign to property %s::$%s of type array<%s>, "
+		"array element at index " ZEND_LONG_FMT " is %s",
+		ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name), expected_type,
+		index, actual_type);
+}
+
+/* Array key type validation errors for array<K, V> with strict_arrays */
+ZEND_API ZEND_COLD void zend_verify_array_key_type_error(
+	const zend_function *zf, const char *expected_key_type, const char *actual_key_type)
+{
+	const char *fname = ZSTR_VAL(zf->common.function_name);
+	const char *fsep = zf->common.scope ? "::" : "";
+	const char *fclass = zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "";
+
+	zend_type_error("%s%s%s(): Return value must be of type array<%s, ...>, "
+		"array contains %s key",
+		fclass, fsep, fname, expected_key_type, actual_key_type);
+}
+
+ZEND_API ZEND_COLD void zend_verify_array_arg_key_type_error(
+	uint32_t arg_num, const char *expected_key_type, const char *actual_key_type)
+{
+	zend_argument_type_error(arg_num,
+		"must be of type array<%s, ...>, array contains %s key",
+		expected_key_type, actual_key_type);
+}
+
+ZEND_API ZEND_COLD void zend_verify_array_prop_key_type_error(
+	const zend_property_info *info, const char *expected_key_type, const char *actual_key_type)
+{
+	zend_type_error("Cannot assign to property %s::$%s of type array<%s, ...>, "
+		"array contains %s key",
+		ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name), expected_key_type, actual_key_type);
+}
+
+/* Key type validation helper - returns true if all keys match expected type */
+static zend_always_inline bool zend_verify_array_key_types(
+	HashTable *ht, uint32_t expected_key_mask)
+{
+	zend_string *str_key;
+	zend_ulong num_key;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* int|string accepts any key */
+	if (expected_key_mask == (MAY_BE_LONG | MAY_BE_STRING)) {
+		return true;
+	}
+
+	bool expects_int = (expected_key_mask == MAY_BE_LONG);
+
+	ZEND_HASH_FOREACH_KEY(ht, num_key, str_key) {
+		if (expects_int) {
+			if (str_key != NULL) {
+				return false;  /* Found string key when expecting int */
+			}
+		} else {
+			/* expects_string */
+			if (str_key == NULL) {
+				return false;  /* Found int key when expecting string */
+			}
+		}
+	} ZEND_HASH_FOREACH_END();
+
+	return true;
+}
+
+/* Find invalid key type for error reporting */
+static zend_always_inline const char *zend_find_invalid_key_type(
+	HashTable *ht, uint32_t expected_key_mask)
+{
+	zend_string *str_key;
+	zend_ulong num_key;
+
+	bool expects_int = (expected_key_mask == MAY_BE_LONG);
+
+	ZEND_HASH_FOREACH_KEY(ht, num_key, str_key) {
+		if (expects_int && str_key != NULL) {
+			return "string";
+		}
+		if (!expects_int && str_key == NULL) {
+			return "int";
+		}
+	} ZEND_HASH_FOREACH_END();
+
+	return "unknown";
+}
+
+/*
+ * Optimized type-specialized validation functions
+ * Key optimizations:
+ * 1. Type check selected once outside loop (no switch per element)
+ * 2. Minimal work in hot path (no index tracking, no type name assignment)
+ * 3. ZEND_HASH_FOREACH_VAL instead of KEY_VAL when keys not needed
+ * 4. Class entry cached for object types
+ * 5. Fast path for packed arrays without references (4x loop unrolling)
+ * 6. Prefetching for cache efficiency on large arrays
+ */
+
+/* Fast path for packed arrays - processes 4 elements at a time */
+static zend_always_inline bool zend_verify_packed_array_elements_long(zval *data, uint32_t count)
+{
+	zval *end = data + count;
+	zval *prefetch_ptr;
+
+	/* Process 4 elements at a time */
+	while (data + 4 <= end) {
+		/* Prefetch next cache line */
+		prefetch_ptr = data + 8;
+		if (prefetch_ptr < end) {
+			__builtin_prefetch(prefetch_ptr, 0, 1);
+		}
+
+		/* Unrolled checks - compiler can pipeline these */
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_LONG)) {
+			if (Z_TYPE_P(data) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		if (UNEXPECTED(Z_TYPE_P(data + 1) != IS_LONG)) {
+			if (Z_TYPE_P(data + 1) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		if (UNEXPECTED(Z_TYPE_P(data + 2) != IS_LONG)) {
+			if (Z_TYPE_P(data + 2) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		if (UNEXPECTED(Z_TYPE_P(data + 3) != IS_LONG)) {
+			if (Z_TYPE_P(data + 3) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		data += 4;
+	}
+
+	/* Handle remaining elements */
+	while (data < end) {
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_LONG)) {
+			if (Z_TYPE_P(data) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		data++;
+	}
+	return true;
+
+slow_path:
+	/* Fall back to reference-aware path from current position */
+	while (data < end) {
+		zval *val = data;
+		if (Z_TYPE_P(val) == IS_REFERENCE) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_LONG)) {
+			return false;
+		}
+		data++;
+	}
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_long(HashTable *ht)
+{
+	/* Fast path for packed arrays */
+	if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+		return zend_verify_packed_array_elements_long(ht->arPacked, ht->nNumOfElements);
+	}
+
+	/* Generic path for non-packed arrays */
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_LONG)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_double(HashTable *ht)
+{
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_DOUBLE && Z_TYPE_P(val) != IS_LONG)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+/* Fast path for packed arrays - string validation */
+static zend_always_inline bool zend_verify_packed_array_elements_string(zval *data, uint32_t count)
+{
+	zval *end = data + count;
+	zval *prefetch_ptr;
+
+	while (data + 4 <= end) {
+		prefetch_ptr = data + 8;
+		if (prefetch_ptr < end) {
+			__builtin_prefetch(prefetch_ptr, 0, 1);
+		}
+
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_STRING)) {
+			if (Z_TYPE_P(data) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		if (UNEXPECTED(Z_TYPE_P(data + 1) != IS_STRING)) {
+			if (Z_TYPE_P(data + 1) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		if (UNEXPECTED(Z_TYPE_P(data + 2) != IS_STRING)) {
+			if (Z_TYPE_P(data + 2) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		if (UNEXPECTED(Z_TYPE_P(data + 3) != IS_STRING)) {
+			if (Z_TYPE_P(data + 3) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		data += 4;
+	}
+
+	while (data < end) {
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_STRING)) {
+			if (Z_TYPE_P(data) == IS_REFERENCE) goto slow_path;
+			return false;
+		}
+		data++;
+	}
+	return true;
+
+slow_path:
+	while (data < end) {
+		zval *val = data;
+		if (Z_TYPE_P(val) == IS_REFERENCE) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_STRING)) {
+			return false;
+		}
+		data++;
+	}
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_string(HashTable *ht)
+{
+	if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+		return zend_verify_packed_array_elements_string(ht->arPacked, ht->nNumOfElements);
+	}
+
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_STRING)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_bool(HashTable *ht)
+{
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_TRUE && Z_TYPE_P(val) != IS_FALSE)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+static zend_always_inline bool zend_verify_array_elements_object(HashTable *ht, zend_class_entry *ce)
+{
+	zval *val;
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_OBJECT)) {
+			return false;
+		}
+		if (ce && UNEXPECTED(!instanceof_function(Z_OBJCE_P(val), ce))) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+/* Cold path: find the failing element for error reporting (simple types) */
+static ZEND_COLD zend_long zend_find_invalid_array_element_simple(
+	HashTable *ht, uint8_t type_code, zend_class_entry *cached_ce, zval **out_val)
+{
+	zval *val;
+	zend_ulong idx;
+	zend_string *key;
+	zend_long numeric_idx = 0;
+
+	ZEND_HASH_FOREACH_KEY_VAL(ht, idx, key, val) {
+		zend_long current_idx = key ? numeric_idx : (zend_long)idx;
+		bool type_matches = false;
+
+		ZVAL_DEREF(val);
+
+		switch (type_code) {
+			case IS_LONG:
+				type_matches = (Z_TYPE_P(val) == IS_LONG);
+				break;
+			case IS_DOUBLE:
+				type_matches = (Z_TYPE_P(val) == IS_DOUBLE || Z_TYPE_P(val) == IS_LONG);
+				break;
+			case IS_STRING:
+				type_matches = (Z_TYPE_P(val) == IS_STRING);
+				break;
+			case _IS_BOOL:
+				type_matches = (Z_TYPE_P(val) == IS_TRUE || Z_TYPE_P(val) == IS_FALSE);
+				break;
+			case IS_OBJECT:
+				if (Z_TYPE_P(val) == IS_OBJECT) {
+					type_matches = !cached_ce || instanceof_function(Z_OBJCE_P(val), cached_ce);
+				}
+				break;
+			default:
+				type_matches = true;
+				break;
+		}
+
+		if (!type_matches) {
+			*out_val = val;
+			return current_idx;
+		}
+		numeric_idx++;
+	} ZEND_HASH_FOREACH_END();
+
+	*out_val = NULL;
+	return -1;
+}
+
+/* Cold path: find the failing element for error reporting (union/complex types) */
+/* Forward declaration for recursive validation */
+static bool zend_verify_nested_array_type(zval *val, const zend_type *element_type);
+
+static ZEND_COLD zend_long zend_find_invalid_array_element_union(
+	HashTable *ht, const zend_type *element_type, zval **out_val)
+{
+	zval *val;
+	zend_ulong idx;
+	zend_string *key;
+	zend_long numeric_idx = 0;
+
+	ZEND_HASH_FOREACH_KEY_VAL(ht, idx, key, val) {
+		zend_long current_idx = key ? numeric_idx : (zend_long)idx;
+
+		/* For nested array types, use recursive validation */
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(*element_type)) {
+			if (!zend_verify_nested_array_type(val, element_type)) {
+				*out_val = val;
+				ZVAL_DEREF(*out_val);
+				return current_idx;
+			}
+		} else if (!zend_check_type(element_type, val, NULL, 0, 0)) {
+			*out_val = val;
+			ZVAL_DEREF(*out_val);
+			return current_idx;
+		}
+		numeric_idx++;
+	} ZEND_HASH_FOREACH_END();
+
+	*out_val = NULL;
+	return -1;
+}
+
+/* Validate array elements against union/complex types */
+static zend_always_inline bool zend_verify_array_elements_union(HashTable *ht, const zend_type *element_type)
+{
+	zval *val;
+
+	ZEND_HASH_FOREACH_VAL(ht, val) {
+		/* Check if element type is a nested array<T> type */
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(*element_type)) {
+			/* Nested array type - need recursive validation */
+			if (!zend_verify_nested_array_type(val, element_type)) {
+				return false;
+			}
+		} else if (!zend_check_type(element_type, val, NULL, 0, 0)) {
+			return false;
+		}
+	} ZEND_HASH_FOREACH_END();
+	return true;
+}
+
+/* Recursively validate a value against an array<T> type */
+static bool zend_verify_nested_array_type(zval *val, const zend_type *array_type)
+{
+	/* The value must be an array */
+	if (Z_TYPE_P(val) != IS_ARRAY) {
+		return false;
+	}
+
+	/* Get the inner element type */
+	const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(*array_type);
+	if (!elem_type) {
+		return true; /* No element type constraint */
+	}
+
+	HashTable *ht = Z_ARRVAL_P(val);
+	zval *inner_val;
+
+	ZEND_HASH_FOREACH_VAL(ht, inner_val) {
+		/* Check if the inner element type is also a nested array<T> */
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(elem_type->element_type)) {
+			/* Recurse for deeper nesting */
+			if (!zend_verify_nested_array_type(inner_val, &elem_type->element_type)) {
+				return false;
+			}
+		} else {
+			/* Leaf level - use regular type checking */
+			if (!zend_check_type(&elem_type->element_type, inner_val, NULL, 0, 0)) {
+				return false;
+			}
+		}
+	} ZEND_HASH_FOREACH_END();
+
+	return true;
+}
+
+/* Check if a zend_type is a simple single type (for optimization) */
+static zend_always_inline uint8_t zend_get_simple_type_code(const zend_type *type)
+{
+	/* Check if it's a simple type without unions/intersections */
+	if (ZEND_TYPE_HAS_LIST(*type)) {
+		return 0; /* Union or intersection - not simple */
+	}
+
+	uint32_t type_mask = ZEND_TYPE_PURE_MASK(*type);
+
+	/* If there's a class name AND other type bits, it's a union like int|MyClass */
+	if (ZEND_TYPE_HAS_NAME(*type) && type_mask != 0) {
+		return 0; /* Union of class + builtin type - not simple */
+	}
+
+	/* If it's a nested array<T> type, treat as complex for recursive validation */
+	if (ZEND_TYPE_HAS_ARRAY_ELEMENT(*type)) {
+		return 0; /* Nested array type - needs recursive validation */
+	}
+
+	/* Check for single built-in type */
+	if (type_mask == MAY_BE_LONG) return IS_LONG;
+	if (type_mask == MAY_BE_DOUBLE) return IS_DOUBLE;
+	if (type_mask == MAY_BE_STRING) return IS_STRING;
+	if (type_mask == MAY_BE_BOOL) return _IS_BOOL;
+	if (type_mask == MAY_BE_ARRAY) return IS_ARRAY;
+
+	/* Check for object type (with or without class name) */
+	if (type_mask == MAY_BE_OBJECT) {
+		return IS_OBJECT;
+	}
+
+	/* Check for class name only (no other type bits) */
+	if (ZEND_TYPE_HAS_NAME(*type)) {
+		return IS_OBJECT;
+	}
+
+	return 0; /* Complex type */
+}
+
+ZEND_API bool zend_verify_array_element_types(
+	const zend_function *zf, zval *arr, const zend_typed_array_element *elem_type)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+	bool valid;
+	zend_class_entry *cached_ce = NULL;
+	zend_string *expected_type_str = NULL;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* Check key types if specified */
+	if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(elem_type->key_type);
+		if (!zend_verify_array_key_types(ht, key_mask)) {
+			zend_string *key_type_str = zend_type_to_string(elem_type->key_type);
+			const char *actual_key_type = zend_find_invalid_key_type(ht, key_mask);
+			zend_verify_array_key_type_error(zf, ZSTR_VAL(key_type_str), actual_key_type);
+			zend_string_release(key_type_str);
+			return false;
+		}
+	}
+
+	/* Check if this is a simple type (for optimized fast paths) */
+	uint8_t simple_type = zend_get_simple_type_code(&elem_type->element_type);
+
+	/* Fast path: check if array was already validated for this type */
+	/* Only works for simple types without class names */
+	if (simple_type != 0 && HT_ELEM_TYPE_IS_VALID(ht) &&
+		HT_VALIDATED_ELEM_TYPE(ht) == simple_type &&
+		(simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type))) {
+		return true;
+	}
+
+	/* Select validation strategy based on type */
+	if (simple_type != 0) {
+		/* Simple type - use optimized fast paths */
+		switch (simple_type) {
+			case IS_LONG:
+				valid = zend_verify_array_elements_long(ht);
+				break;
+			case IS_DOUBLE:
+				valid = zend_verify_array_elements_double(ht);
+				break;
+			case IS_STRING:
+				valid = zend_verify_array_elements_string(ht);
+				break;
+			case _IS_BOOL:
+				valid = zend_verify_array_elements_bool(ht);
+				break;
+			case IS_OBJECT:
+				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
+					cached_ce = zend_lookup_class(class_name);
+				}
+				valid = zend_verify_array_elements_object(ht, cached_ce);
+				break;
+			default:
+				valid = true;
+				break;
+		}
+
+		if (EXPECTED(valid)) {
+			/* Cache the validated type (skip for class-specific object validation) */
+			if (simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+				HT_SET_VALIDATED_ELEM_TYPE(ht, simple_type);
+			}
+			return true;
+		}
+
+		/* Slow path (cold): find and report the failing element */
+		zval *failing_val;
+		zend_long failing_idx = zend_find_invalid_array_element_simple(ht, simple_type, cached_ce, &failing_val);
+		if (failing_idx >= 0 && failing_val) {
+			expected_type_str = zend_type_to_string(elem_type->element_type);
+			const char *actual_type_name = zend_zval_type_name(failing_val);
+			zend_verify_array_element_type_error(zf, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+			zend_string_release(expected_type_str);
+		}
+		return false;
+	}
+
+	/* Union/complex type - use generic validation */
+	valid = zend_verify_array_elements_union(ht, &elem_type->element_type);
+
+	if (EXPECTED(valid)) {
+		return true;
+	}
+
+	/* Slow path (cold): find and report the failing element */
+	zval *failing_val;
+	zend_long failing_idx = zend_find_invalid_array_element_union(ht, &elem_type->element_type, &failing_val);
+	if (failing_idx >= 0 && failing_val) {
+		expected_type_str = zend_type_to_string(elem_type->element_type);
+		const char *actual_type_name = zend_zval_type_name(failing_val);
+		zend_verify_array_element_type_error(zf, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+		zend_string_release(expected_type_str);
+	}
+	return false;
+}
+
+/* Validate array element types for function argument with array<T> */
+ZEND_API bool zend_verify_array_arg_element_types(
+	const zend_function *zf, uint32_t arg_num, zval *arr, const zend_typed_array_element *elem_type)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+	bool valid;
+	zend_class_entry *cached_ce = NULL;
+	zend_string *expected_type_str = NULL;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* Check key types if specified */
+	if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(elem_type->key_type);
+		if (!zend_verify_array_key_types(ht, key_mask)) {
+			zend_string *key_type_str = zend_type_to_string(elem_type->key_type);
+			const char *actual_key_type = zend_find_invalid_key_type(ht, key_mask);
+			zend_verify_array_arg_key_type_error(arg_num, ZSTR_VAL(key_type_str), actual_key_type);
+			zend_string_release(key_type_str);
+			return false;
+		}
+	}
+
+	/* Check if this is a simple type (for optimized fast paths) */
+	uint8_t simple_type = zend_get_simple_type_code(&elem_type->element_type);
+
+	/* Fast path: check if array was already validated for this type */
+	if (simple_type != 0 && HT_ELEM_TYPE_IS_VALID(ht) &&
+		HT_VALIDATED_ELEM_TYPE(ht) == simple_type &&
+		(simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type))) {
+		return true;
+	}
+
+	/* Select validation strategy based on type */
+	if (simple_type != 0) {
+		/* Simple type - use optimized fast paths */
+		switch (simple_type) {
+			case IS_LONG:
+				valid = zend_verify_array_elements_long(ht);
+				break;
+			case IS_DOUBLE:
+				valid = zend_verify_array_elements_double(ht);
+				break;
+			case IS_STRING:
+				valid = zend_verify_array_elements_string(ht);
+				break;
+			case _IS_BOOL:
+				valid = zend_verify_array_elements_bool(ht);
+				break;
+			case IS_OBJECT:
+				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
+					cached_ce = zend_lookup_class(class_name);
+				}
+				valid = zend_verify_array_elements_object(ht, cached_ce);
+				break;
+			default:
+				valid = true;
+				break;
+		}
+
+		if (EXPECTED(valid)) {
+			/* Cache the validated type (skip for class-specific object validation) */
+			if (simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+				HT_SET_VALIDATED_ELEM_TYPE(ht, simple_type);
+			}
+			return true;
+		}
+
+		/* Slow path (cold): find and report the failing element */
+		zval *failing_val;
+		zend_long failing_idx = zend_find_invalid_array_element_simple(ht, simple_type, cached_ce, &failing_val);
+		if (failing_idx >= 0 && failing_val) {
+			expected_type_str = zend_type_to_string(elem_type->element_type);
+			const char *actual_type_name = zend_zval_type_name(failing_val);
+			zend_verify_array_arg_element_type_error(zf, arg_num, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+			zend_string_release(expected_type_str);
+		}
+		return false;
+	}
+
+	/* Union/complex type - use generic validation */
+	valid = zend_verify_array_elements_union(ht, &elem_type->element_type);
+
+	if (EXPECTED(valid)) {
+		return true;
+	}
+
+	/* Slow path (cold): find and report the failing element */
+	zval *failing_val;
+	zend_long failing_idx = zend_find_invalid_array_element_union(ht, &elem_type->element_type, &failing_val);
+	if (failing_idx >= 0 && failing_val) {
+		expected_type_str = zend_type_to_string(elem_type->element_type);
+		const char *actual_type_name = zend_zval_type_name(failing_val);
+		zend_verify_array_arg_element_type_error(zf, arg_num, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+		zend_string_release(expected_type_str);
+	}
+	return false;
+}
+
+/* Validate array element types for property with array<T> */
+ZEND_API bool zend_verify_array_prop_element_types(
+	const zend_property_info *info, zval *arr, const zend_typed_array_element *elem_type)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+	bool valid;
+	zend_class_entry *cached_ce = NULL;
+	zend_string *expected_type_str = NULL;
+
+	/* Fast path: empty arrays always valid */
+	if (zend_hash_num_elements(ht) == 0) {
+		return true;
+	}
+
+	/* Check key types if specified */
+	if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		uint32_t key_mask = ZEND_TYPE_PURE_MASK(elem_type->key_type);
+		if (!zend_verify_array_key_types(ht, key_mask)) {
+			zend_string *key_type_str = zend_type_to_string(elem_type->key_type);
+			const char *actual_key_type = zend_find_invalid_key_type(ht, key_mask);
+			zend_verify_array_prop_key_type_error(info, ZSTR_VAL(key_type_str), actual_key_type);
+			zend_string_release(key_type_str);
+			return false;
+		}
+	}
+
+	/* Check if this is a simple type (for optimized fast paths) */
+	uint8_t simple_type = zend_get_simple_type_code(&elem_type->element_type);
+
+	/* Fast path: check if array was already validated for this type */
+	if (simple_type != 0 && HT_ELEM_TYPE_IS_VALID(ht) &&
+		HT_VALIDATED_ELEM_TYPE(ht) == simple_type &&
+		(simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type))) {
+		return true;
+	}
+
+	/* Select validation strategy based on type */
+	if (simple_type != 0) {
+		/* Simple type - use optimized fast paths */
+		switch (simple_type) {
+			case IS_LONG:
+				valid = zend_verify_array_elements_long(ht);
+				break;
+			case IS_DOUBLE:
+				valid = zend_verify_array_elements_double(ht);
+				break;
+			case IS_STRING:
+				valid = zend_verify_array_elements_string(ht);
+				break;
+			case _IS_BOOL:
+				valid = zend_verify_array_elements_bool(ht);
+				break;
+			case IS_OBJECT:
+				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
+					cached_ce = zend_lookup_class(class_name);
+				}
+				valid = zend_verify_array_elements_object(ht, cached_ce);
+				break;
+			default:
+				valid = true;
+				break;
+		}
+
+		if (EXPECTED(valid)) {
+			/* Cache the validated type (skip for class-specific object validation) */
+			if (simple_type != IS_OBJECT || !ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
+				HT_SET_VALIDATED_ELEM_TYPE(ht, simple_type);
+			}
+			return true;
+		}
+
+		/* Slow path (cold): find and report the failing element */
+		zval *failing_val;
+		zend_long failing_idx = zend_find_invalid_array_element_simple(ht, simple_type, cached_ce, &failing_val);
+		if (failing_idx >= 0 && failing_val) {
+			expected_type_str = zend_type_to_string(elem_type->element_type);
+			const char *actual_type_name = zend_zval_type_name(failing_val);
+			zend_verify_array_prop_element_type_error(info, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+			zend_string_release(expected_type_str);
+		}
+		return false;
+	}
+
+	/* Union/complex type - use generic validation */
+	valid = zend_verify_array_elements_union(ht, &elem_type->element_type);
+
+	if (EXPECTED(valid)) {
+		return true;
+	}
+
+	/* Slow path (cold): find and report the failing element */
+	zval *failing_val;
+	zend_long failing_idx = zend_find_invalid_array_element_union(ht, &elem_type->element_type, &failing_val);
+	if (failing_idx >= 0 && failing_val) {
+		expected_type_str = zend_type_to_string(elem_type->element_type);
+		const char *actual_type_name = zend_zval_type_name(failing_val);
+		zend_verify_array_prop_element_type_error(info, failing_idx, failing_val, ZSTR_VAL(expected_type_str), actual_type_name);
+		zend_string_release(expected_type_str);
+	}
+	return false;
+}
+
+/* Validate array against shape definition (array{key: type, key?: type}) */
+ZEND_API bool zend_verify_array_shape(
+	const zend_function *zf, zval *arr, const zend_array_shape *shape)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+
+	/* Check each defined key in the shape */
+	for (uint32_t i = 0; i < shape->num_elements; i++) {
+		const zend_array_shape_element *elem = &shape->elements[i];
+		zval *val = zend_hash_find(ht, elem->key);
+
+		if (val == NULL) {
+			/* Key not present - error if required */
+			if (!elem->is_optional) {
+				zend_type_error("%s%s%s(): Return value must be of type array{%s: ...}, missing required key \"%s\"",
+					zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "",
+					zf->common.scope ? "::" : "",
+					ZSTR_VAL(zf->common.function_name),
+					ZSTR_VAL(elem->key),
+					ZSTR_VAL(elem->key));
+				return false;
+			}
+			continue;
+		}
+
+		/* Check value type */
+		if (!zend_check_type(&elem->type, val, NULL, 0, false)) {
+			zend_string *expected = zend_type_to_string(elem->type);
+			zend_type_error("%s%s%s(): Return value key \"%s\" must be of type %s, %s given",
+				zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "",
+				zf->common.scope ? "::" : "",
+				ZSTR_VAL(zf->common.function_name),
+				ZSTR_VAL(elem->key),
+				ZSTR_VAL(expected),
+				zend_zval_value_name(val));
+			zend_string_release(expected);
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/* Validate array shape for function argument */
+ZEND_API bool zend_verify_array_arg_shape(
+	uint32_t arg_num, zval *arr, const zend_array_shape *shape)
+{
+	HashTable *ht = Z_ARRVAL_P(arr);
+
+	/* Check each defined key in the shape */
+	for (uint32_t i = 0; i < shape->num_elements; i++) {
+		const zend_array_shape_element *elem = &shape->elements[i];
+		zval *val = zend_hash_find(ht, elem->key);
+
+		if (val == NULL) {
+			if (!elem->is_optional) {
+				zend_type_error("Argument #%u must be of type array{%s: ...}, missing required key \"%s\"",
+					arg_num, ZSTR_VAL(elem->key), ZSTR_VAL(elem->key));
+				return false;
+			}
+			continue;
+		}
+
+		if (!zend_check_type(&elem->type, val, NULL, 0, false)) {
+			zend_string *expected = zend_type_to_string(elem->type);
+			zend_type_error("Argument #%u key \"%s\" must be of type %s, %s given",
+				arg_num, ZSTR_VAL(elem->key), ZSTR_VAL(expected), zend_zval_value_name(val));
+			zend_string_release(expected);
+			return false;
+		}
+	}
+
+	return true;
+}
+
 ZEND_API ZEND_COLD void zend_verify_never_error(const zend_function *zf)
 {
 	zend_string *func_name = get_function_or_method_name(zf);
diff --git a/Zend/zend_execute.h b/Zend/zend_execute.h
index c08adf2a..fda9b47c 100644
--- a/Zend/zend_execute.h
+++ b/Zend/zend_execute.h
@@ -105,6 +105,31 @@ ZEND_API ZEND_COLD void zend_verify_arg_error(
 		const zend_function *zf, const zend_arg_info *arg_info, uint32_t arg_num, const zval *value);
 ZEND_API ZEND_COLD void zend_verify_return_error(
 		const zend_function *zf, const zval *value);
+ZEND_API ZEND_COLD void zend_verify_array_element_type_error(
+		const zend_function *zf, zend_long index, const zval *element,
+		const char *expected_type, const char *actual_type);
+ZEND_API ZEND_COLD void zend_verify_array_arg_element_type_error(
+		const zend_function *zf, uint32_t arg_num, zend_long index, const zval *element,
+		const char *expected_type, const char *actual_type);
+ZEND_API bool zend_verify_array_element_types(
+		const zend_function *zf, zval *arr, const zend_typed_array_element *elem_type);
+ZEND_API bool zend_verify_array_arg_element_types(
+		const zend_function *zf, uint32_t arg_num, zval *arr, const zend_typed_array_element *elem_type);
+ZEND_API ZEND_COLD void zend_verify_array_prop_element_type_error(
+		const zend_property_info *info, zend_long index, const zval *element,
+		const char *expected_type, const char *actual_type);
+ZEND_API bool zend_verify_array_prop_element_types(
+		const zend_property_info *info, zval *arr, const zend_typed_array_element *elem_type);
+ZEND_API ZEND_COLD void zend_verify_array_key_type_error(
+		const zend_function *zf, const char *expected_key_type, const char *actual_key_type);
+ZEND_API ZEND_COLD void zend_verify_array_arg_key_type_error(
+		uint32_t arg_num, const char *expected_key_type, const char *actual_key_type);
+ZEND_API ZEND_COLD void zend_verify_array_prop_key_type_error(
+		const zend_property_info *info, const char *expected_key_type, const char *actual_key_type);
+ZEND_API bool zend_verify_array_shape(
+		const zend_function *zf, zval *arr, const zend_array_shape *shape);
+ZEND_API bool zend_verify_array_arg_shape(
+		uint32_t arg_num, zval *arr, const zend_array_shape *shape);
 ZEND_API ZEND_COLD void zend_verify_never_error(
 		const zend_function *zf);
 ZEND_API bool zend_verify_ref_array_assignable(zend_reference *ref);
diff --git a/Zend/zend_hash.c b/Zend/zend_hash.c
index 6978beaa..3dfc345e 100644
--- a/Zend/zend_hash.c
+++ b/Zend/zend_hash.c
@@ -829,6 +829,7 @@ static zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_s
 
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
 	zend_string_hash_val(key);
 
 	if (UNEXPECTED(HT_FLAGS(ht) & (HASH_FLAG_UNINITIALIZED|HASH_FLAG_PACKED))) {
@@ -910,6 +911,7 @@ static zend_always_inline zval *_zend_hash_str_add_or_update_i(HashTable *ht, co
 
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
 
 	if (UNEXPECTED(HT_FLAGS(ht) & (HASH_FLAG_UNINITIALIZED|HASH_FLAG_PACKED))) {
 		if (EXPECTED(HT_FLAGS(ht) & HASH_FLAG_UNINITIALIZED)) {
@@ -1095,6 +1097,7 @@ static zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht,
 
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
 
 	if ((flag & HASH_ADD_NEXT) && h == ZEND_LONG_MIN) {
 		h = 0;
@@ -1451,6 +1454,7 @@ static zend_always_inline void zend_hash_iterators_clamp_max(const HashTable *ht
 
 static zend_always_inline void _zend_hash_packed_del_val(HashTable *ht, uint32_t idx, zval *zv)
 {
+	HT_INVALIDATE_ELEM_TYPE(ht);
 	idx = HT_HASH_TO_IDX(idx);
 	ht->nNumOfElements--;
 	if (ht->nNumUsed - 1 == idx) {
@@ -1472,6 +1476,7 @@ static zend_always_inline void _zend_hash_packed_del_val(HashTable *ht, uint32_t
 
 static zend_always_inline void _zend_hash_del_el_ex(HashTable *ht, uint32_t idx, Bucket *p, Bucket *prev)
 {
+	HT_INVALIDATE_ELEM_TYPE(ht);
 	if (prev) {
 		Z_NEXT(prev->val) = Z_NEXT(p->val);
 	} else {
@@ -1876,6 +1881,7 @@ ZEND_API void ZEND_FASTCALL zend_hash_clean(HashTable *ht)
 {
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
+	HT_INVALIDATE_ELEM_TYPE(ht);
 
 	if (ht->nNumUsed) {
 		if (HT_IS_PACKED(ht)) {
diff --git a/Zend/zend_hash.h b/Zend/zend_hash.h
index 57020bbc..0111c64d 100644
--- a/Zend/zend_hash.h
+++ b/Zend/zend_hash.h
@@ -46,6 +46,7 @@ typedef enum {
 #define HASH_FLAG_STATIC_KEYS      (1<<4) /* long and interned strings */
 #define HASH_FLAG_HAS_EMPTY_IND    (1<<5)
 #define HASH_FLAG_ALLOW_COW_VIOLATION (1<<6)
+#define HASH_FLAG_ELEM_TYPE_VALID  (1<<7) /* Element type validation cache is valid */
 
 /* Only the low byte are real flags */
 #define HASH_FLAG_MASK 0xff
@@ -85,6 +86,16 @@ typedef enum {
 #define HT_DEC_ITERATORS_COUNT(ht) \
 	HT_SET_ITERATORS_COUNT(ht, HT_ITERATORS_COUNT(ht) - 1)
 
+/* Element type validation cache for array<T> optimization */
+#define HT_VALIDATED_ELEM_TYPE(ht) (ht)->u.v.nValidatedElemType
+#define HT_ELEM_TYPE_IS_VALID(ht) ((HT_FLAGS(ht) & HASH_FLAG_ELEM_TYPE_VALID) != 0)
+#define HT_INVALIDATE_ELEM_TYPE(ht) \
+	do { HT_FLAGS(ht) &= ~HASH_FLAG_ELEM_TYPE_VALID; } while (0)
+#define HT_SET_VALIDATED_ELEM_TYPE(ht, type) do { \
+		(ht)->u.v.nValidatedElemType = (type); \
+		HT_FLAGS(ht) |= HASH_FLAG_ELEM_TYPE_VALID; \
+	} while (0)
+
 extern ZEND_API const HashTable zend_empty_array;
 
 #define ZVAL_EMPTY_ARRAY(z) do {						\
diff --git a/Zend/zend_language_parser.y b/Zend/zend_language_parser.y
index e4d61006..83b61b1d 100644
--- a/Zend/zend_language_parser.y
+++ b/Zend/zend_language_parser.y
@@ -87,6 +87,7 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %precedence T_ELSEIF
 %precedence T_ELSE
 
+
 %token <ast> T_LNUMBER   "integer"
 %token <ast> T_DNUMBER   "floating-point number"
 %token <ast> T_STRING    "identifier"
@@ -173,6 +174,7 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %token <ident> T_NAMESPACE     "'namespace'"
 %token <ident> T_LIST            "'list'"
 %token <ident> T_ARRAY           "'array'"
+%token T_ARRAY_SHAPE_START       "'array{'"
 %token <ident> T_CALLABLE        "'callable'"
 %token <ident> T_LINE            "'__LINE__'"
 %token <ident> T_FILE            "'__FILE__'"
@@ -280,6 +282,7 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %type <ast> array_pair non_empty_array_pair_list array_pair_list possible_array_pair
 %type <ast> isset_variable type return_type type_expr type_without_static
 %type <ast> identifier type_expr_without_static union_type_without_static_element union_type_without_static intersection_type_without_static
+%type <ast> shape_element_list shape_element
 %type <ast> inline_function union_type_element union_type intersection_type
 %type <ast> attributed_statement attributed_top_statement attributed_class_statement attributed_parameter
 %type <ast> attribute_decl attribute attributes attribute_group namespace_declaration_name
@@ -874,6 +877,40 @@ type_without_static:
 		T_ARRAY		{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_ARRAY); }
 	|	T_CALLABLE	{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_CALLABLE); }
 	|	name		{ $$ = $1; }
+	|	T_ARRAY '<' type_expr '>'
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_OF, $3); }
+	|	T_ARRAY '<' type_expr ',' type_expr '>'
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_MAP, $3, $5); }
+	|	T_ARRAY '<' T_ARRAY '<' type_expr T_SR
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_OF,
+				zend_ast_create(ZEND_AST_TYPE_ARRAY_OF, $5)); }
+	|	T_ARRAY '<' T_ARRAY '<' T_ARRAY '<' type_expr T_SR '>'
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_OF,
+				zend_ast_create(ZEND_AST_TYPE_ARRAY_OF,
+					zend_ast_create(ZEND_AST_TYPE_ARRAY_OF, $7))); }
+	|	T_ARRAY '<' T_ARRAY '<' T_ARRAY '<' T_ARRAY '<' type_expr T_SR T_SR
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_OF,
+				zend_ast_create(ZEND_AST_TYPE_ARRAY_OF,
+					zend_ast_create(ZEND_AST_TYPE_ARRAY_OF,
+						zend_ast_create(ZEND_AST_TYPE_ARRAY_OF, $9)))); }
+	|	T_ARRAY_SHAPE_START shape_element_list '}'
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_SHAPE, $2); }
+	|	T_ARRAY_SHAPE_START '}'
+			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_SHAPE, NULL); }
+;
+
+shape_element_list:
+		shape_element
+			{ $$ = zend_ast_create_list(1, ZEND_AST_SHAPE_ELEMENT_LIST, $1); }
+	|	shape_element_list ',' shape_element
+			{ $$ = zend_ast_list_add($1, $3); }
+;
+
+shape_element:
+		T_STRING ':' type_expr
+			{ $$ = zend_ast_create_ex(ZEND_AST_SHAPE_ELEMENT, 0, $1, $3); }
+	|	T_STRING '?' ':' type_expr
+			{ $$ = zend_ast_create_ex(ZEND_AST_SHAPE_ELEMENT, 1, $1, $4); }
 ;
 
 union_type_without_static_element:
diff --git a/Zend/zend_language_scanner.l b/Zend/zend_language_scanner.l
index 3ecb2f8d..7ca79ab9 100644
--- a/Zend/zend_language_scanner.l
+++ b/Zend/zend_language_scanner.l
@@ -1814,6 +1814,13 @@ OPTIONAL_WHITESPACE_OR_COMMENTS ({WHITESPACE}|{MULTI_LINE_COMMENT}|{SINGLE_LINE_
 	RETURN_TOKEN_WITH_IDENT(T_LIST);
 }
 
+<ST_IN_SCRIPTING>"array{" {
+	/* Return T_ARRAY_SHAPE_START for array shape syntax (no whitespace between array and {)
+	 * We must call enter_nesting since we consumed the { character */
+	enter_nesting('{');
+	RETURN_TOKEN(T_ARRAY_SHAPE_START);
+}
+
 <ST_IN_SCRIPTING>"array" {
 	RETURN_TOKEN_WITH_IDENT(T_ARRAY);
 }
diff --git a/Zend/zend_object_handlers.c b/Zend/zend_object_handlers.c
index 67257913..c723e4d6 100644
--- a/Zend/zend_object_handlers.c
+++ b/Zend/zend_object_handlers.c
@@ -33,6 +33,7 @@
 #include "zend_hash.h"
 #include "zend_property_hooks.h"
 #include "zend_observer.h"
+#include "zend_execute.h"
 
 #define DEBUG_OBJECT_HANDLERS 0
 
@@ -1002,6 +1003,14 @@ static zend_always_inline bool property_uses_strict_types(void) {
 		&& ZEND_CALL_USES_STRICT_TYPES(EG(current_execute_data));
 }
 
+static zend_always_inline bool property_uses_strict_arrays(void) {
+	zend_execute_data *execute_data = EG(current_execute_data);
+	return execute_data
+		&& execute_data->func
+		&& ZEND_USER_CODE(execute_data->func->type)
+		&& (execute_data->func->op_array.fn_flags & ZEND_ACC_STRICT_ARRAYS);
+}
+
 static zval *forward_write_to_lazy_object(zend_object *zobj,
 		zend_string *name, zval *value, void **cache_slot, bool guarded)
 {
@@ -1098,6 +1107,15 @@ ZEND_API zval *zend_std_write_property(zend_object *zobj, zend_string *name, zva
 					variable_ptr = &EG(error_zval);
 					goto exit;
 				}
+				/* Check array element types if strict_arrays is enabled */
+				if (property_uses_strict_arrays() && Z_TYPE(tmp) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(prop_info->type)) {
+					zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(prop_info->type);
+					if (!zend_verify_array_prop_element_types(prop_info, &tmp, elem_type)) {
+						zval_ptr_dtor(&tmp);
+						variable_ptr = &EG(error_zval);
+						goto exit;
+					}
+				}
 				Z_PROP_FLAG_P(variable_ptr) &= ~(IS_PROP_UNINIT|IS_PROP_REINITABLE);
 				value = &tmp;
 			}
diff --git a/Zend/zend_types.h b/Zend/zend_types.h
index a3d3e4da..9f79a3cb 100644
--- a/Zend/zend_types.h
+++ b/Zend/zend_types.h
@@ -157,7 +157,9 @@ typedef struct {
 #define _ZEND_TYPE_INTERSECTION_BIT (1u << 19)
 /* Whether the type is a union type */
 #define _ZEND_TYPE_UNION_BIT (1u << 18)
-/* Type mask excluding the flags above. */
+/* Whether the type is an array shape (array{key: type}) */
+#define _ZEND_TYPE_ARRAY_SHAPE_BIT (1u << 30)
+/* Type mask for MAY_BE_* type bits only (bits 0-17, including IS_NEVER) */
 #define _ZEND_TYPE_MAY_BE_MASK ((1u << 18) - 1)
 /* Must have same value as MAY_BE_NULL */
 #define _ZEND_TYPE_NULLABLE_BIT 0x2u
@@ -191,6 +193,9 @@ typedef struct {
 #define ZEND_TYPE_USES_ARENA(t) \
 	((((t).type_mask) & _ZEND_TYPE_ARENA_BIT) != 0)
 
+#define ZEND_TYPE_HAS_ARRAY_ELEMENT(t) \
+	((((t).type_mask) & (1u << IS_ARRAY)) != 0 && (t).ptr != NULL && !ZEND_TYPE_IS_COMPLEX(t) && !((t).type_mask & _ZEND_TYPE_ARRAY_SHAPE_BIT))
+
 #define ZEND_TYPE_IS_ONLY_MASK(t) \
 	(ZEND_TYPE_IS_SET(t) && (t).ptr == NULL)
 
@@ -411,7 +416,7 @@ struct _zend_array {
 		struct {
 			ZEND_ENDIAN_LOHI_4(
 				uint8_t    flags,
-				uint8_t    _unused,
+				uint8_t    nValidatedElemType,  /* Cached validated element type for array<T> */
 				uint8_t    nIteratorsCount,
 				uint8_t    _unused2)
 		} v;
diff --git a/Zend/zend_vm_def.h b/Zend/zend_vm_def.h
index 90247b3c..0982bd4c 100644
--- a/Zend/zend_vm_def.h
+++ b/Zend/zend_vm_def.h
@@ -4453,6 +4453,24 @@ ZEND_VM_COLD_CONST_HANDLER(124, ZEND_VERIFY_RETURN_TYPE, CONST|TMP|VAR|UNUSED|CV
 		}
 
 		if (EXPECTED(ZEND_TYPE_CONTAINS_CODE(ret_info->type, Z_TYPE_P(retval_ptr)))) {
+			/* Check array element types if strict_arrays is enabled and we have array<T> type info */
+			if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(retval_ptr) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(ret_info->type)) {
+				SAVE_OPLINE();
+				zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(ret_info->type);
+				if (!zend_verify_array_element_types(EX(func), retval_ptr, elem_type)) {
+					FREE_OP1();
+					HANDLE_EXCEPTION();
+				}
+			}
+			/* Check array shape if strict_arrays is enabled and we have array{...} type info */
+			if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(retval_ptr) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_SHAPE(ret_info->type)) {
+				SAVE_OPLINE();
+				zend_array_shape *shape = ZEND_ARRAY_SHAPE(ret_info->type);
+				if (!zend_verify_array_shape(EX(func), retval_ptr, shape)) {
+					FREE_OP1();
+					HANDLE_EXCEPTION();
+				}
+			}
 			ZEND_VM_NEXT_OPCODE();
 		}
 
@@ -5681,6 +5699,23 @@ ZEND_VM_HELPER(zend_verify_recv_arg_type_helper, ANY, ANY, zval *op_1)
 		HANDLE_EXCEPTION();
 	}
 
+	/* Check array element types if strict_arrays is enabled */
+	if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(op_1) == IS_ARRAY) {
+		const zend_arg_info *arg_info = &EX(func)->common.arg_info[opline->op1.num - 1];
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+			zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+			if (!zend_verify_array_arg_element_types(EX(func), opline->op1.num, op_1, elem_type)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+		if (ZEND_TYPE_HAS_ARRAY_SHAPE(arg_info->type)) {
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(arg_info->type);
+			if (!zend_verify_array_arg_shape(opline->op1.num, op_1, shape)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+	}
+
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -5700,6 +5735,25 @@ ZEND_VM_HOT_HANDLER(63, ZEND_RECV, NUM, UNUSED)
 		ZEND_VM_DISPATCH_TO_HELPER(zend_verify_recv_arg_type_helper, op_1, param);
 	}
 
+	/* Check array element types if strict_arrays is enabled */
+	if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY) {
+		const zend_arg_info *arg_info = &EX(func)->common.arg_info[arg_num - 1];
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+			SAVE_OPLINE();
+			zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+			if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+		if (ZEND_TYPE_HAS_ARRAY_SHAPE(arg_info->type)) {
+			SAVE_OPLINE();
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(arg_info->type);
+			if (!zend_verify_array_arg_shape(arg_num, param, shape)) {
+				HANDLE_EXCEPTION();
+			}
+		}
+	}
+
 	ZEND_VM_NEXT_OPCODE();
 }
 
@@ -5758,6 +5812,16 @@ ZEND_VM_C_LABEL(recv_init_check_type):
 			if (UNEXPECTED(!zend_verify_recv_arg_type(EX(func), arg_num, param))) {
 				HANDLE_EXCEPTION();
 			}
+			/* Check array element types if strict_arrays is enabled */
+			if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY) {
+				const zend_arg_info *arg_info = &EX(func)->common.arg_info[arg_num - 1];
+				if (ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+					zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+					if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+						HANDLE_EXCEPTION();
+					}
+				}
+			}
 		}
 	}
 
@@ -5792,6 +5856,14 @@ ZEND_VM_HANDLER(164, ZEND_RECV_VARIADIC, NUM, UNUSED)
 						ZEND_HASH_FILL_FINISH();
 						HANDLE_EXCEPTION();
 					}
+					/* Check array element types if strict_arrays is enabled */
+					if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+						zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+						if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+							ZEND_HASH_FILL_FINISH();
+							HANDLE_EXCEPTION();
+						}
+					}
 
 					if (Z_OPT_REFCOUNTED_P(param)) Z_ADDREF_P(param);
 					ZEND_HASH_FILL_ADD(param);
@@ -5819,6 +5891,13 @@ ZEND_VM_HANDLER(164, ZEND_RECV_VARIADIC, NUM, UNUSED)
 				if (UNEXPECTED(!zend_verify_variadic_arg_type(EX(func), arg_info, arg_num, param))) {
 					HANDLE_EXCEPTION();
 				}
+				/* Check array element types if strict_arrays is enabled */
+				if (EX_USES_STRICT_ARRAYS() && Z_TYPE_P(param) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(arg_info->type)) {
+					zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(arg_info->type);
+					if (!zend_verify_array_arg_element_types(EX(func), arg_num, param, elem_type)) {
+						HANDLE_EXCEPTION();
+					}
+				}
 				Z_TRY_ADDREF_P(param);
 				zend_hash_add_new(Z_ARRVAL_P(params), name, param);
 			} ZEND_HASH_FOREACH_END();
diff --git a/Zend/zend_vm_execute.h b/Zend/zend_vm_execute.h
index 810c2c7e..8e4f5427 100644
Binary files a/Zend/zend_vm_execute.h and b/Zend/zend_vm_execute.h differ
diff --git a/examples/array-shapes/01-basic-shapes.php b/examples/array-shapes/01-basic-shapes.php
new file mode 100644
index 00000000..ded279f2
--- /dev/null
+++ b/examples/array-shapes/01-basic-shapes.php
@@ -0,0 +1,123 @@
+<?php
+/**
+ * Basic Array Shape Examples
+ *
+ * Array shapes define the structure of associative arrays with typed keys.
+ * Syntax: array{key: type, key2: type2, ...}
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC SHAPE WITH REQUIRED KEYS
+// =============================================================================
+
+/**
+ * Simple shape with two required keys
+ */
+function getPoint(): array{x: int, y: int} {
+    return ['x' => 10, 'y' => 20];
+}
+
+$point = getPoint();
+echo "Point: ({$point['x']}, {$point['y']})\n";
+
+
+/**
+ * Shape with different types
+ */
+function getUser(): array{id: int, name: string, balance: float, active: bool} {
+    return [
+        'id' => 1,
+        'name' => 'Alice',
+        'balance' => 100.50,
+        'active' => true
+    ];
+}
+
+$user = getUser();
+echo "User: {$user['name']} (ID: {$user['id']}, Balance: {$user['balance']}, Active: " . ($user['active'] ? 'yes' : 'no') . ")\n";
+
+
+// =============================================================================
+// SHAPES AS PARAMETER TYPES
+// =============================================================================
+
+/**
+ * Function accepting a shaped array as parameter
+ */
+function processOrder(array{product: string, quantity: int, price: float} $order): float {
+    return $order['quantity'] * $order['price'];
+}
+
+$total = processOrder(['product' => 'Widget', 'quantity' => 5, 'price' => 9.99]);
+echo "Order total: \${$total}\n";
+
+
+/**
+ * Function with both shaped parameter and return type
+ */
+function createInvoice(
+    array{customer: string, items: int} $order
+): array{invoice_id: string, customer: string, items: int, created: string} {
+    return [
+        'invoice_id' => uniqid('INV-'),
+        'customer' => $order['customer'],
+        'items' => $order['items'],
+        'created' => date('Y-m-d H:i:s')
+    ];
+}
+
+$invoice = createInvoice(['customer' => 'Acme Corp', 'items' => 3]);
+echo "Invoice: {$invoice['invoice_id']} for {$invoice['customer']}\n";
+
+
+// =============================================================================
+// SINGLE KEY SHAPES
+// =============================================================================
+
+/**
+ * Shape with just one key (useful for wrapper types)
+ */
+function wrapValue(): array{value: mixed} {
+    return ['value' => 'anything goes here'];
+}
+
+$wrapped = wrapValue();
+echo "Wrapped value: {$wrapped['value']}\n";
+
+
+// =============================================================================
+// SHAPES WITH MANY KEYS
+// =============================================================================
+
+/**
+ * Shape with many keys (complex data structure)
+ */
+function getFullProfile(): array{
+    id: int,
+    username: string,
+    email: string,
+    first_name: string,
+    last_name: string,
+    age: int,
+    verified: bool,
+    score: float
+} {
+    return [
+        'id' => 42,
+        'username' => 'johndoe',
+        'email' => 'john@example.com',
+        'first_name' => 'John',
+        'last_name' => 'Doe',
+        'age' => 30,
+        'verified' => true,
+        'score' => 95.5
+    ];
+}
+
+$profile = getFullProfile();
+echo "Profile: {$profile['first_name']} {$profile['last_name']} ({$profile['username']})\n";
+
+
+echo "\n--- All basic shape examples completed successfully! ---\n";
diff --git a/examples/array-shapes/02-optional-keys.php b/examples/array-shapes/02-optional-keys.php
new file mode 100644
index 00000000..190bcc81
--- /dev/null
+++ b/examples/array-shapes/02-optional-keys.php
@@ -0,0 +1,199 @@
+<?php
+/**
+ * Optional Keys in Array Shapes
+ *
+ * Optional keys are marked with a question mark after the key name: key?: type
+ * Optional keys don't need to be present in the returned array.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Shape with one required and one optional key
+ */
+function getUserBasic(): array{name: string, nickname?: string} {
+    // We can omit 'nickname' since it's optional
+    return ['name' => 'Alice'];
+}
+
+$user1 = getUserBasic();
+echo "User: {$user1['name']}, Nickname: " . ($user1['nickname'] ?? 'none') . "\n";
+
+
+/**
+ * Same shape, but this time including the optional key
+ */
+function getUserWithNickname(): array{name: string, nickname?: string} {
+    return ['name' => 'Bob', 'nickname' => 'Bobby'];
+}
+
+$user2 = getUserWithNickname();
+echo "User: {$user2['name']}, Nickname: {$user2['nickname']}\n";
+
+
+// =============================================================================
+// MULTIPLE OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Shape with multiple optional keys
+ */
+function getConfig(): array{
+    host: string,
+    port?: int,
+    timeout?: float,
+    ssl?: bool,
+    username?: string,
+    password?: string
+} {
+    // Only host is required, everything else is optional
+    return ['host' => 'localhost'];
+}
+
+/**
+ * Same shape with some optional keys filled
+ */
+function getSecureConfig(): array{
+    host: string,
+    port?: int,
+    timeout?: float,
+    ssl?: bool,
+    username?: string,
+    password?: string
+} {
+    return [
+        'host' => 'secure.example.com',
+        'port' => 443,
+        'ssl' => true,
+        'timeout' => 30.0
+    ];
+}
+
+$config1 = getConfig();
+$config2 = getSecureConfig();
+echo "Config 1 host: {$config1['host']}, port: " . ($config1['port'] ?? 'default') . "\n";
+echo "Config 2 host: {$config2['host']}, port: {$config2['port']}, ssl: " . ($config2['ssl'] ? 'yes' : 'no') . "\n";
+
+
+// =============================================================================
+// ALL OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Shape where all keys are optional (useful for options/settings)
+ */
+function getOptions(): array{
+    debug?: bool,
+    verbose?: bool,
+    color?: bool,
+    format?: string
+} {
+    // Can return empty array since all keys are optional
+    return [];
+}
+
+/**
+ * Same shape with all options set
+ */
+function getFullOptions(): array{
+    debug?: bool,
+    verbose?: bool,
+    color?: bool,
+    format?: string
+} {
+    return [
+        'debug' => true,
+        'verbose' => false,
+        'color' => true,
+        'format' => 'json'
+    ];
+}
+
+$opts1 = getOptions();
+$opts2 = getFullOptions();
+echo "Options 1 debug: " . (isset($opts1['debug']) ? ($opts1['debug'] ? 'yes' : 'no') : 'not set') . "\n";
+echo "Options 2 debug: " . ($opts2['debug'] ? 'yes' : 'no') . ", format: {$opts2['format']}\n";
+
+
+// =============================================================================
+// MIXED REQUIRED AND OPTIONAL
+// =============================================================================
+
+/**
+ * Real-world example: API response shape
+ */
+function getApiResponse(): array{
+    status: int,
+    message: string,
+    data?: array,
+    error?: string,
+    timestamp?: string
+} {
+    return [
+        'status' => 200,
+        'message' => 'Success',
+        'data' => ['items' => [1, 2, 3]],
+        'timestamp' => date('c')
+        // 'error' is intentionally omitted since this is a success response
+    ];
+}
+
+/**
+ * Error response using the same shape
+ */
+function getErrorResponse(): array{
+    status: int,
+    message: string,
+    data?: array,
+    error?: string,
+    timestamp?: string
+} {
+    return [
+        'status' => 500,
+        'message' => 'Internal Server Error',
+        'error' => 'Database connection failed'
+        // 'data' is omitted since this is an error
+    ];
+}
+
+$success = getApiResponse();
+$error = getErrorResponse();
+echo "Success response: status={$success['status']}, has data: " . (isset($success['data']) ? 'yes' : 'no') . "\n";
+echo "Error response: status={$error['status']}, error: {$error['error']}\n";
+
+
+// =============================================================================
+// OPTIONAL KEYS WITH DEFAULTS PATTERN
+// =============================================================================
+
+/**
+ * Function that merges defaults with optional shape keys
+ */
+function createWidget(array{
+    name: string,
+    width?: int,
+    height?: int,
+    color?: string,
+    visible?: bool
+} $config): array{name: string, width: int, height: int, color: string, visible: bool} {
+    // Merge with defaults
+    return [
+        'name' => $config['name'],
+        'width' => $config['width'] ?? 100,
+        'height' => $config['height'] ?? 50,
+        'color' => $config['color'] ?? 'blue',
+        'visible' => $config['visible'] ?? true
+    ];
+}
+
+$widget1 = createWidget(['name' => 'Button']);
+$widget2 = createWidget(['name' => 'Panel', 'width' => 200, 'color' => 'red']);
+echo "Widget 1: {$widget1['name']} ({$widget1['width']}x{$widget1['height']}) color={$widget1['color']}\n";
+echo "Widget 2: {$widget2['name']} ({$widget2['width']}x{$widget2['height']}) color={$widget2['color']}\n";
+
+
+echo "\n--- All optional key examples completed successfully! ---\n";
diff --git a/examples/array-shapes/03-nested-shapes.php b/examples/array-shapes/03-nested-shapes.php
new file mode 100644
index 00000000..86781e2d
--- /dev/null
+++ b/examples/array-shapes/03-nested-shapes.php
@@ -0,0 +1,272 @@
+<?php
+/**
+ * Nested Array Shapes
+ *
+ * Array shapes can be nested within each other to define complex structures.
+ * Syntax: array{key: array{nested_key: type}}
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// SIMPLE NESTING
+// =============================================================================
+
+/**
+ * Shape with one level of nesting
+ */
+function getUserWithAddress(): array{
+    name: string,
+    address: array{street: string, city: string}
+} {
+    return [
+        'name' => 'Alice',
+        'address' => [
+            'street' => '123 Main St',
+            'city' => 'Boston'
+        ]
+    ];
+}
+
+$user = getUserWithAddress();
+echo "User: {$user['name']}, Lives at: {$user['address']['street']}, {$user['address']['city']}\n";
+
+
+// =============================================================================
+// DEEP NESTING
+// =============================================================================
+
+/**
+ * Shape with multiple levels of nesting
+ */
+function getCompanyInfo(): array{
+    name: string,
+    headquarters: array{
+        address: array{
+            street: string,
+            city: string,
+            country: string
+        },
+        contact: array{
+            phone: string,
+            email: string
+        }
+    }
+} {
+    return [
+        'name' => 'Acme Corp',
+        'headquarters' => [
+            'address' => [
+                'street' => '456 Corporate Blvd',
+                'city' => 'New York',
+                'country' => 'USA'
+            ],
+            'contact' => [
+                'phone' => '+1-555-0123',
+                'email' => 'info@acme.com'
+            ]
+        ]
+    ];
+}
+
+$company = getCompanyInfo();
+echo "Company: {$company['name']}\n";
+echo "  Location: {$company['headquarters']['address']['city']}, {$company['headquarters']['address']['country']}\n";
+echo "  Contact: {$company['headquarters']['contact']['email']}\n";
+
+
+// =============================================================================
+// NESTED WITH OPTIONAL KEYS
+// =============================================================================
+
+/**
+ * Nested shapes with optional keys at various levels
+ */
+function getProfile(): array{
+    user: array{
+        id: int,
+        name: string,
+        email?: string
+    },
+    settings?: array{
+        theme?: string,
+        notifications?: bool
+    }
+} {
+    return [
+        'user' => [
+            'id' => 1,
+            'name' => 'Bob'
+            // email is optional
+        ]
+        // settings is optional
+    ];
+}
+
+/**
+ * Same shape with all optional keys filled
+ */
+function getFullProfile(): array{
+    user: array{
+        id: int,
+        name: string,
+        email?: string
+    },
+    settings?: array{
+        theme?: string,
+        notifications?: bool
+    }
+} {
+    return [
+        'user' => [
+            'id' => 2,
+            'name' => 'Carol',
+            'email' => 'carol@example.com'
+        ],
+        'settings' => [
+            'theme' => 'dark',
+            'notifications' => true
+        ]
+    ];
+}
+
+$profile1 = getProfile();
+$profile2 = getFullProfile();
+echo "Profile 1: {$profile1['user']['name']}, email: " . ($profile1['user']['email'] ?? 'not set') . "\n";
+echo "Profile 2: {$profile2['user']['name']}, theme: {$profile2['settings']['theme']}\n";
+
+
+// =============================================================================
+// MULTIPLE NESTED STRUCTURES
+// =============================================================================
+
+/**
+ * Shape with multiple nested structures at the same level
+ */
+function getOrder(): array{
+    order_id: string,
+    customer: array{name: string, email: string},
+    shipping: array{address: string, city: string},
+    billing: array{address: string, city: string},
+    items: array{count: int, total: float}
+} {
+    return [
+        'order_id' => 'ORD-001',
+        'customer' => ['name' => 'Dave', 'email' => 'dave@example.com'],
+        'shipping' => ['address' => '789 Ship Lane', 'city' => 'Portland'],
+        'billing' => ['address' => '789 Ship Lane', 'city' => 'Portland'],
+        'items' => ['count' => 3, 'total' => 149.99]
+    ];
+}
+
+$order = getOrder();
+echo "Order {$order['order_id']} for {$order['customer']['name']}\n";
+echo "  Ship to: {$order['shipping']['city']}\n";
+echo "  Total: \${$order['items']['total']} ({$order['items']['count']} items)\n";
+
+
+// =============================================================================
+// NESTED SHAPE AS PARAMETER
+// =============================================================================
+
+/**
+ * Function accepting nested shape as parameter
+ */
+function processPayment(array{
+    amount: float,
+    card: array{
+        number: string,
+        expiry: string,
+        cvv: string
+    },
+    billing: array{
+        name: string,
+        address: string
+    }
+} $payment): array{success: bool, transaction_id: string} {
+    // Simulate payment processing
+    return [
+        'success' => true,
+        'transaction_id' => 'TXN-' . substr(md5($payment['card']['number']), 0, 8)
+    ];
+}
+
+$result = processPayment([
+    'amount' => 99.99,
+    'card' => [
+        'number' => '4111111111111111',
+        'expiry' => '12/25',
+        'cvv' => '123'
+    ],
+    'billing' => [
+        'name' => 'Eve Smith',
+        'address' => '321 Pay St'
+    ]
+]);
+echo "Payment result: " . ($result['success'] ? 'Success' : 'Failed') . ", ID: {$result['transaction_id']}\n";
+
+
+// =============================================================================
+// DEEPLY NESTED REAL-WORLD EXAMPLE
+// =============================================================================
+
+/**
+ * Complex nested structure: API configuration
+ */
+function getApiConfig(): array{
+    api: array{
+        version: string,
+        endpoints: array{
+            base: string,
+            auth: string
+        }
+    },
+    auth: array{
+        type: string,
+        credentials: array{
+            key: string,
+            secret?: string
+        }
+    },
+    options: array{
+        timeout: int,
+        retry: array{
+            enabled: bool,
+            max_attempts: int
+        }
+    }
+} {
+    return [
+        'api' => [
+            'version' => 'v2',
+            'endpoints' => [
+                'base' => 'https://api.example.com',
+                'auth' => 'https://auth.example.com'
+            ]
+        ],
+        'auth' => [
+            'type' => 'api_key',
+            'credentials' => [
+                'key' => 'my-api-key'
+            ]
+        ],
+        'options' => [
+            'timeout' => 30,
+            'retry' => [
+                'enabled' => true,
+                'max_attempts' => 3
+            ]
+        ]
+    ];
+}
+
+$config = getApiConfig();
+echo "API Config:\n";
+echo "  Version: {$config['api']['version']}\n";
+echo "  Base URL: {$config['api']['endpoints']['base']}\n";
+echo "  Auth type: {$config['auth']['type']}\n";
+echo "  Timeout: {$config['options']['timeout']}s\n";
+echo "  Retry enabled: " . ($config['options']['retry']['enabled'] ? 'yes' : 'no') . "\n";
+
+
+echo "\n--- All nested shape examples completed successfully! ---\n";
diff --git a/examples/array-shapes/04-union-and-nullable-types.php b/examples/array-shapes/04-union-and-nullable-types.php
new file mode 100644
index 00000000..32dbf667
--- /dev/null
+++ b/examples/array-shapes/04-union-and-nullable-types.php
@@ -0,0 +1,265 @@
+<?php
+/**
+ * Union Types and Nullable Types in Array Shapes
+ *
+ * Shape values can use union types (type1|type2) and nullable types (?type).
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// UNION TYPES IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with union type values
+ */
+function getFlexibleId(): array{id: int|string} {
+    return ['id' => 'ABC-123']; // Can be string
+}
+
+function getNumericId(): array{id: int|string} {
+    return ['id' => 42]; // Can also be int
+}
+
+$flex = getFlexibleId();
+$num = getNumericId();
+echo "Flexible ID: {$flex['id']} (type: " . gettype($flex['id']) . ")\n";
+echo "Numeric ID: {$num['id']} (type: " . gettype($num['id']) . ")\n";
+
+
+/**
+ * Multiple union types in a shape
+ */
+function getMixedData(): array{
+    value: int|float|string,
+    status: bool|string,
+    code: int|null
+} {
+    return [
+        'value' => 3.14,
+        'status' => 'active',
+        'code' => null
+    ];
+}
+
+$data = getMixedData();
+echo "Mixed data - value: {$data['value']}, status: {$data['status']}, code: " . ($data['code'] ?? 'null') . "\n";
+
+
+// =============================================================================
+// NULLABLE TYPES IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with nullable type values using ? syntax
+ */
+function getUserWithOptionalEmail(): array{name: string, email: ?string} {
+    return [
+        'name' => 'Alice',
+        'email' => null // Explicitly null
+    ];
+}
+
+function getUserWithEmail(): array{name: string, email: ?string} {
+    return [
+        'name' => 'Bob',
+        'email' => 'bob@example.com'
+    ];
+}
+
+$user1 = getUserWithOptionalEmail();
+$user2 = getUserWithEmail();
+echo "User 1: {$user1['name']}, email: " . ($user1['email'] ?? 'null') . "\n";
+echo "User 2: {$user2['name']}, email: {$user2['email']}\n";
+
+
+/**
+ * Shape with multiple nullable types
+ */
+function getNullableConfig(): array{
+    host: string,
+    port: ?int,
+    timeout: ?float,
+    proxy: ?string
+} {
+    return [
+        'host' => 'localhost',
+        'port' => 8080,
+        'timeout' => null,
+        'proxy' => null
+    ];
+}
+
+$config = getNullableConfig();
+echo "Config - host: {$config['host']}, port: {$config['port']}, timeout: " . ($config['timeout'] ?? 'null') . "\n";
+
+
+// =============================================================================
+// COMBINING UNION AND NULLABLE
+// =============================================================================
+
+/**
+ * Nullable union types
+ */
+function getResult(): array{
+    success: bool,
+    data: string|int|null,
+    error: ?string
+} {
+    return [
+        'success' => true,
+        'data' => 42,
+        'error' => null
+    ];
+}
+
+function getErrorResult(): array{
+    success: bool,
+    data: string|int|null,
+    error: ?string
+} {
+    return [
+        'success' => false,
+        'data' => null,
+        'error' => 'Something went wrong'
+    ];
+}
+
+$success = getResult();
+$error = getErrorResult();
+echo "Success result - data: {$success['data']}\n";
+echo "Error result - error: {$error['error']}\n";
+
+
+// =============================================================================
+// UNION TYPES WITH OBJECTS
+// =============================================================================
+
+class User {
+    public function __construct(public string $name) {}
+}
+
+class Admin {
+    public function __construct(public string $name, public string $role) {}
+}
+
+/**
+ * Shape with object union types
+ */
+function getAccount(): array{
+    id: int,
+    principal: User|Admin
+} {
+    return [
+        'id' => 1,
+        'principal' => new Admin('Alice', 'super')
+    ];
+}
+
+$account = getAccount();
+echo "Account ID: {$account['id']}, Principal: {$account['principal']->name}\n";
+
+
+// =============================================================================
+// COMPLEX UNION EXAMPLES
+// =============================================================================
+
+/**
+ * Real-world example: Database column value
+ */
+function getColumnValue(): array{
+    column: string,
+    value: int|float|string|bool|null,
+    type: string
+} {
+    return [
+        'column' => 'price',
+        'value' => 29.99,
+        'type' => 'decimal'
+    ];
+}
+
+$col = getColumnValue();
+echo "Column '{$col['column']}' = {$col['value']} (type: {$col['type']})\n";
+
+
+/**
+ * Union with array types
+ */
+function getItems(): array{
+    items: array|null,
+    count: int
+} {
+    return [
+        'items' => [1, 2, 3],
+        'count' => 3
+    ];
+}
+
+function getEmptyItems(): array{
+    items: array|null,
+    count: int
+} {
+    return [
+        'items' => null,
+        'count' => 0
+    ];
+}
+
+$items = getItems();
+$empty = getEmptyItems();
+echo "Items: " . ($items['items'] ? implode(', ', $items['items']) : 'none') . "\n";
+echo "Empty items: " . ($empty['items'] ? implode(', ', $empty['items']) : 'none') . "\n";
+
+
+// =============================================================================
+// OPTIONAL VS NULLABLE
+// =============================================================================
+
+/**
+ * Demonstrates the difference between optional keys and nullable types:
+ * - Optional key (key?): The key may be absent from the array
+ * - Nullable type (?type): The key must be present but can have null value
+ */
+
+// Optional: key may not exist
+function withOptionalKey(): array{name: string, age?: int} {
+    return ['name' => 'Alice']; // 'age' key is completely absent
+}
+
+// Nullable: key exists but value is null
+function withNullableValue(): array{name: string, age: ?int} {
+    return ['name' => 'Bob', 'age' => null]; // 'age' key must exist, but value can be null
+}
+
+$opt = withOptionalKey();
+$null = withNullableValue();
+echo "Optional - has 'age' key: " . (array_key_exists('age', $opt) ? 'yes' : 'no') . "\n";
+echo "Nullable - has 'age' key: " . (array_key_exists('age', $null) ? 'yes' : 'no') . ", value: " . ($null['age'] ?? 'null') . "\n";
+
+
+// =============================================================================
+// COMBINING OPTIONAL AND NULLABLE
+// =============================================================================
+
+/**
+ * Optional key with nullable type: key may be absent, or present with null/value
+ */
+function getContact(): array{
+    phone: string,
+    fax?: ?string,  // Optional AND nullable
+    email?: string  // Just optional (if present, must be string)
+} {
+    return [
+        'phone' => '555-0100',
+        'fax' => null  // Present but null
+        // email is absent
+    ];
+}
+
+$contact = getContact();
+echo "Contact - phone: {$contact['phone']}, fax: " . (array_key_exists('fax', $contact) ? ($contact['fax'] ?? 'null') : 'not set') . "\n";
+
+
+echo "\n--- All union and nullable type examples completed successfully! ---\n";
diff --git a/examples/array-shapes/05-shapes-with-typed-arrays.php b/examples/array-shapes/05-shapes-with-typed-arrays.php
new file mode 100644
index 00000000..ad4ad6da
--- /dev/null
+++ b/examples/array-shapes/05-shapes-with-typed-arrays.php
@@ -0,0 +1,290 @@
+<?php
+/**
+ * Combining Array Shapes with Typed Arrays (array<T>)
+ *
+ * Array shapes can contain typed array values, and typed arrays can contain shapes.
+ * This allows for powerful type definitions like array<array{id: int, name: string}>
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// TYPED ARRAYS INSIDE SHAPES
+// =============================================================================
+
+/**
+ * Shape with a typed array value
+ */
+function getNumberList(): array{name: string, values: array<int>} {
+    return [
+        'name' => 'Prime numbers',
+        'values' => [2, 3, 5, 7, 11, 13]
+    ];
+}
+
+$list = getNumberList();
+echo "List '{$list['name']}': " . implode(', ', $list['values']) . "\n";
+
+
+/**
+ * Shape with multiple typed array values
+ */
+function getDataSets(): array{
+    integers: array<int>,
+    floats: array<float>,
+    strings: array<string>
+} {
+    return [
+        'integers' => [1, 2, 3],
+        'floats' => [1.1, 2.2, 3.3],
+        'strings' => ['a', 'b', 'c']
+    ];
+}
+
+$sets = getDataSets();
+echo "Integers: " . implode(', ', $sets['integers']) . "\n";
+echo "Floats: " . implode(', ', $sets['floats']) . "\n";
+echo "Strings: " . implode(', ', $sets['strings']) . "\n";
+
+
+// =============================================================================
+// TYPED ARRAYS OF SHAPES (Lists of Objects)
+// =============================================================================
+
+/**
+ * Typed array containing shapes - perfect for list of records
+ */
+function getUsers(): array<array{id: int, name: string, active: bool}> {
+    return [
+        ['id' => 1, 'name' => 'Alice', 'active' => true],
+        ['id' => 2, 'name' => 'Bob', 'active' => false],
+        ['id' => 3, 'name' => 'Carol', 'active' => true]
+    ];
+}
+
+$users = getUsers();
+echo "Users:\n";
+foreach ($users as $user) {
+    echo "  - {$user['name']} (ID: {$user['id']}, " . ($user['active'] ? 'active' : 'inactive') . ")\n";
+}
+
+
+/**
+ * Typed array with more complex shapes
+ */
+function getOrders(): array<array{
+    order_id: string,
+    amount: float,
+    status: string,
+    created: string
+}> {
+    return [
+        ['order_id' => 'ORD-001', 'amount' => 99.99, 'status' => 'pending', 'created' => '2024-01-15'],
+        ['order_id' => 'ORD-002', 'amount' => 149.50, 'status' => 'shipped', 'created' => '2024-01-16'],
+        ['order_id' => 'ORD-003', 'amount' => 29.99, 'status' => 'delivered', 'created' => '2024-01-17']
+    ];
+}
+
+$orders = getOrders();
+echo "Orders:\n";
+foreach ($orders as $order) {
+    echo "  - {$order['order_id']}: \${$order['amount']} ({$order['status']})\n";
+}
+
+
+// =============================================================================
+// SHAPES WITH OPTIONAL KEYS IN TYPED ARRAYS
+// =============================================================================
+
+/**
+ * Typed array of shapes with optional keys
+ */
+function getContacts(): array<array{name: string, email: string, phone?: string}> {
+    return [
+        ['name' => 'Alice', 'email' => 'alice@example.com', 'phone' => '555-0101'],
+        ['name' => 'Bob', 'email' => 'bob@example.com'], // phone is optional
+        ['name' => 'Carol', 'email' => 'carol@example.com', 'phone' => '555-0103']
+    ];
+}
+
+$contacts = getContacts();
+echo "Contacts:\n";
+foreach ($contacts as $contact) {
+    echo "  - {$contact['name']}: {$contact['email']}" . (isset($contact['phone']) ? " ({$contact['phone']})" : "") . "\n";
+}
+
+
+// =============================================================================
+// NESTED: SHAPE WITH TYPED ARRAY OF SHAPES
+// =============================================================================
+
+/**
+ * Shape containing a typed array of shapes
+ */
+function getDepartment(): array{
+    name: string,
+    budget: float,
+    employees: array<array{id: int, name: string, role: string}>
+} {
+    return [
+        'name' => 'Engineering',
+        'budget' => 500000.00,
+        'employees' => [
+            ['id' => 1, 'name' => 'Alice', 'role' => 'Lead'],
+            ['id' => 2, 'name' => 'Bob', 'role' => 'Senior'],
+            ['id' => 3, 'name' => 'Carol', 'role' => 'Junior']
+        ]
+    ];
+}
+
+$dept = getDepartment();
+echo "Department: {$dept['name']} (Budget: \${$dept['budget']})\n";
+echo "  Employees:\n";
+foreach ($dept['employees'] as $emp) {
+    echo "    - {$emp['name']} ({$emp['role']})\n";
+}
+
+
+// =============================================================================
+// COMPLEX: MULTIPLE TYPED ARRAYS IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with multiple typed array fields
+ */
+function getProject(): array{
+    id: string,
+    name: string,
+    tags: array<string>,
+    members: array<array{user_id: int, role: string}>,
+    milestones: array<array{name: string, date: string, completed: bool}>
+} {
+    return [
+        'id' => 'PRJ-001',
+        'name' => 'Website Redesign',
+        'tags' => ['web', 'design', 'frontend'],
+        'members' => [
+            ['user_id' => 1, 'role' => 'lead'],
+            ['user_id' => 2, 'role' => 'developer']
+        ],
+        'milestones' => [
+            ['name' => 'Design', 'date' => '2024-02-01', 'completed' => true],
+            ['name' => 'Development', 'date' => '2024-03-01', 'completed' => false]
+        ]
+    ];
+}
+
+$project = getProject();
+echo "Project: {$project['name']}\n";
+echo "  Tags: " . implode(', ', $project['tags']) . "\n";
+echo "  Members: " . count($project['members']) . "\n";
+echo "  Milestones:\n";
+foreach ($project['milestones'] as $ms) {
+    echo "    - {$ms['name']}: " . ($ms['completed'] ? 'done' : 'pending') . "\n";
+}
+
+
+// =============================================================================
+// KEYED TYPED ARRAYS IN SHAPES
+// =============================================================================
+
+/**
+ * Shape with keyed (associative) typed array
+ */
+function getSettings(): array{
+    app_name: string,
+    features: array<string, bool>,
+    limits: array<string, int>
+} {
+    return [
+        'app_name' => 'MyApp',
+        'features' => [
+            'dark_mode' => true,
+            'notifications' => false,
+            'analytics' => true
+        ],
+        'limits' => [
+            'max_users' => 100,
+            'max_storage' => 1024,
+            'max_requests' => 1000
+        ]
+    ];
+}
+
+$settings = getSettings();
+echo "App: {$settings['app_name']}\n";
+echo "  Features:\n";
+foreach ($settings['features'] as $feature => $enabled) {
+    echo "    - {$feature}: " . ($enabled ? 'on' : 'off') . "\n";
+}
+echo "  Limits:\n";
+foreach ($settings['limits'] as $limit => $value) {
+    echo "    - {$limit}: {$value}\n";
+}
+
+
+// =============================================================================
+// KEYED TYPED ARRAYS OF SHAPES
+// =============================================================================
+
+/**
+ * Associative array of shapes (keyed by string)
+ */
+function getUsersById(): array<string, array{name: string, email: string}> {
+    return [
+        'user_1' => ['name' => 'Alice', 'email' => 'alice@example.com'],
+        'user_2' => ['name' => 'Bob', 'email' => 'bob@example.com'],
+        'user_3' => ['name' => 'Carol', 'email' => 'carol@example.com']
+    ];
+}
+
+$usersById = getUsersById();
+echo "Users by ID:\n";
+foreach ($usersById as $id => $user) {
+    echo "  - {$id}: {$user['name']} <{$user['email']}>\n";
+}
+
+
+/**
+ * Integer-keyed array of shapes
+ */
+function getIndexedProducts(): array<int, array{sku: string, name: string, price: float}> {
+    return [
+        100 => ['sku' => 'WIDGET-A', 'name' => 'Widget A', 'price' => 9.99],
+        200 => ['sku' => 'WIDGET-B', 'name' => 'Widget B', 'price' => 19.99],
+        300 => ['sku' => 'WIDGET-C', 'name' => 'Widget C', 'price' => 29.99]
+    ];
+}
+
+$products = getIndexedProducts();
+echo "Products by index:\n";
+foreach ($products as $idx => $product) {
+    echo "  - [{$idx}] {$product['name']} (\${$product['price']})\n";
+}
+
+
+// =============================================================================
+// PARAMETER: TYPED ARRAY OF SHAPES
+// =============================================================================
+
+/**
+ * Function accepting typed array of shapes as parameter
+ */
+function calculateTotal(array<array{quantity: int, price: float}> $items): float {
+    $total = 0.0;
+    foreach ($items as $item) {
+        $total += $item['quantity'] * $item['price'];
+    }
+    return $total;
+}
+
+$cart = [
+    ['quantity' => 2, 'price' => 10.00],
+    ['quantity' => 1, 'price' => 25.50],
+    ['quantity' => 3, 'price' => 5.00]
+];
+$total = calculateTotal($cart);
+echo "Cart total: \${$total}\n";
+
+
+echo "\n--- All typed array with shapes examples completed successfully! ---\n";
diff --git a/examples/array-shapes/06-classes-and-interfaces.php b/examples/array-shapes/06-classes-and-interfaces.php
new file mode 100644
index 00000000..9cc96cc2
--- /dev/null
+++ b/examples/array-shapes/06-classes-and-interfaces.php
@@ -0,0 +1,353 @@
+<?php
+/**
+ * Array Shapes with Classes, Interfaces, and Traits
+ *
+ * Array shapes can be used in class methods, properties, interfaces, and traits.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// CLASS METHODS WITH ARRAY SHAPES
+// =============================================================================
+
+class UserRepository
+{
+    /**
+     * Method returning an array shape
+     */
+    public function findById(int $id): array{id: int, name: string, email: string} {
+        return [
+            'id' => $id,
+            'name' => 'User ' . $id,
+            'email' => "user{$id}@example.com"
+        ];
+    }
+
+    /**
+     * Method accepting array shape as parameter
+     */
+    public function create(array{name: string, email: string, password?: string} $data): array{id: int, name: string, email: string} {
+        return [
+            'id' => rand(1000, 9999),
+            'name' => $data['name'],
+            'email' => $data['email']
+        ];
+    }
+
+    /**
+     * Method returning array of shapes
+     */
+    public function findAll(): array<array{id: int, name: string, email: string}> {
+        return [
+            ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'],
+            ['id' => 2, 'name' => 'Bob', 'email' => 'bob@example.com']
+        ];
+    }
+}
+
+$repo = new UserRepository();
+$user = $repo->findById(42);
+echo "Found user: {$user['name']} <{$user['email']}>\n";
+
+$newUser = $repo->create(['name' => 'Carol', 'email' => 'carol@example.com']);
+echo "Created user: {$newUser['name']} (ID: {$newUser['id']})\n";
+
+$all = $repo->findAll();
+echo "All users: " . count($all) . "\n";
+
+
+// =============================================================================
+// INTERFACE WITH ARRAY SHAPES
+// =============================================================================
+
+interface ConfigProviderInterface
+{
+    /**
+     * Interface method with shape return type
+     */
+    public function getConfig(): array{
+        debug: bool,
+        environment: string,
+        features: array<string>
+    };
+
+    /**
+     * Interface method with shape parameter
+     */
+    public function setConfig(array{
+        debug?: bool,
+        environment?: string,
+        features?: array<string>
+    } $config): void;
+}
+
+class AppConfigProvider implements ConfigProviderInterface
+{
+    private bool $debug = false;
+    private string $environment = 'production';
+    private array $features = [];
+
+    public function getConfig(): array{
+        debug: bool,
+        environment: string,
+        features: array<string>
+    } {
+        return [
+            'debug' => $this->debug,
+            'environment' => $this->environment,
+            'features' => $this->features
+        ];
+    }
+
+    public function setConfig(array{
+        debug?: bool,
+        environment?: string,
+        features?: array<string>
+    } $config): void {
+        if (isset($config['debug'])) {
+            $this->debug = $config['debug'];
+        }
+        if (isset($config['environment'])) {
+            $this->environment = $config['environment'];
+        }
+        if (isset($config['features'])) {
+            $this->features = $config['features'];
+        }
+    }
+}
+
+$configProvider = new AppConfigProvider();
+$configProvider->setConfig(['debug' => true, 'environment' => 'development']);
+$config = $configProvider->getConfig();
+echo "Config - debug: " . ($config['debug'] ? 'yes' : 'no') . ", env: {$config['environment']}\n";
+
+
+// =============================================================================
+// ABSTRACT CLASS WITH ARRAY SHAPES
+// =============================================================================
+
+abstract class BaseApiClient
+{
+    /**
+     * Abstract method with shape return type
+     */
+    abstract public function request(string $method, string $endpoint): array{
+        status: int,
+        body: mixed,
+        headers: array<string>
+    };
+
+    /**
+     * Concrete method using shapes
+     */
+    protected function buildResponse(
+        int $status,
+        mixed $body
+    ): array{status: int, body: mixed, headers: array<string>} {
+        return [
+            'status' => $status,
+            'body' => $body,
+            'headers' => ['Content-Type: application/json']
+        ];
+    }
+}
+
+class MockApiClient extends BaseApiClient
+{
+    public function request(string $method, string $endpoint): array{
+        status: int,
+        body: mixed,
+        headers: array<string>
+    } {
+        return $this->buildResponse(200, ['success' => true]);
+    }
+}
+
+$client = new MockApiClient();
+$response = $client->request('GET', '/users');
+echo "API response status: {$response['status']}\n";
+
+
+// =============================================================================
+// TRAIT WITH ARRAY SHAPES
+// =============================================================================
+
+trait Auditable
+{
+    /**
+     * Trait method returning shape
+     */
+    public function getAuditInfo(): array{
+        created_at: string,
+        updated_at: string,
+        created_by: ?int,
+        updated_by: ?int
+    } {
+        return [
+            'created_at' => '2024-01-15 10:00:00',
+            'updated_at' => '2024-01-16 15:30:00',
+            'created_by' => 1,
+            'updated_by' => 2
+        ];
+    }
+}
+
+class Document
+{
+    use Auditable;
+
+    public function __construct(
+        public string $title
+    ) {}
+}
+
+$doc = new Document('My Document');
+$audit = $doc->getAuditInfo();
+echo "Document '{$doc->title}' created at: {$audit['created_at']}\n";
+
+
+// =============================================================================
+// STATIC METHODS WITH ARRAY SHAPES
+// =============================================================================
+
+class Factory
+{
+    /**
+     * Static factory method returning shape
+     */
+    public static function createProduct(
+        string $name,
+        float $price
+    ): array{id: string, name: string, price: float, created: string} {
+        return [
+            'id' => uniqid('prod_'),
+            'name' => $name,
+            'price' => $price,
+            'created' => date('Y-m-d H:i:s')
+        ];
+    }
+
+    /**
+     * Static method returning array of shapes
+     */
+    public static function createBatch(
+        array<string> $names,
+        float $price
+    ): array<array{id: string, name: string, price: float, created: string}> {
+        $products = [];
+        foreach ($names as $name) {
+            $products[] = self::createProduct($name, $price);
+        }
+        return $products;
+    }
+}
+
+$product = Factory::createProduct('Widget', 9.99);
+echo "Product: {$product['name']} - \${$product['price']}\n";
+
+$batch = Factory::createBatch(['A', 'B', 'C'], 5.99);
+echo "Batch created: " . count($batch) . " products\n";
+
+
+// =============================================================================
+// CLASS WITH TYPED PROPERTIES (Array Shapes in Properties)
+// =============================================================================
+
+class Order
+{
+    /**
+     * Property with array shape type
+     */
+    public array $customer; // Type enforced at runtime when strict_arrays=1
+
+    /**
+     * Property with typed array of shapes
+     */
+    public array $items;
+
+    public function __construct(
+        array $customer,
+        array $items
+    ) {
+        $this->customer = $customer;
+        $this->items = $items;
+    }
+
+    public function getCustomer(): array{name: string, email: string} {
+        return $this->customer;
+    }
+
+    public function getItems(): array<array{sku: string, qty: int, price: float}> {
+        return $this->items;
+    }
+
+    public function getTotal(): float {
+        $total = 0.0;
+        foreach ($this->items as $item) {
+            $total += $item['qty'] * $item['price'];
+        }
+        return $total;
+    }
+}
+
+$order = new Order(
+    ['name' => 'John', 'email' => 'john@example.com'],
+    [
+        ['sku' => 'ABC', 'qty' => 2, 'price' => 10.00],
+        ['sku' => 'DEF', 'qty' => 1, 'price' => 25.00]
+    ]
+);
+echo "Order for: {$order->getCustomer()['name']}\n";
+echo "Total: \${$order->getTotal()}\n";
+
+
+// =============================================================================
+// FLUENT INTERFACE WITH ARRAY SHAPES
+// =============================================================================
+
+class QueryBuilder
+{
+    private array $conditions = [];
+    private array $orderBy = [];
+    private ?int $limit = null;
+
+    public function where(array{field: string, operator: string, value: mixed} $condition): self {
+        $this->conditions[] = $condition;
+        return $this;
+    }
+
+    public function orderBy(array{field: string, direction: string} $order): self {
+        $this->orderBy[] = $order;
+        return $this;
+    }
+
+    public function limit(int $limit): self {
+        $this->limit = $limit;
+        return $this;
+    }
+
+    public function build(): array{
+        conditions: array<array{field: string, operator: string, value: mixed}>,
+        order_by: array<array{field: string, direction: string}>,
+        limit: ?int
+    } {
+        return [
+            'conditions' => $this->conditions,
+            'order_by' => $this->orderBy,
+            'limit' => $this->limit
+        ];
+    }
+}
+
+$query = (new QueryBuilder())
+    ->where(['field' => 'status', 'operator' => '=', 'value' => 'active'])
+    ->where(['field' => 'age', 'operator' => '>', 'value' => 18])
+    ->orderBy(['field' => 'name', 'direction' => 'ASC'])
+    ->limit(10)
+    ->build();
+
+echo "Query - conditions: " . count($query['conditions']) . ", limit: {$query['limit']}\n";
+
+
+echo "\n--- All class and interface examples completed successfully! ---\n";
diff --git a/examples/array-shapes/07-closures-and-callables.php b/examples/array-shapes/07-closures-and-callables.php
new file mode 100644
index 00000000..3c251c46
--- /dev/null
+++ b/examples/array-shapes/07-closures-and-callables.php
@@ -0,0 +1,294 @@
+<?php
+/**
+ * Array Shapes with Closures and Callable Types
+ *
+ * Array shapes can be used with closures, arrow functions, and callable parameters.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// CLOSURES WITH ARRAY SHAPE RETURN TYPES
+// =============================================================================
+
+/**
+ * Closure returning an array shape
+ */
+$createUser = function(string $name, string $email): array{id: int, name: string, email: string} {
+    return [
+        'id' => rand(1, 1000),
+        'name' => $name,
+        'email' => $email
+    ];
+};
+
+$user = $createUser('Alice', 'alice@example.com');
+echo "Created user: {$user['name']} <{$user['email']}>\n";
+
+
+/**
+ * Closure with array shape parameter
+ */
+$formatUser = function(array{name: string, email: string} $user): string {
+    return "{$user['name']} <{$user['email']}>";
+};
+
+echo "Formatted: " . $formatUser(['name' => 'Bob', 'email' => 'bob@example.com']) . "\n";
+
+
+// =============================================================================
+// ARROW FUNCTIONS WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Arrow function returning array shape
+ */
+$getPoint = fn(int $x, int $y): array{x: int, y: int} => ['x' => $x, 'y' => $y];
+
+$point = $getPoint(10, 20);
+echo "Point: ({$point['x']}, {$point['y']})\n";
+
+
+/**
+ * Arrow function with array shape parameter
+ */
+$distance = fn(array{x: int, y: int} $p): float => sqrt($p['x'] ** 2 + $p['y'] ** 2);
+
+echo "Distance from origin: " . round($distance(['x' => 3, 'y' => 4]), 2) . "\n";
+
+
+// =============================================================================
+// HIGHER-ORDER FUNCTIONS WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Function accepting closure that returns array shape
+ */
+function processWithTransformer(
+    array $data,
+    Closure $transformer
+): array<array{id: int, value: string}> {
+    $results = [];
+    foreach ($data as $key => $value) {
+        $results[] = $transformer($key, $value);
+    }
+    return $results;
+}
+
+$items = ['foo' => 'bar', 'baz' => 'qux'];
+$transformed = processWithTransformer(
+    $items,
+    fn($k, $v): array{id: int, value: string} => ['id' => crc32($k), 'value' => $v]
+);
+echo "Transformed items: " . count($transformed) . "\n";
+
+
+/**
+ * Function returning a closure that uses array shapes
+ */
+function createValidator(array{min: int, max: int} $range): Closure {
+    return function(int $value) use ($range): array{valid: bool, message: string} {
+        if ($value < $range['min']) {
+            return ['valid' => false, 'message' => "Value must be at least {$range['min']}"];
+        }
+        if ($value > $range['max']) {
+            return ['valid' => false, 'message' => "Value must be at most {$range['max']}"];
+        }
+        return ['valid' => true, 'message' => 'OK'];
+    };
+}
+
+$validateAge = createValidator(['min' => 0, 'max' => 150]);
+$result = $validateAge(25);
+echo "Validation: " . ($result['valid'] ? 'passed' : 'failed') . " - {$result['message']}\n";
+
+
+// =============================================================================
+// ARRAY_MAP WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Using array_map with closures that have array shape types
+ */
+$numbers = [1, 2, 3, 4, 5];
+
+$wrapped = array_map(
+    fn(int $n): array{value: int, squared: int} => ['value' => $n, 'squared' => $n * $n],
+    $numbers
+);
+
+echo "Wrapped numbers:\n";
+foreach ($wrapped as $item) {
+    echo "  {$item['value']} => {$item['squared']}\n";
+}
+
+
+// =============================================================================
+// ARRAY_FILTER WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Filtering an array of shapes
+ */
+$users = [
+    ['id' => 1, 'name' => 'Alice', 'active' => true],
+    ['id' => 2, 'name' => 'Bob', 'active' => false],
+    ['id' => 3, 'name' => 'Carol', 'active' => true]
+];
+
+/** @var array<array{id: int, name: string, active: bool}> $activeUsers */
+$activeUsers = array_filter(
+    $users,
+    fn(array{id: int, name: string, active: bool} $user): bool => $user['active']
+);
+
+echo "Active users: " . count($activeUsers) . "\n";
+
+
+// =============================================================================
+// ARRAY_REDUCE WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Reducing array of shapes to a single shape
+ */
+$orders = [
+    ['product' => 'Widget', 'qty' => 2, 'price' => 10.0],
+    ['product' => 'Gadget', 'qty' => 1, 'price' => 25.0],
+    ['product' => 'Thing', 'qty' => 3, 'price' => 5.0]
+];
+
+$summary = array_reduce(
+    $orders,
+    function(array{total_items: int, total_amount: float} $carry, array{product: string, qty: int, price: float} $item): array{total_items: int, total_amount: float} {
+        return [
+            'total_items' => $carry['total_items'] + $item['qty'],
+            'total_amount' => $carry['total_amount'] + ($item['qty'] * $item['price'])
+        ];
+    },
+    ['total_items' => 0, 'total_amount' => 0.0]
+);
+
+echo "Order summary: {$summary['total_items']} items, \${$summary['total_amount']}\n";
+
+
+// =============================================================================
+// USORT WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Sorting array of shapes
+ */
+$products = [
+    ['name' => 'Banana', 'price' => 0.50],
+    ['name' => 'Apple', 'price' => 1.00],
+    ['name' => 'Cherry', 'price' => 2.50]
+];
+
+usort($products, fn(array{name: string, price: float} $a, array{name: string, price: float} $b): int =>
+    $a['price'] <=> $b['price']
+);
+
+echo "Products by price:\n";
+foreach ($products as $p) {
+    echo "  {$p['name']}: \${$p['price']}\n";
+}
+
+
+// =============================================================================
+// CALLABLE RETURNING CLOSURES WITH SHAPES
+// =============================================================================
+
+/**
+ * Factory function returning typed closures
+ */
+function createCounter(int $start = 0): Closure {
+    $count = $start;
+    return function() use (&$count): array{current: int, next: int} {
+        $current = $count++;
+        return ['current' => $current, 'next' => $count];
+    };
+}
+
+$counter = createCounter(10);
+$step1 = $counter();
+$step2 = $counter();
+echo "Counter: step1={$step1['current']}, step2={$step2['current']}, next={$step2['next']}\n";
+
+
+// =============================================================================
+// CLOSURE WITH USE AND ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Closure capturing external variables
+ */
+$config = ['prefix' => 'USER_', 'suffix' => '_ID'];
+
+$formatId = function(int $id) use ($config): array{raw: int, formatted: string} {
+    return [
+        'raw' => $id,
+        'formatted' => $config['prefix'] . $id . $config['suffix']
+    ];
+};
+
+$formatted = $formatId(42);
+echo "ID: {$formatted['raw']} => {$formatted['formatted']}\n";
+
+
+// =============================================================================
+// RECURSIVE CLOSURES WITH ARRAY SHAPES
+// =============================================================================
+
+/**
+ * Recursive closure building a tree structure
+ */
+$buildTree = function(int $depth, string $prefix = '') use (&$buildTree): array{
+    name: string,
+    children: array
+} {
+    $name = $prefix . 'Node_' . $depth;
+    $children = [];
+
+    if ($depth > 0) {
+        $children[] = $buildTree($depth - 1, $prefix . 'L');
+        $children[] = $buildTree($depth - 1, $prefix . 'R');
+    }
+
+    return [
+        'name' => $name,
+        'children' => $children
+    ];
+};
+
+$tree = $buildTree(2);
+echo "Tree root: {$tree['name']}, children: " . count($tree['children']) . "\n";
+
+
+// =============================================================================
+// FIRST-CLASS CALLABLES WITH ARRAY SHAPES
+// =============================================================================
+
+class Formatter
+{
+    public function formatUser(array{name: string, email: string} $user): string {
+        return "{$user['name']} <{$user['email']}>";
+    }
+}
+
+$formatter = new Formatter();
+$formatFn = $formatter->formatUser(...);  // First-class callable
+
+$users = [
+    ['name' => 'Alice', 'email' => 'alice@example.com'],
+    ['name' => 'Bob', 'email' => 'bob@example.com']
+];
+
+$formatted = array_map($formatFn, $users);
+echo "Formatted users:\n";
+foreach ($formatted as $f) {
+    echo "  - {$f}\n";
+}
+
+
+echo "\n--- All closure and callable examples completed successfully! ---\n";
diff --git a/examples/array-shapes/08-reflection-api.php b/examples/array-shapes/08-reflection-api.php
new file mode 100644
index 00000000..cad597d5
--- /dev/null
+++ b/examples/array-shapes/08-reflection-api.php
@@ -0,0 +1,331 @@
+<?php
+/**
+ * Reflection API for Array Shapes
+ *
+ * The ReflectionArrayShapeType and ReflectionArrayShapeElement classes
+ * allow runtime inspection of array shape types.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC REFLECTION OF ARRAY SHAPES
+// =============================================================================
+
+function getUserProfile(): array{id: int, name: string, email: string, active: bool} {
+    return ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com', 'active' => true];
+}
+
+// Get reflection of the function
+$reflection = new ReflectionFunction('getUserProfile');
+$returnType = $reflection->getReturnType();
+
+echo "=== Basic Reflection ===\n";
+echo "Return type class: " . get_class($returnType) . "\n";
+echo "Is array shape: " . ($returnType instanceof ReflectionArrayShapeType ? 'yes' : 'no') . "\n";
+echo "Type as string: " . (string)$returnType . "\n";
+echo "\n";
+
+
+// =============================================================================
+// INSPECTING SHAPE ELEMENTS
+// =============================================================================
+
+echo "=== Shape Elements ===\n";
+
+$elements = $returnType->getElements();
+echo "Number of elements: " . count($elements) . "\n";
+echo "Element count method: " . $returnType->getElementCount() . "\n";
+echo "Required elements: " . $returnType->getRequiredElementCount() . "\n";
+echo "\n";
+
+echo "Elements:\n";
+foreach ($elements as $element) {
+    echo "  - Name: " . $element->getName() . "\n";
+    echo "    Type: " . (string)$element->getType() . "\n";
+    echo "    Optional: " . ($element->isOptional() ? 'yes' : 'no') . "\n";
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION WITH OPTIONAL KEYS
+// =============================================================================
+
+function getConfig(): array{host: string, port?: int, ssl?: bool, timeout?: float} {
+    return ['host' => 'localhost'];
+}
+
+echo "=== Optional Keys Reflection ===\n";
+
+$configReflection = new ReflectionFunction('getConfig');
+$configType = $configReflection->getReturnType();
+
+echo "Total elements: " . $configType->getElementCount() . "\n";
+echo "Required elements: " . $configType->getRequiredElementCount() . "\n";
+echo "\n";
+
+foreach ($configType->getElements() as $elem) {
+    $status = $elem->isOptional() ? 'optional' : 'required';
+    echo "  - {$elem->getName()}: {$elem->getType()} ({$status})\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// REFLECTION OF NESTED SHAPES
+// =============================================================================
+
+function getNestedData(): array{
+    user: array{id: int, name: string},
+    settings: array{theme: string, language: string}
+} {
+    return [
+        'user' => ['id' => 1, 'name' => 'Alice'],
+        'settings' => ['theme' => 'dark', 'language' => 'en']
+    ];
+}
+
+echo "=== Nested Shapes Reflection ===\n";
+
+$nestedReflection = new ReflectionFunction('getNestedData');
+$nestedType = $nestedReflection->getReturnType();
+
+foreach ($nestedType->getElements() as $elem) {
+    echo "Element: {$elem->getName()}\n";
+    $elemType = $elem->getType();
+    echo "  Type class: " . get_class($elemType) . "\n";
+
+    if ($elemType instanceof ReflectionArrayShapeType) {
+        echo "  Nested elements:\n";
+        foreach ($elemType->getElements() as $nested) {
+            echo "    - {$nested->getName()}: {$nested->getType()}\n";
+        }
+    }
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION OF UNION TYPES IN SHAPES
+// =============================================================================
+
+function getFlexibleData(): array{id: int|string, value: float|int|null} {
+    return ['id' => 'ABC', 'value' => null];
+}
+
+echo "=== Union Types in Shapes ===\n";
+
+$flexReflection = new ReflectionFunction('getFlexibleData');
+$flexType = $flexReflection->getReturnType();
+
+foreach ($flexType->getElements() as $elem) {
+    $elemType = $elem->getType();
+    echo "Element: {$elem->getName()}\n";
+    echo "  Type: {$elemType}\n";
+    echo "  Type class: " . get_class($elemType) . "\n";
+
+    if ($elemType instanceof ReflectionUnionType) {
+        echo "  Union members:\n";
+        foreach ($elemType->getTypes() as $unionMember) {
+            echo "    - {$unionMember}\n";
+        }
+    }
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION OF PARAMETER TYPES
+// =============================================================================
+
+function processOrder(array{product: string, quantity: int, price: float} $order): float {
+    return $order['quantity'] * $order['price'];
+}
+
+echo "=== Parameter Type Reflection ===\n";
+
+$orderReflection = new ReflectionFunction('processOrder');
+$params = $orderReflection->getParameters();
+
+foreach ($params as $param) {
+    echo "Parameter: \${$param->getName()}\n";
+    $paramType = $param->getType();
+    echo "  Type class: " . get_class($paramType) . "\n";
+
+    if ($paramType instanceof ReflectionArrayShapeType) {
+        echo "  Shape elements:\n";
+        foreach ($paramType->getElements() as $elem) {
+            echo "    - {$elem->getName()}: {$elem->getType()}\n";
+        }
+    }
+    echo "\n";
+}
+
+
+// =============================================================================
+// REFLECTION OF CLASS METHODS
+// =============================================================================
+
+class UserService
+{
+    public function create(
+        array{name: string, email: string, password?: string} $data
+    ): array{id: int, name: string, email: string, created_at: string} {
+        return [
+            'id' => 1,
+            'name' => $data['name'],
+            'email' => $data['email'],
+            'created_at' => date('c')
+        ];
+    }
+}
+
+echo "=== Class Method Reflection ===\n";
+
+$methodReflection = new ReflectionMethod(UserService::class, 'create');
+
+// Reflect parameter
+$paramType = $methodReflection->getParameters()[0]->getType();
+echo "Parameter type (create):\n";
+if ($paramType instanceof ReflectionArrayShapeType) {
+    foreach ($paramType->getElements() as $elem) {
+        $opt = $elem->isOptional() ? '?' : '';
+        echo "  - {$elem->getName()}{$opt}: {$elem->getType()}\n";
+    }
+}
+
+// Reflect return type
+$returnType = $methodReflection->getReturnType();
+echo "\nReturn type:\n";
+if ($returnType instanceof ReflectionArrayShapeType) {
+    foreach ($returnType->getElements() as $elem) {
+        echo "  - {$elem->getName()}: {$elem->getType()}\n";
+    }
+}
+echo "\n";
+
+
+// =============================================================================
+// DYNAMIC TYPE CHECKING USING REFLECTION
+// =============================================================================
+
+echo "=== Dynamic Type Checking ===\n";
+
+function validateAgainstShape(array $data, ReflectionArrayShapeType $shape): array {
+    $errors = [];
+
+    foreach ($shape->getElements() as $elem) {
+        $key = $elem->getName();
+
+        // Check if required key is missing
+        if (!array_key_exists($key, $data)) {
+            if (!$elem->isOptional()) {
+                $errors[] = "Missing required key: {$key}";
+            }
+            continue;
+        }
+
+        // Get the expected type as string
+        $expectedType = (string)$elem->getType();
+        $actualType = gettype($data[$key]);
+
+        echo "  Checking '{$key}': expected={$expectedType}, actual={$actualType}\n";
+    }
+
+    return $errors;
+}
+
+// Test validation
+$testData = ['id' => 1, 'name' => 'Test'];
+$shapeType = (new ReflectionFunction('getUserProfile'))->getReturnType();
+
+echo "Validating test data against getUserProfile shape:\n";
+$errors = validateAgainstShape($testData, $shapeType);
+if ($errors) {
+    echo "Errors found:\n";
+    foreach ($errors as $error) {
+        echo "  - {$error}\n";
+    }
+}
+echo "\n";
+
+
+// =============================================================================
+// BUILDING DOCUMENTATION FROM REFLECTION
+// =============================================================================
+
+echo "=== Auto-Generated Documentation ===\n";
+
+function generateShapeDoc(ReflectionArrayShapeType $shape): string {
+    $doc = "Shape structure:\n";
+    $doc .= "```\n";
+    $doc .= "array{\n";
+
+    foreach ($shape->getElements() as $elem) {
+        $optional = $elem->isOptional() ? '?' : '';
+        $doc .= "    {$elem->getName()}{$optional}: {$elem->getType()},\n";
+    }
+
+    $doc .= "}\n";
+    $doc .= "```\n";
+    $doc .= "\nTotal elements: " . $shape->getElementCount() . "\n";
+    $doc .= "Required elements: " . $shape->getRequiredElementCount() . "\n";
+
+    return $doc;
+}
+
+$docType = (new ReflectionFunction('getConfig'))->getReturnType();
+echo generateShapeDoc($docType);
+
+
+// =============================================================================
+// COMPARING SHAPE TYPES
+// =============================================================================
+
+function getUserA(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'A'];
+}
+
+function getUserB(): array{id: int, name: string} {
+    return ['id' => 2, 'name' => 'B'];
+}
+
+function getUserC(): array{id: int, name: string, email: string} {
+    return ['id' => 3, 'name' => 'C', 'email' => 'c@example.com'];
+}
+
+echo "=== Comparing Shape Types ===\n";
+
+$typeA = (new ReflectionFunction('getUserA'))->getReturnType();
+$typeB = (new ReflectionFunction('getUserB'))->getReturnType();
+$typeC = (new ReflectionFunction('getUserC'))->getReturnType();
+
+function shapesMatch(ReflectionArrayShapeType $a, ReflectionArrayShapeType $b): bool {
+    if ($a->getElementCount() !== $b->getElementCount()) {
+        return false;
+    }
+
+    $aElements = $a->getElements();
+    $bElements = $b->getElements();
+
+    for ($i = 0; $i < count($aElements); $i++) {
+        if ($aElements[$i]->getName() !== $bElements[$i]->getName()) {
+            return false;
+        }
+        if ((string)$aElements[$i]->getType() !== (string)$bElements[$i]->getType()) {
+            return false;
+        }
+        if ($aElements[$i]->isOptional() !== $bElements[$i]->isOptional()) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+echo "getUserA matches getUserB: " . (shapesMatch($typeA, $typeB) ? 'yes' : 'no') . "\n";
+echo "getUserA matches getUserC: " . (shapesMatch($typeA, $typeC) ? 'yes' : 'no') . "\n";
+
+
+echo "\n--- All reflection examples completed successfully! ---\n";
diff --git a/examples/array-shapes/09-validation-and-errors.php b/examples/array-shapes/09-validation-and-errors.php
new file mode 100644
index 00000000..afbbc5af
--- /dev/null
+++ b/examples/array-shapes/09-validation-and-errors.php
@@ -0,0 +1,360 @@
+<?php
+/**
+ * Validation and Error Handling with Array Shapes
+ *
+ * When declare(strict_arrays=1) is enabled, PHP validates array shapes
+ * at runtime and throws TypeError on mismatches.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// BASIC TYPE VALIDATION
+// =============================================================================
+
+echo "=== Basic Type Validation ===\n";
+
+function getValidUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice']; // Valid
+}
+
+$user = getValidUser();
+echo "Valid user: ID={$user['id']}, Name={$user['name']}\n\n";
+
+
+// =============================================================================
+// CATCHING TYPE ERRORS - MISSING REQUIRED KEY
+// =============================================================================
+
+echo "=== Missing Required Key ===\n";
+
+function getMissingKeyUser(): array{id: int, name: string, email: string} {
+    // This would cause a TypeError because 'email' is missing
+    // Uncommenting will throw: TypeError: Return value must have key 'email'
+    // return ['id' => 1, 'name' => 'Alice'];
+
+    // Correct version:
+    return ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+
+try {
+    $user = getMissingKeyUser();
+    echo "User retrieved successfully: {$user['email']}\n";
+} catch (TypeError $e) {
+    echo "TypeError caught: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// CATCHING TYPE ERRORS - WRONG VALUE TYPE
+// =============================================================================
+
+echo "=== Wrong Value Type ===\n";
+
+function getTypedUser(int $id, string $name): array{id: int, name: string} {
+    // Parameters ensure correct types
+    return ['id' => $id, 'name' => $name];
+}
+
+try {
+    // This works
+    $user = getTypedUser(1, 'Bob');
+    echo "User: ID={$user['id']} (type: " . gettype($user['id']) . ")\n";
+
+    // This would fail at parameter level
+    // $user = getTypedUser('not-an-int', 'Carol');
+} catch (TypeError $e) {
+    echo "TypeError caught: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// OPTIONAL KEYS DON'T REQUIRE VALUES
+// =============================================================================
+
+echo "=== Optional Keys ===\n";
+
+function getPartialConfig(): array{host: string, port?: int, ssl?: bool} {
+    // Only 'host' is required - this is valid
+    return ['host' => 'localhost'];
+}
+
+function getFullConfig(): array{host: string, port?: int, ssl?: bool} {
+    // All keys provided - also valid
+    return ['host' => 'secure.example.com', 'port' => 443, 'ssl' => true];
+}
+
+$partial = getPartialConfig();
+$full = getFullConfig();
+echo "Partial config - host: {$partial['host']}, port: " . ($partial['port'] ?? 'not set') . "\n";
+echo "Full config - host: {$full['host']}, port: {$full['port']}, ssl: " . ($full['ssl'] ? 'yes' : 'no') . "\n\n";
+
+
+// =============================================================================
+// VALIDATION WITH NULLABLE TYPES
+// =============================================================================
+
+echo "=== Nullable Types ===\n";
+
+function getNullableData(): array{value: ?string, count: ?int} {
+    return [
+        'value' => null,  // Valid - nullable
+        'count' => null   // Valid - nullable
+    ];
+}
+
+function getMixedNullable(): array{value: ?string, count: ?int} {
+    return [
+        'value' => 'hello',  // Valid - string
+        'count' => null      // Valid - null
+    ];
+}
+
+$null = getNullableData();
+$mixed = getMixedNullable();
+echo "Nullable data - value: " . ($null['value'] ?? 'null') . ", count: " . ($null['count'] ?? 'null') . "\n";
+echo "Mixed data - value: {$mixed['value']}, count: " . ($mixed['count'] ?? 'null') . "\n\n";
+
+
+// =============================================================================
+// PARAMETER VALIDATION
+// =============================================================================
+
+echo "=== Parameter Validation ===\n";
+
+function processData(array{x: int, y: int} $point): int {
+    return $point['x'] + $point['y'];
+}
+
+try {
+    // Valid call
+    $sum = processData(['x' => 10, 'y' => 20]);
+    echo "Sum: {$sum}\n";
+
+    // Invalid call would be caught here
+    // $sum = processData(['x' => 10]); // Missing 'y'
+    // $sum = processData(['x' => 'ten', 'y' => 20]); // Wrong type
+} catch (TypeError $e) {
+    echo "TypeError caught: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// NESTED SHAPE VALIDATION
+// =============================================================================
+
+echo "=== Nested Shape Validation ===\n";
+
+function getNestedValid(): array{
+    user: array{id: int, name: string},
+    meta: array{created: string}
+} {
+    return [
+        'user' => ['id' => 1, 'name' => 'Alice'],
+        'meta' => ['created' => '2024-01-15']
+    ];
+}
+
+$nested = getNestedValid();
+echo "Nested user: {$nested['user']['name']}, created: {$nested['meta']['created']}\n\n";
+
+
+// =============================================================================
+// SAFE WRAPPER PATTERN
+// =============================================================================
+
+echo "=== Safe Wrapper Pattern ===\n";
+
+/**
+ * Wrapper that catches validation errors and returns a result shape
+ */
+function safeGetUser(int $id): array{success: bool, data: ?array, error: ?string} {
+    try {
+        // Simulate fetching user
+        if ($id <= 0) {
+            throw new InvalidArgumentException("Invalid user ID: {$id}");
+        }
+
+        $user = [
+            'id' => $id,
+            'name' => 'User ' . $id,
+            'email' => "user{$id}@example.com"
+        ];
+
+        return [
+            'success' => true,
+            'data' => $user,
+            'error' => null
+        ];
+    } catch (Throwable $e) {
+        return [
+            'success' => false,
+            'data' => null,
+            'error' => $e->getMessage()
+        ];
+    }
+}
+
+$result1 = safeGetUser(42);
+$result2 = safeGetUser(-1);
+
+echo "Result 1: " . ($result1['success'] ? "success - {$result1['data']['name']}" : "failed - {$result1['error']}") . "\n";
+echo "Result 2: " . ($result2['success'] ? "success - {$result2['data']['name']}" : "failed - {$result2['error']}") . "\n\n";
+
+
+// =============================================================================
+// VALIDATION HELPER FUNCTIONS
+// =============================================================================
+
+echo "=== Custom Validation Helpers ===\n";
+
+/**
+ * Validate array has required keys before using as shape
+ */
+function validateShape(array $data, array $requiredKeys): bool {
+    foreach ($requiredKeys as $key) {
+        if (!array_key_exists($key, $data)) {
+            return false;
+        }
+    }
+    return true;
+}
+
+/**
+ * Validate and coerce to shape
+ */
+function toUserShape(array $data): array{id: int, name: string, email: string} {
+    // Validate required keys
+    $required = ['id', 'name', 'email'];
+    foreach ($required as $key) {
+        if (!isset($data[$key])) {
+            throw new InvalidArgumentException("Missing required key: {$key}");
+        }
+    }
+
+    // Coerce types if needed
+    return [
+        'id' => (int) $data['id'],
+        'name' => (string) $data['name'],
+        'email' => (string) $data['email']
+    ];
+}
+
+try {
+    $userData = ['id' => '123', 'name' => 'Test', 'email' => 'test@example.com'];
+    $user = toUserShape($userData);
+    echo "Coerced user: ID={$user['id']} (type: " . gettype($user['id']) . ")\n";
+} catch (InvalidArgumentException $e) {
+    echo "Validation failed: {$e->getMessage()}\n";
+}
+echo "\n";
+
+
+// =============================================================================
+// ASSERTION STYLE VALIDATION
+// =============================================================================
+
+echo "=== Assertion Style Validation ===\n";
+
+/**
+ * Assert function for shape validation
+ */
+function assertValidUser(array $user): void {
+    assert(isset($user['id']) && is_int($user['id']), 'id must be an integer');
+    assert(isset($user['name']) && is_string($user['name']), 'name must be a string');
+    assert(isset($user['email']) && is_string($user['email']), 'email must be a string');
+}
+
+$validUser = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+assertValidUser($validUser);
+echo "User validated successfully\n\n";
+
+
+// =============================================================================
+// TYPED ARRAYS VALIDATION
+// =============================================================================
+
+echo "=== Typed Arrays Validation ===\n";
+
+function getTypedList(): array<int> {
+    return [1, 2, 3, 4, 5]; // Valid - all integers
+}
+
+function getTypedShapeList(): array<array{id: int, name: string}> {
+    return [
+        ['id' => 1, 'name' => 'Alice'],
+        ['id' => 2, 'name' => 'Bob'],
+        ['id' => 3, 'name' => 'Carol']
+    ];
+}
+
+$numbers = getTypedList();
+$users = getTypedShapeList();
+echo "Numbers: " . implode(', ', $numbers) . "\n";
+echo "Users: " . count($users) . " valid user shapes\n\n";
+
+
+// =============================================================================
+// DEFENSIVE CODING PATTERNS
+// =============================================================================
+
+echo "=== Defensive Coding Patterns ===\n";
+
+class UserRepository
+{
+    /**
+     * Returns user or throws exception
+     */
+    public function findOrFail(int $id): array{id: int, name: string, email: string} {
+        $user = $this->find($id);
+        if ($user === null) {
+            throw new RuntimeException("User not found: {$id}");
+        }
+        return $user;
+    }
+
+    /**
+     * Returns user or null
+     */
+    public function find(int $id): ?array {
+        if ($id <= 0) {
+            return null;
+        }
+        return ['id' => $id, 'name' => "User {$id}", 'email' => "user{$id}@example.com"];
+    }
+
+    /**
+     * Returns result shape for safer error handling
+     */
+    public function findSafe(int $id): array{found: bool, user: ?array} {
+        $user = $this->find($id);
+        return [
+            'found' => $user !== null,
+            'user' => $user
+        ];
+    }
+}
+
+$repo = new UserRepository();
+
+// Pattern 1: Try-catch with findOrFail
+try {
+    $user = $repo->findOrFail(1);
+    echo "Found user: {$user['name']}\n";
+} catch (RuntimeException $e) {
+    echo "Error: {$e->getMessage()}\n";
+}
+
+// Pattern 2: Check result shape
+$result = $repo->findSafe(999);
+if ($result['found']) {
+    echo "User found: {$result['user']['name']}\n";
+} else {
+    echo "User not found\n";
+}
+
+
+echo "\n--- All validation and error examples completed successfully! ---\n";
diff --git a/examples/array-shapes/10-real-world-patterns.php b/examples/array-shapes/10-real-world-patterns.php
new file mode 100644
index 00000000..d8c0fdc8
--- /dev/null
+++ b/examples/array-shapes/10-real-world-patterns.php
@@ -0,0 +1,590 @@
+<?php
+/**
+ * Real-World Patterns and Use Cases for Array Shapes
+ *
+ * Common patterns you'll encounter in production applications.
+ */
+
+declare(strict_arrays=1);
+
+// =============================================================================
+// PATTERN 1: API RESPONSES
+// =============================================================================
+
+echo "=== API Response Pattern ===\n";
+
+/**
+ * Standard API response wrapper
+ */
+function apiSuccess(mixed $data): array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    meta: array{timestamp: string, version: string}
+} {
+    return [
+        'success' => true,
+        'data' => $data,
+        'error' => null,
+        'meta' => [
+            'timestamp' => date('c'),
+            'version' => '1.0'
+        ]
+    ];
+}
+
+function apiError(string $message, int $code = 500): array{
+    success: bool,
+    data: ?array,
+    error: string,
+    meta: array{timestamp: string, code: int}
+} {
+    return [
+        'success' => false,
+        'data' => null,
+        'error' => $message,
+        'meta' => [
+            'timestamp' => date('c'),
+            'code' => $code
+        ]
+    ];
+}
+
+$success = apiSuccess(['user' => ['id' => 1, 'name' => 'Alice']]);
+$error = apiError('User not found', 404);
+echo "Success response: " . json_encode($success) . "\n";
+echo "Error response: " . json_encode($error) . "\n\n";
+
+
+// =============================================================================
+// PATTERN 2: CONFIGURATION OBJECTS
+// =============================================================================
+
+echo "=== Configuration Pattern ===\n";
+
+/**
+ * Database configuration
+ */
+function getDatabaseConfig(): array{
+    driver: string,
+    host: string,
+    port: int,
+    database: string,
+    username: string,
+    password: string,
+    options?: array{
+        charset?: string,
+        collation?: string,
+        timeout?: int,
+        persistent?: bool
+    }
+} {
+    return [
+        'driver' => 'mysql',
+        'host' => 'localhost',
+        'port' => 3306,
+        'database' => 'myapp',
+        'username' => 'root',
+        'password' => 'secret',
+        'options' => [
+            'charset' => 'utf8mb4',
+            'timeout' => 30
+        ]
+    ];
+}
+
+/**
+ * Cache configuration
+ */
+function getCacheConfig(): array{
+    driver: string,
+    prefix: string,
+    ttl: int,
+    redis?: array{host: string, port: int, password?: string},
+    memcached?: array{servers: array<array{host: string, port: int}>}
+} {
+    return [
+        'driver' => 'redis',
+        'prefix' => 'myapp_',
+        'ttl' => 3600,
+        'redis' => [
+            'host' => '127.0.0.1',
+            'port' => 6379
+        ]
+    ];
+}
+
+$dbConfig = getDatabaseConfig();
+$cacheConfig = getCacheConfig();
+echo "DB: {$dbConfig['driver']}://{$dbConfig['host']}:{$dbConfig['port']}/{$dbConfig['database']}\n";
+echo "Cache: {$cacheConfig['driver']} (prefix: {$cacheConfig['prefix']}, ttl: {$cacheConfig['ttl']}s)\n\n";
+
+
+// =============================================================================
+// PATTERN 3: DATA TRANSFER OBJECTS (DTOs) AS SHAPES
+// =============================================================================
+
+echo "=== DTO Pattern ===\n";
+
+/**
+ * User DTO
+ */
+function createUserDTO(
+    int $id,
+    string $name,
+    string $email
+): array{id: int, name: string, email: string, created_at: string} {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email,
+        'created_at' => date('c')
+    ];
+}
+
+/**
+ * Order DTO with nested structures
+ */
+function createOrderDTO(
+    string $orderId,
+    array{id: int, name: string, email: string} $customer,
+    array<array{sku: string, name: string, qty: int, price: float}> $items
+): array{
+    order_id: string,
+    customer: array{id: int, name: string, email: string},
+    items: array<array{sku: string, name: string, qty: int, price: float}>,
+    total: float,
+    created_at: string
+} {
+    $total = array_reduce($items, fn($sum, $item) => $sum + ($item['qty'] * $item['price']), 0.0);
+
+    return [
+        'order_id' => $orderId,
+        'customer' => $customer,
+        'items' => $items,
+        'total' => $total,
+        'created_at' => date('c')
+    ];
+}
+
+$user = createUserDTO(1, 'Alice', 'alice@example.com');
+$order = createOrderDTO(
+    'ORD-001',
+    $user,
+    [
+        ['sku' => 'WIDGET-A', 'name' => 'Widget A', 'qty' => 2, 'price' => 10.00],
+        ['sku' => 'GADGET-B', 'name' => 'Gadget B', 'qty' => 1, 'price' => 25.00]
+    ]
+);
+echo "Order {$order['order_id']} for {$order['customer']['name']}: \${$order['total']}\n\n";
+
+
+// =============================================================================
+// PATTERN 4: EVENT PAYLOADS
+// =============================================================================
+
+echo "=== Event Payload Pattern ===\n";
+
+/**
+ * User registered event
+ */
+function userRegisteredEvent(
+    int $userId,
+    string $email
+): array{event: string, payload: array{user_id: int, email: string}, timestamp: string} {
+    return [
+        'event' => 'user.registered',
+        'payload' => [
+            'user_id' => $userId,
+            'email' => $email
+        ],
+        'timestamp' => date('c')
+    ];
+}
+
+/**
+ * Order placed event
+ */
+function orderPlacedEvent(
+    string $orderId,
+    int $customerId,
+    float $total
+): array{event: string, payload: array{order_id: string, customer_id: int, total: float}, timestamp: string} {
+    return [
+        'event' => 'order.placed',
+        'payload' => [
+            'order_id' => $orderId,
+            'customer_id' => $customerId,
+            'total' => $total
+        ],
+        'timestamp' => date('c')
+    ];
+}
+
+$regEvent = userRegisteredEvent(42, 'new@example.com');
+$orderEvent = orderPlacedEvent('ORD-123', 42, 99.99);
+echo "Event: {$regEvent['event']} at {$regEvent['timestamp']}\n";
+echo "Event: {$orderEvent['event']} - Order {$orderEvent['payload']['order_id']}\n\n";
+
+
+// =============================================================================
+// PATTERN 5: FORM DATA VALIDATION
+// =============================================================================
+
+echo "=== Form Validation Pattern ===\n";
+
+/**
+ * Registration form data
+ */
+function validateRegistrationForm(array $input): array{
+    valid: bool,
+    data?: array{name: string, email: string, password: string},
+    errors: array<string>
+} {
+    $errors = [];
+
+    if (empty($input['name'])) {
+        $errors[] = 'Name is required';
+    }
+    if (empty($input['email']) || !str_contains($input['email'], '@')) {
+        $errors[] = 'Valid email is required';
+    }
+    if (empty($input['password']) || strlen($input['password']) < 8) {
+        $errors[] = 'Password must be at least 8 characters';
+    }
+
+    if (empty($errors)) {
+        return [
+            'valid' => true,
+            'data' => [
+                'name' => $input['name'],
+                'email' => $input['email'],
+                'password' => $input['password']
+            ],
+            'errors' => []
+        ];
+    }
+
+    return [
+        'valid' => false,
+        'errors' => $errors
+    ];
+}
+
+$validForm = validateRegistrationForm([
+    'name' => 'Alice',
+    'email' => 'alice@example.com',
+    'password' => 'securepassword'
+]);
+
+$invalidForm = validateRegistrationForm([
+    'name' => '',
+    'email' => 'not-an-email',
+    'password' => 'short'
+]);
+
+echo "Valid form: " . ($validForm['valid'] ? 'yes' : 'no') . "\n";
+echo "Invalid form errors: " . implode(', ', $invalidForm['errors']) . "\n\n";
+
+
+// =============================================================================
+// PATTERN 6: PAGINATION RESULTS
+// =============================================================================
+
+echo "=== Pagination Pattern ===\n";
+
+/**
+ * Paginated result wrapper
+ */
+function paginatedResult(
+    array $items,
+    int $page,
+    int $perPage,
+    int $total
+): array{
+    data: array,
+    pagination: array{
+        current_page: int,
+        per_page: int,
+        total_items: int,
+        total_pages: int,
+        has_next: bool,
+        has_prev: bool
+    }
+} {
+    $totalPages = (int) ceil($total / $perPage);
+
+    return [
+        'data' => $items,
+        'pagination' => [
+            'current_page' => $page,
+            'per_page' => $perPage,
+            'total_items' => $total,
+            'total_pages' => $totalPages,
+            'has_next' => $page < $totalPages,
+            'has_prev' => $page > 1
+        ]
+    ];
+}
+
+$result = paginatedResult(
+    [['id' => 1], ['id' => 2], ['id' => 3]],
+    2, 10, 45
+);
+echo "Page {$result['pagination']['current_page']} of {$result['pagination']['total_pages']}\n";
+echo "Has next: " . ($result['pagination']['has_next'] ? 'yes' : 'no') . "\n\n";
+
+
+// =============================================================================
+// PATTERN 7: REPOSITORY METHODS
+// =============================================================================
+
+echo "=== Repository Pattern ===\n";
+
+class ProductRepository
+{
+    private array $products = [];
+
+    public function __construct()
+    {
+        $this->products = [
+            ['id' => 1, 'sku' => 'PROD-001', 'name' => 'Widget', 'price' => 9.99, 'stock' => 100],
+            ['id' => 2, 'sku' => 'PROD-002', 'name' => 'Gadget', 'price' => 19.99, 'stock' => 50],
+            ['id' => 3, 'sku' => 'PROD-003', 'name' => 'Thing', 'price' => 29.99, 'stock' => 25]
+        ];
+    }
+
+    public function findById(int $id): ?array {
+        foreach ($this->products as $product) {
+            if ($product['id'] === $id) {
+                return $product;
+            }
+        }
+        return null;
+    }
+
+    public function findAll(): array<array{id: int, sku: string, name: string, price: float, stock: int}> {
+        return $this->products;
+    }
+
+    public function findBySku(string $sku): ?array {
+        foreach ($this->products as $product) {
+            if ($product['sku'] === $sku) {
+                return $product;
+            }
+        }
+        return null;
+    }
+
+    public function search(
+        array{min_price?: float, max_price?: float, in_stock?: bool} $criteria
+    ): array<array{id: int, sku: string, name: string, price: float, stock: int}> {
+        return array_filter($this->products, function($p) use ($criteria) {
+            if (isset($criteria['min_price']) && $p['price'] < $criteria['min_price']) {
+                return false;
+            }
+            if (isset($criteria['max_price']) && $p['price'] > $criteria['max_price']) {
+                return false;
+            }
+            if (isset($criteria['in_stock']) && $criteria['in_stock'] && $p['stock'] <= 0) {
+                return false;
+            }
+            return true;
+        });
+    }
+}
+
+$repo = new ProductRepository();
+$all = $repo->findAll();
+$searched = $repo->search(['min_price' => 15.00, 'in_stock' => true]);
+
+echo "All products: " . count($all) . "\n";
+echo "Filtered products: " . count($searched) . "\n\n";
+
+
+// =============================================================================
+// PATTERN 8: SERVICE LAYER RESPONSES
+// =============================================================================
+
+echo "=== Service Layer Pattern ===\n";
+
+class PaymentService
+{
+    public function processPayment(
+        array{amount: float, currency: string, card_token: string} $payment
+    ): array{
+        success: bool,
+        transaction_id: ?string,
+        error_code: ?string,
+        error_message: ?string
+    } {
+        // Simulate payment processing
+        if ($payment['amount'] <= 0) {
+            return [
+                'success' => false,
+                'transaction_id' => null,
+                'error_code' => 'INVALID_AMOUNT',
+                'error_message' => 'Amount must be greater than zero'
+            ];
+        }
+
+        return [
+            'success' => true,
+            'transaction_id' => 'TXN-' . uniqid(),
+            'error_code' => null,
+            'error_message' => null
+        ];
+    }
+
+    public function refund(
+        string $transactionId,
+        float $amount
+    ): array{success: bool, refund_id: ?string, error: ?string} {
+        return [
+            'success' => true,
+            'refund_id' => 'REF-' . uniqid(),
+            'error' => null
+        ];
+    }
+}
+
+$paymentService = new PaymentService();
+$result = $paymentService->processPayment([
+    'amount' => 99.99,
+    'currency' => 'USD',
+    'card_token' => 'tok_visa'
+]);
+
+echo "Payment: " . ($result['success'] ? "Success - {$result['transaction_id']}" : "Failed - {$result['error_message']}") . "\n\n";
+
+
+// =============================================================================
+// PATTERN 9: BUILDER PATTERN WITH SHAPES
+// =============================================================================
+
+echo "=== Builder Pattern ===\n";
+
+class EmailBuilder
+{
+    private array $data = [
+        'to' => [],
+        'cc' => [],
+        'bcc' => [],
+        'subject' => '',
+        'body' => '',
+        'attachments' => []
+    ];
+
+    public function to(string $email, string $name = ''): self {
+        $this->data['to'][] = ['email' => $email, 'name' => $name];
+        return $this;
+    }
+
+    public function cc(string $email): self {
+        $this->data['cc'][] = $email;
+        return $this;
+    }
+
+    public function subject(string $subject): self {
+        $this->data['subject'] = $subject;
+        return $this;
+    }
+
+    public function body(string $body): self {
+        $this->data['body'] = $body;
+        return $this;
+    }
+
+    public function attach(array{filename: string, content: string, mime: string} $attachment): self {
+        $this->data['attachments'][] = $attachment;
+        return $this;
+    }
+
+    public function build(): array{
+        to: array<array{email: string, name: string}>,
+        cc: array<string>,
+        bcc: array<string>,
+        subject: string,
+        body: string,
+        attachments: array<array{filename: string, content: string, mime: string}>
+    } {
+        return $this->data;
+    }
+}
+
+$email = (new EmailBuilder())
+    ->to('alice@example.com', 'Alice')
+    ->to('bob@example.com', 'Bob')
+    ->cc('manager@example.com')
+    ->subject('Weekly Report')
+    ->body('Please find attached the weekly report.')
+    ->attach(['filename' => 'report.pdf', 'content' => '...', 'mime' => 'application/pdf'])
+    ->build();
+
+echo "Email to: " . count($email['to']) . " recipients, Subject: {$email['subject']}\n\n";
+
+
+// =============================================================================
+// PATTERN 10: JSON API RESOURCES
+// =============================================================================
+
+echo "=== JSON:API Resource Pattern ===\n";
+
+/**
+ * JSON:API compliant resource wrapper
+ */
+function jsonApiResource(
+    string $type,
+    string|int $id,
+    array $attributes,
+    array $relationships = []
+): array{
+    type: string,
+    id: string,
+    attributes: array,
+    relationships: array,
+    links: array{self: string}
+} {
+    return [
+        'type' => $type,
+        'id' => (string) $id,
+        'attributes' => $attributes,
+        'relationships' => $relationships,
+        'links' => [
+            'self' => "/{$type}/{$id}"
+        ]
+    ];
+}
+
+/**
+ * JSON:API collection wrapper
+ */
+function jsonApiCollection(
+    array $resources,
+    array{page: int, per_page: int, total: int} $meta
+): array{
+    data: array,
+    meta: array{page: int, per_page: int, total: int, total_pages: int}
+} {
+    return [
+        'data' => $resources,
+        'meta' => [
+            'page' => $meta['page'],
+            'per_page' => $meta['per_page'],
+            'total' => $meta['total'],
+            'total_pages' => (int) ceil($meta['total'] / $meta['per_page'])
+        ]
+    ];
+}
+
+$userResource = jsonApiResource('users', 1, ['name' => 'Alice', 'email' => 'alice@example.com']);
+$collection = jsonApiCollection(
+    [$userResource],
+    ['page' => 1, 'per_page' => 10, 'total' => 1]
+);
+
+echo "Resource type: {$userResource['type']}, id: {$userResource['id']}\n";
+echo "Collection total: {$collection['meta']['total']}\n\n";
+
+
+echo "--- All real-world pattern examples completed successfully! ---\n";
diff --git a/examples/array-shapes/README.md b/examples/array-shapes/README.md
new file mode 100644
index 00000000..cbd5d3e9
--- /dev/null
+++ b/examples/array-shapes/README.md
@@ -0,0 +1,250 @@
+# Array Shape Examples
+
+This directory contains comprehensive examples demonstrating all features of PHP's array shape type syntax.
+
+## What Are Array Shapes?
+
+Array shapes allow you to define the structure of associative arrays with typed keys:
+
+```php
+declare(strict_arrays=1);
+
+function getUser(): array{id: int, name: string, email?: string} {
+    return ['id' => 1, 'name' => 'Alice'];
+}
+```
+
+## Quick Reference
+
+### Basic Syntax
+
+```php
+// Required keys
+array{key: type}
+
+// Optional keys (may be absent)
+array{key?: type}
+
+// Nullable values (key present, value can be null)
+array{key: ?type}
+
+// Multiple keys
+array{key1: type1, key2: type2, key3?: type3}
+```
+
+### Type Options
+
+```php
+// Scalar types
+array{id: int, name: string, price: float, active: bool}
+
+// Nullable types
+array{value: ?string}
+
+// Union types
+array{id: int|string, value: float|null}
+
+// Mixed type
+array{data: mixed}
+
+// Array types
+array{items: array}
+array{numbers: array<int>}
+array{users: array<array{id: int, name: string}>}
+
+// Object types
+array{user: User, admin: ?Admin}
+```
+
+### Where You Can Use Array Shapes
+
+```php
+// Return types
+function getUser(): array{id: int, name: string} { ... }
+
+// Parameter types
+function process(array{x: int, y: int} $point): void { ... }
+
+// Closures and arrow functions
+$fn = fn(): array{value: int} => ['value' => 42];
+
+// Class methods
+class UserService {
+    public function find(int $id): array{id: int, name: string} { ... }
+}
+
+// Interface methods
+interface ConfigProvider {
+    public function getConfig(): array{debug: bool, env: string};
+}
+```
+
+## Examples Index
+
+| File | Description |
+|------|-------------|
+| `01-basic-shapes.php` | Basic array shape syntax with required keys |
+| `02-optional-keys.php` | Optional keys with `key?: type` syntax |
+| `03-nested-shapes.php` | Nested array shapes for complex structures |
+| `04-union-and-nullable-types.php` | Union types and nullable values in shapes |
+| `05-shapes-with-typed-arrays.php` | Combining shapes with `array<T>` syntax |
+| `06-classes-and-interfaces.php` | Using shapes in classes, interfaces, traits |
+| `07-closures-and-callables.php` | Shapes with closures and arrow functions |
+| `08-reflection-api.php` | Runtime inspection with Reflection API |
+| `09-validation-and-errors.php` | Error handling and validation patterns |
+| `10-real-world-patterns.php` | Production-ready patterns and use cases |
+
+## Running Examples
+
+```bash
+# Run any example
+./sapi/cli/php examples/array-shapes/01-basic-shapes.php
+
+# Run all examples
+for f in examples/array-shapes/*.php; do echo "=== $f ==="; ./sapi/cli/php "$f"; done
+```
+
+## Key Concepts
+
+### Optional vs Nullable
+
+```php
+// Optional: key may not exist in array
+array{name: string, email?: string}
+// Valid: ['name' => 'Alice']
+// Valid: ['name' => 'Alice', 'email' => 'alice@example.com']
+
+// Nullable: key must exist but value can be null
+array{name: string, email: ?string}
+// Valid: ['name' => 'Alice', 'email' => null]
+// Valid: ['name' => 'Alice', 'email' => 'alice@example.com']
+// Invalid: ['name' => 'Alice'] - missing 'email' key
+
+// Both: key is optional, and if present can be null
+array{name: string, email?: ?string}
+```
+
+### Nested Shapes
+
+```php
+array{
+    user: array{
+        id: int,
+        profile: array{
+            name: string,
+            avatar?: string
+        }
+    },
+    settings: array{
+        theme: string,
+        notifications: bool
+    }
+}
+```
+
+### Shapes with Typed Arrays
+
+```php
+// Shape containing typed array
+array{
+    name: string,
+    tags: array<string>,
+    scores: array<int>
+}
+
+// Typed array of shapes (list of records)
+array<array{id: int, name: string}>
+
+// Keyed array of shapes (dictionary)
+array<string, array{value: mixed, type: string}>
+```
+
+## Reflection API
+
+```php
+$reflection = new ReflectionFunction('getUser');
+$returnType = $reflection->getReturnType();
+
+if ($returnType instanceof ReflectionArrayShapeType) {
+    echo "Element count: " . $returnType->getElementCount() . "\n";
+    echo "Required count: " . $returnType->getRequiredElementCount() . "\n";
+
+    foreach ($returnType->getElements() as $element) {
+        echo $element->getName() . ": " . $element->getType();
+        if ($element->isOptional()) {
+            echo " (optional)";
+        }
+        echo "\n";
+    }
+}
+```
+
+## Common Patterns
+
+### API Response Wrapper
+
+```php
+function apiResponse(mixed $data, ?string $error = null): array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    timestamp: string
+} {
+    return [
+        'success' => $error === null,
+        'data' => $data,
+        'error' => $error,
+        'timestamp' => date('c')
+    ];
+}
+```
+
+### Configuration Object
+
+```php
+function getConfig(): array{
+    database: array{host: string, port: int, name: string},
+    cache: array{driver: string, ttl: int},
+    debug?: bool
+} { ... }
+```
+
+### DTO Factory
+
+```php
+function createUserDTO(
+    int $id,
+    string $name,
+    string $email
+): array{id: int, name: string, email: string, created_at: string} {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email,
+        'created_at' => date('c')
+    ];
+}
+```
+
+### Paginated Results
+
+```php
+function paginate(array $items, int $page, int $total): array{
+    data: array,
+    meta: array{page: int, total: int, has_more: bool}
+} {
+    return [
+        'data' => $items,
+        'meta' => [
+            'page' => $page,
+            'total' => $total,
+            'has_more' => count($items) < $total
+        ]
+    ];
+}
+```
+
+## Requirements
+
+- PHP 8.5+ with array shape support
+- `declare(strict_arrays=1)` for runtime validation
diff --git a/ext/reflection/php_reflection.c b/ext/reflection/php_reflection.c
index 583717a6..db205a43 100644
--- a/ext/reflection/php_reflection.c
+++ b/ext/reflection/php_reflection.c
@@ -90,6 +90,9 @@ PHPAPI zend_class_entry *reflection_type_ptr;
 PHPAPI zend_class_entry *reflection_named_type_ptr;
 PHPAPI zend_class_entry *reflection_intersection_type_ptr;
 PHPAPI zend_class_entry *reflection_union_type_ptr;
+PHPAPI zend_class_entry *reflection_array_type_ptr;
+PHPAPI zend_class_entry *reflection_array_shape_type_ptr;
+PHPAPI zend_class_entry *reflection_array_shape_element_ptr;
 PHPAPI zend_class_entry *reflection_class_ptr;
 PHPAPI zend_class_entry *reflection_object_ptr;
 PHPAPI zend_class_entry *reflection_method_ptr;
@@ -159,6 +162,13 @@ typedef struct _attribute_reference {
 	uint32_t target;
 } attribute_reference;
 
+/* Struct to store array shape element reference for ReflectionArrayShapeElement */
+typedef struct _array_shape_element_reference {
+	zend_string *key;
+	zend_type type;
+	bool is_optional;
+} array_shape_element_reference;
+
 typedef enum {
 	REF_TYPE_OTHER,      /* Must be 0 */
 	REF_TYPE_FUNCTION,
@@ -168,7 +178,8 @@ typedef enum {
 	REF_TYPE_TYPE,
 	REF_TYPE_PROPERTY,
 	REF_TYPE_CLASS_CONSTANT,
-	REF_TYPE_ATTRIBUTE
+	REF_TYPE_ATTRIBUTE,
+	REF_TYPE_ARRAY_SHAPE_ELEMENT
 } reflection_type_t;
 
 /* Struct for reflection objects */
@@ -270,6 +281,12 @@ static void reflection_free_objects_storage(zend_object *object) /* {{{ */
 			efree(intern->ptr);
 			break;
 		}
+		case REF_TYPE_ARRAY_SHAPE_ELEMENT: {
+			array_shape_element_reference *elem_ref = intern->ptr;
+			zend_string_release(elem_ref->key);
+			efree(elem_ref);
+			break;
+		}
 		case REF_TYPE_GENERATOR:
 		case REF_TYPE_FIBER:
 		case REF_TYPE_CLASS_CONSTANT:
@@ -1480,7 +1497,9 @@ static void reflection_parameter_factory(zend_function *fptr, zval *closure_obje
 typedef enum {
 	NAMED_TYPE = 0,
 	UNION_TYPE = 1,
-	INTERSECTION_TYPE = 2
+	INTERSECTION_TYPE = 2,
+	ARRAY_TYPE = 3,
+	ARRAY_SHAPE_TYPE = 4
 } reflection_type_kind;
 
 /* For backwards compatibility reasons, we need to return T|null style unions
@@ -1490,6 +1509,16 @@ typedef enum {
 static reflection_type_kind get_type_kind(zend_type type) {
 	uint32_t type_mask_without_null = ZEND_TYPE_PURE_MASK_WITHOUT_NULL(type);
 
+	/* Check for array shapes (array{key: type, ...}) first */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+		return ARRAY_SHAPE_TYPE;
+	}
+
+	/* Check for typed arrays (array<T> or array<K, V>) */
+	if (ZEND_TYPE_HAS_ARRAY_ELEMENT(type)) {
+		return ARRAY_TYPE;
+	}
+
 	if (ZEND_TYPE_HAS_LIST(type)) {
 		if (ZEND_TYPE_IS_INTERSECTION(type)) {
 			return INTERSECTION_TYPE;
@@ -1537,6 +1566,12 @@ static void reflection_type_factory(zend_type type, zval *object, bool legacy_be
 		case NAMED_TYPE:
 			object_init_ex(object, reflection_named_type_ptr);
 			break;
+		case ARRAY_TYPE:
+			object_init_ex(object, reflection_array_type_ptr);
+			break;
+		case ARRAY_SHAPE_TYPE:
+			object_init_ex(object, reflection_array_shape_type_ptr);
+			break;
 		EMPTY_SWITCH_DEFAULT_CASE();
 	}
 
@@ -3262,6 +3297,171 @@ ZEND_METHOD(ReflectionIntersectionType, getTypes)
 }
 /* }}} */
 
+/* {{{ Returns the element (value) type of the typed array */
+ZEND_METHOD(ReflectionArrayType, getElementType)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_typed_array_element *elem_type;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_ELEMENT(param->type));
+	elem_type = ZEND_TYPED_ARRAY_ELEMENT(param->type);
+
+	reflection_type_factory(elem_type->element_type, return_value, 0);
+}
+/* }}} */
+
+/* {{{ Returns the key type of the typed array, or null if not specified */
+ZEND_METHOD(ReflectionArrayType, getKeyType)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_typed_array_element *elem_type;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_ELEMENT(param->type));
+	elem_type = ZEND_TYPED_ARRAY_ELEMENT(param->type);
+
+	if (!ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+		RETURN_NULL();
+	}
+
+	reflection_type_factory(elem_type->key_type, return_value, 0);
+}
+/* }}} */
+
+/* {{{ Returns whether a key type was explicitly specified */
+ZEND_METHOD(ReflectionArrayType, hasKeyType)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_typed_array_element *elem_type;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_ELEMENT(param->type));
+	elem_type = ZEND_TYPED_ARRAY_ELEMENT(param->type);
+
+	RETURN_BOOL(ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type));
+}
+/* }}} */
+
+/* {{{ Returns an array of ReflectionArrayShapeElement objects */
+ZEND_METHOD(ReflectionArrayShapeType, getElements)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	array_init_size(return_value, shape->num_elements);
+
+	for (uint32_t i = 0; i < shape->num_elements; i++) {
+		const zend_array_shape_element *elem = &shape->elements[i];
+		zval element_obj;
+		reflection_object *elem_intern;
+		array_shape_element_reference *elem_ref;
+
+		object_init_ex(&element_obj, reflection_array_shape_element_ptr);
+		elem_intern = Z_REFLECTION_P(&element_obj);
+
+		elem_ref = emalloc(sizeof(array_shape_element_reference));
+		elem_ref->key = zend_string_copy(elem->key);
+		elem_ref->type = elem->type;
+		elem_ref->is_optional = elem->is_optional;
+
+		elem_intern->ptr = elem_ref;
+		elem_intern->ref_type = REF_TYPE_ARRAY_SHAPE_ELEMENT;
+
+		zend_hash_next_index_insert(Z_ARRVAL_P(return_value), &element_obj);
+	}
+}
+/* }}} */
+
+/* {{{ Returns the number of elements in the shape */
+ZEND_METHOD(ReflectionArrayShapeType, getElementCount)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	RETURN_LONG(shape->num_elements);
+}
+/* }}} */
+
+/* {{{ Returns the number of required (non-optional) elements in the shape */
+ZEND_METHOD(ReflectionArrayShapeType, getRequiredElementCount)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	RETURN_LONG(shape->num_required);
+}
+/* }}} */
+
+/* {{{ Returns the key name of this array shape element */
+ZEND_METHOD(ReflectionArrayShapeElement, getName)
+{
+	reflection_object *intern;
+	array_shape_element_reference *elem_ref;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(elem_ref);
+
+	RETURN_STR_COPY(elem_ref->key);
+}
+/* }}} */
+
+/* {{{ Returns the type of this array shape element */
+ZEND_METHOD(ReflectionArrayShapeElement, getType)
+{
+	reflection_object *intern;
+	array_shape_element_reference *elem_ref;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(elem_ref);
+
+	reflection_type_factory(elem_ref->type, return_value, 0);
+}
+/* }}} */
+
+/* {{{ Returns whether this array shape element is optional */
+ZEND_METHOD(ReflectionArrayShapeElement, isOptional)
+{
+	reflection_object *intern;
+	array_shape_element_reference *elem_ref;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(elem_ref);
+
+	RETURN_BOOL(elem_ref->is_optional);
+}
+/* }}} */
+
 /* {{{ Constructor. Throws an Exception in case the given method does not exist */
 static void instantiate_reflection_method(INTERNAL_FUNCTION_PARAMETERS, bool is_constructor)
 {
@@ -7975,6 +8175,18 @@ PHP_MINIT_FUNCTION(reflection) /* {{{ */
 	reflection_intersection_type_ptr->create_object = reflection_objects_new;
 	reflection_intersection_type_ptr->default_object_handlers = &reflection_object_handlers;
 
+	reflection_array_type_ptr = register_class_ReflectionArrayType(reflection_type_ptr);
+	reflection_array_type_ptr->create_object = reflection_objects_new;
+	reflection_array_type_ptr->default_object_handlers = &reflection_object_handlers;
+
+	reflection_array_shape_type_ptr = register_class_ReflectionArrayShapeType(reflection_type_ptr);
+	reflection_array_shape_type_ptr->create_object = reflection_objects_new;
+	reflection_array_shape_type_ptr->default_object_handlers = &reflection_object_handlers;
+
+	reflection_array_shape_element_ptr = register_class_ReflectionArrayShapeElement();
+	reflection_array_shape_element_ptr->create_object = reflection_objects_new;
+	reflection_array_shape_element_ptr->default_object_handlers = &reflection_object_handlers;
+
 	reflection_method_ptr = register_class_ReflectionMethod(reflection_function_abstract_ptr);
 	reflection_method_ptr->create_object = reflection_objects_new;
 	reflection_method_ptr->default_object_handlers = &reflection_object_handlers;
diff --git a/ext/reflection/php_reflection.h b/ext/reflection/php_reflection.h
index d676597f..e5cf169d 100644
--- a/ext/reflection/php_reflection.h
+++ b/ext/reflection/php_reflection.h
@@ -35,6 +35,7 @@ extern PHPAPI zend_class_entry *reflection_function_ptr;
 extern PHPAPI zend_class_entry *reflection_parameter_ptr;
 extern PHPAPI zend_class_entry *reflection_type_ptr;
 extern PHPAPI zend_class_entry *reflection_named_type_ptr;
+extern PHPAPI zend_class_entry *reflection_array_type_ptr;
 extern PHPAPI zend_class_entry *reflection_class_ptr;
 extern PHPAPI zend_class_entry *reflection_object_ptr;
 extern PHPAPI zend_class_entry *reflection_method_ptr;
diff --git a/ext/reflection/php_reflection.stub.php b/ext/reflection/php_reflection.stub.php
index 91c70d6f..35b4270c 100644
--- a/ext/reflection/php_reflection.stub.php
+++ b/ext/reflection/php_reflection.stub.php
@@ -744,6 +744,44 @@ class ReflectionIntersectionType extends ReflectionType
     public function getTypes(): array {}
 }
 
+class ReflectionArrayType extends ReflectionType
+{
+    /** Get the element (value) type of the array */
+    public function getElementType(): ReflectionType {}
+
+    /** Get the key type of the array, or null if not specified */
+    public function getKeyType(): ?ReflectionType {}
+
+    /** Check if a key type was explicitly specified */
+    public function hasKeyType(): bool {}
+}
+
+/** Represents an array shape type like array{name: string, age?: int} */
+class ReflectionArrayShapeType extends ReflectionType
+{
+    /** Get the elements defined in the shape */
+    public function getElements(): array {}
+
+    /** Get the number of elements in the shape */
+    public function getElementCount(): int {}
+
+    /** Get the number of required (non-optional) elements */
+    public function getRequiredElementCount(): int {}
+}
+
+/** Represents an element in an array shape type */
+class ReflectionArrayShapeElement
+{
+    /** Get the key name */
+    public function getName(): string {}
+
+    /** Get the type of this element */
+    public function getType(): ReflectionType {}
+
+    /** Check if this element is optional */
+    public function isOptional(): bool {}
+}
+
 /** @not-serializable */
 class ReflectionExtension implements Reflector
 {
diff --git a/ext/reflection/php_reflection_arginfo.h b/ext/reflection/php_reflection_arginfo.h
index bee9cbfc..d9eb0ecd 100644
Binary files a/ext/reflection/php_reflection_arginfo.h and b/ext/reflection/php_reflection_arginfo.h differ
diff --git a/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt b/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt
index 8ba243a5..dc32bbda 100644
--- a/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt
+++ b/ext/reflection/tests/ReflectionExtension_getClasses_basic.phpt
@@ -8,7 +8,7 @@
 var_dump($ext->getClasses());
 ?>
 --EXPECTF--
-array(26) {
+array(29) {
   ["ReflectionException"]=>
   object(ReflectionClass)#%d (1) {
     ["name"]=>
@@ -64,6 +64,21 @@
     ["name"]=>
     string(26) "ReflectionIntersectionType"
   }
+  ["ReflectionArrayType"]=>
+  object(ReflectionClass)#%d (1) {
+    ["name"]=>
+    string(19) "ReflectionArrayType"
+  }
+  ["ReflectionArrayShapeType"]=>
+  object(ReflectionClass)#%d (1) {
+    ["name"]=>
+    string(24) "ReflectionArrayShapeType"
+  }
+  ["ReflectionArrayShapeElement"]=>
+  object(ReflectionClass)#%d (1) {
+    ["name"]=>
+    string(27) "ReflectionArrayShapeElement"
+  }
   ["ReflectionMethod"]=>
   object(ReflectionClass)#%d (1) {
     ["name"]=>
