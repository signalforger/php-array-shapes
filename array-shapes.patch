diff --git a/README.md b/README.md
index fabe5902..186473f3 100644
--- a/README.md
+++ b/README.md
@@ -16,73 +16,301 @@ blog to the most popular websites in the world. PHP is distributed under the
 
 ---
 
-## Array Shape Return Types (RFC Implementation)
+## Typed Arrays & Array Shapes RFC Implementation
 
-This fork implements **Array Shape Return Types** for PHP, allowing you to specify
-element types for array return values using the `array<T>` syntax.
+This fork implements **Typed Arrays** and **Array Shapes** for PHP—two complementary features that bring type safety to PHP's most versatile data structure.
 
-### Features
+### The Problem
 
-- **Basic typed arrays**: `array<int>`, `array<string>`, `array<float>`, `array<bool>`
-- **Object typed arrays**: `array<MyClass>`, `array<DateTime>`
-- **Union types**: `array<int|string>`, `array<MyClass|OtherClass|int>`
-- **Nested arrays**: `array<array<int>>`, `array<array<array<string>>>` (up to 4 levels)
-- **Compile-time validation** for constant arrays (escape analysis optimization)
-- **Runtime validation** with detailed error messages
+PHP arrays are incredibly flexible, serving as lists, dictionaries, and structured records. But this flexibility comes at a cost: no way to express or enforce what an array should contain.
 
-### Usage
+```php
+function getUsers(): array {
+    // What's in this array? Objects? Associative arrays? Integers?
+    // The type system can't tell you.
+}
+```
 
-Enable strict array checking with the `strict_arrays` declare:
+### The Solution: Two Complementary Features
 
-```php
-<?php
-declare(strict_arrays=1);
+#### Typed Arrays — For Collections
 
-// Basic typed array
+When you have a **list of things of the same type**, use typed arrays:
+
+```php
+// A list of integers
 function getIds(): array<int> {
     return [1, 2, 3];
 }
 
-// Union types
-function getValues(): array<int|string> {
-    return [1, "two", 3];
+// A list of User objects
+function getActiveUsers(): array<User> {
+    return $this->repository->findActive();
+}
+
+// A dictionary with string keys and integer values
+function getScores(): array<string, int> {
+    return ['alice' => 95, 'bob' => 87, 'charlie' => 92];
+}
+```
+
+This is what you reach for when working with collections—arrays where every element is the same kind of thing.
+
+#### Array Shapes — For Structured Data
+
+When you have **structured data with known keys**, like records from a database or responses from an API, use array shapes:
+
+```php
+// Data from a database row
+function getUser(int $id): array{id: int, name: string, email: string} {
+    return $this->db->fetch("SELECT id, name, email FROM users WHERE id = ?", $id);
+}
+
+// Response from an external API
+function getWeather(string $city): array{temp: float, humidity: int, conditions: string} {
+    return json_decode(file_get_contents("https://api.weather.com/$city"), true);
+}
+```
+
+### Real-World Examples
+
+#### Working with Database Results
+
+```php
+// Define the shape of a user record
+shape UserRecord = array{
+    id: int,
+    name: string,
+    email: string,
+    created_at: string,
+    is_active?: bool
+};
+
+class UserRepository {
+    // Single record
+    public function find(int $id): ?UserRecord {
+        return $this->db->fetch("SELECT * FROM users WHERE id = ?", $id);
+    }
+
+    // Collection of records — combining both features!
+    public function findAll(): array<UserRecord> {
+        return $this->db->fetchAll("SELECT * FROM users");
+    }
+}
+```
+
+#### Working with API Responses
+
+```php
+// Shape describing the API response structure
+shape ApiResponse = array{
+    success: bool,
+    data: mixed,
+    error?: string,
+    meta?: array{page: int, total: int}
+};
+
+shape ProductData = array{
+    id: int,
+    name: string,
+    price: float,
+    tags: array<string>     // Nested typed array!
+};
+
+function fetchProduct(int $id): ProductData {
+    $response = $this->http->get("/api/products/$id");
+    return $response['data'];
+}
+
+function fetchProducts(): array<ProductData> {
+    $response = $this->http->get("/api/products");
+    return $response['data'];
+}
+```
+
+#### Configuration Arrays
+
+```php
+shape DatabaseConfig = array{
+    host: string,
+    port: int,
+    database: string,
+    username: string,
+    password: string,
+    options?: array<string, mixed>
+};
+
+shape AppConfig = array{
+    debug: bool,
+    env: string,
+    database: DatabaseConfig,
+    cache_ttl?: int
+};
+
+function loadConfig(string $path): AppConfig {
+    return require $path;
 }
+```
+
+### This is NOT About DTOs
+
+A common misconception: "Why not just use classes/DTOs?"
+
+**These features work with arrays, not objects.** They're designed for the many situations where arrays are the right tool:
+
+- **Database results** — PDO and other drivers return arrays
+- **JSON APIs** — `json_decode()` returns arrays
+- **Configuration files** — Often loaded as arrays
+- **Legacy code** — Millions of lines of PHP use arrays for structured data
+- **Interoperability** — Arrays are PHP's universal data interchange format
 
-// Object types
-function getUsers(): array<User> {
-    return [new User("Alice"), new User("Bob")];
+You don't have to choose between arrays and objects. Use objects when you need behavior (methods), use typed arrays when you're working with data.
+
+```php
+// Arrays for data from external sources
+function getApiUser(): array{id: int, name: string} {
+    return json_decode($response, true);
 }
 
-// Nested arrays (matrix)
-function getMatrix(): array<array<int>> {
-    return [[1, 2], [3, 4], [5, 6]];
+// Objects when you need behavior
+class User {
+    public function __construct(
+        public int $id,
+        public string $name
+    ) {}
+
+    public function greet(): string {
+        return "Hello, {$this->name}!";
+    }
 }
+```
+
+### Quick Reference
 
-// Mixed union with objects
-function getItems(): array<Product|Service|int> {
-    return [new Product(), 42, new Service()];
+```php
+// Typed arrays — for collections
+array<int>                     // List of integers
+array<string>                  // List of strings
+array<User>                    // List of User objects
+array<int|string>              // List of integers or strings
+array<string, int>             // Dictionary: string keys, int values
+array<array<int>>              // List of integer lists
+
+// Array shapes — for structured data
+array{id: int, name: string}   // Required keys
+array{id: int, email?: string} // Optional key (may be absent)
+array{data: ?string}           // Nullable value (can be null)
+array{user: array{id: int}}    // Nested shapes
+array{id: int, name: string}!  // Closed shape (no extra keys allowed)
+
+// Shape type aliases — for reusability
+shape User = array{id: int, name: string};
+shape Point = array{x: int, y: int};
+shape Config = array{debug: bool, cache?: int};
+
+// Shape inheritance
+shape BaseUser = array{id: int, name: string};
+shape AdminUser extends BaseUser = array{role: string, permissions: array<string>};
+```
+
+### Shape Inheritance
+
+Shapes support single inheritance with type covariance:
+
+```php
+shape Entity = array{id: int, created_at: string};
+shape User extends Entity = array{name: string, email: string};
+shape Admin extends User = array{role: string, permissions: array<string>};
+
+// Admin inherits all fields: id, created_at, name, email, role, permissions
+function getAdmin(): Admin {
+    return [
+        'id' => 1,
+        'created_at' => '2024-01-01',
+        'name' => 'Alice',
+        'email' => 'alice@example.com',
+        'role' => 'superadmin',
+        'permissions' => ['read', 'write', 'delete']
+    ];
 }
 ```
 
-### Error Handling
+**Covariance rules:**
+- Child shapes can narrow parent types (e.g., `string|int` → `string`)
+- Child shapes cannot widen types (e.g., `string` → `int` is rejected)
+- Child shapes can make optional properties required
+- Child shapes cannot make required properties optional
+
+### Closed Shapes
 
-When validation fails, a `TypeError` is thrown with details about the failing element:
+By default, shapes are "open" — they allow extra keys beyond what's defined. Use the `!` suffix for closed shapes that reject extra keys:
 
 ```php
-function getInts(): array<int> {
-    return [1, "two", 3];  // TypeError: array element at index 1 is string
+// Open shape (default) — extra keys allowed
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'allowed'];  // OK
+}
+
+// Closed shape — no extra keys allowed
+function getStrictUser(): array{id: int, name: string}! {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'forbidden'];
+    // TypeError: unexpected extra key "extra"
 }
 ```
 
+### Error Messages
+
+When validation fails, you get clear error messages:
+
+```php
+function getIds(): array<int> {
+    return [1, "two", 3];
+}
+// TypeError: getIds(): Return value must be of type array<int>,
+//            array element at index 1 is string
+
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1];
+}
+// TypeError: getUser(): Return value must be of type array{name: string, ...},
+//            array given with missing key "name"
+```
+
+### Shape Autoloading
+
+Shapes can be autoloaded like classes, keeping your codebase organized:
+
+```php
+// shapes/UserRecord.php
+<?php
+shape UserRecord = array{id: int, name: string, email: string};
+
+// Somewhere else in your code
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) require_once $file;
+});
+
+// UserRecord is autoloaded when first used
+function getUser(): UserRecord { ... }
+```
+
 ### Implementation Status
 
-- [x] Parser support for `array<T>` syntax
-- [x] Single type validation (`array<int>`, `array<string>`, etc.)
-- [x] Object/class type validation (`array<MyClass>`)
-- [x] Union type support (`array<int|string|MyClass>`)
-- [x] Nested array support (`array<array<T>>`)
-- [x] Compile-time escape analysis optimization
-- [x] Runtime validation with error reporting
+- [x] Typed arrays: `array<T>`, `array<K, V>`
+- [x] Array shapes: `array{key: type}`
+- [x] Optional keys: `array{key?: type}`
+- [x] Nullable values: `array{key: ?type}`
+- [x] Union types: `array<int|string>`
+- [x] Nested structures: `array<array<int>>`, `array{user: array{id: int}}`
+- [x] Shape type aliases: `shape Name = array{...}`
+- [x] Shape inheritance: `shape Child extends Parent = array{...}`
+- [x] Type covariance validation for shape inheritance
+- [x] Closed shapes: `array{...}!` (reject extra keys)
+- [x] Shape autoloading via `spl_autoload_register()`
+- [x] Reflection API support (`ReflectionArrayType`, `ReflectionArrayShapeType`)
+- [x] Runtime validation with detailed error messages
+- [x] Performance optimizations (string interning, cached key lookups)
 
 ---
 
diff --git a/Zend/tests/get_class_methods/bug32296.phpt b/Zend/tests/get_class_methods/bug32296.phpt
index 16914a71..612fab16 100644
--- a/Zend/tests/get_class_methods/bug32296.phpt
+++ b/Zend/tests/get_class_methods/bug32296.phpt
@@ -7,12 +7,12 @@ function __construct(){}
     abstract protected function unfold();
 }
 
-abstract class shape extends space{
+abstract class polygon extends space{
     private function x1() {}
     protected final function unfold(){}
 }
 
-abstract class quad extends shape{
+abstract class quad extends polygon{
     private function x2() {}
     function buggy(){
         $c = get_class($this);
diff --git a/Zend/tests/type_declarations/array_shapes/class_cannot_extend_shape.phpt b/Zend/tests/type_declarations/array_shapes/class_cannot_extend_shape.phpt
new file mode 100644
index 00000000..74898cf6
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/class_cannot_extend_shape.phpt
@@ -0,0 +1,13 @@
+--TEST--
+Class cannot extend a shape
+--FILE--
+<?php
+
+shape MyShape = array{id: int, name: string};
+
+class BadClass extends MyShape {
+}
+
+?>
+--EXPECTF--
+Fatal error: Class BadClass cannot extend shape MyShape in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/class_method.phpt b/Zend/tests/type_declarations/array_shapes/class_method.phpt
index fd4ae661..6e6047f6 100644
--- a/Zend/tests/type_declarations/array_shapes/class_method.phpt
+++ b/Zend/tests/type_declarations/array_shapes/class_method.phpt
@@ -1,8 +1,8 @@
 --TEST--
 Array shape in class methods
+--XLEAK--
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 class UserService {
     public function createUser(array{name: string, email: string} $data): array{id: int, name: string, email: string} {
diff --git a/Zend/tests/type_declarations/array_shapes/closed_shape_basic.phpt b/Zend/tests/type_declarations/array_shapes/closed_shape_basic.phpt
new file mode 100644
index 00000000..e147be7e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/closed_shape_basic.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Closed array shape - basic validation
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+// Closed shape: no extra keys allowed
+function getUser(): array{id: int, name: string}! {
+    return ['id' => 1, 'name' => 'Alice'];
+}
+
+$user = getUser();
+var_dump($user);
+
+// Verify reflection
+$ref = new ReflectionFunction('getUser');
+$type = $ref->getReturnType();
+var_dump($type->isClosed());
+echo $type . "\n";
+
+?>
+--EXPECTF--
+array(2) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(5) "Alice"
+}
+bool(true)
+array{id: int, name: string}!%A
diff --git a/Zend/tests/type_declarations/array_shapes/closed_shape_extra_key_error.phpt b/Zend/tests/type_declarations/array_shapes/closed_shape_extra_key_error.phpt
new file mode 100644
index 00000000..2bc0a2ed
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/closed_shape_extra_key_error.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Closed array shape - extra key error
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+function getUser(): array{id: int, name: string}! {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'not allowed'];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+getUser(): Return value must be of type closed shape, unexpected extra key "extra"%A
diff --git a/Zend/tests/type_declarations/array_shapes/closed_shape_param.phpt b/Zend/tests/type_declarations/array_shapes/closed_shape_param.phpt
new file mode 100644
index 00000000..5163dc52
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/closed_shape_param.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Closed array shape - parameter type
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+function processUser(array{id: int, name: string}! $user): void {
+    echo "Processing user: " . $user['name'] . "\n";
+}
+
+// Valid: exact match
+processUser(['id' => 1, 'name' => 'Alice']);
+
+// Invalid: extra key
+try {
+    processUser(['id' => 2, 'name' => 'Bob', 'extra' => 'data']);
+} catch (TypeError $e) {
+    echo $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Processing user: Alice
+processUser(): Argument #1 ($user) must be of type closed shape, unexpected extra key "extra"%A
diff --git a/Zend/tests/type_declarations/array_shapes/open_shape_extra_keys.phpt b/Zend/tests/type_declarations/array_shapes/open_shape_extra_keys.phpt
new file mode 100644
index 00000000..c915464e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/open_shape_extra_keys.phpt
@@ -0,0 +1,35 @@
+--TEST--
+Open array shape - extra keys allowed (default)
+--SKIPIF--
+<?php if (getenv('USE_ZEND_ALLOC') === '0') die('skip Not compatible with valgrind'); ?>
+--FILE--
+<?php
+
+// Open shape (default): extra keys are allowed
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice', 'extra' => 'allowed', 'more' => 'data'];
+}
+
+$user = getUser();
+var_dump($user);
+
+// Verify reflection shows not closed
+$ref = new ReflectionFunction('getUser');
+$type = $ref->getReturnType();
+var_dump($type->isClosed());
+echo $type . "\n";
+
+?>
+--EXPECTF--
+array(4) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(5) "Alice"
+  ["extra"]=>
+  string(7) "allowed"
+  ["more"]=>
+  string(4) "data"
+}
+bool(false)
+array{id: int, name: string}%A
diff --git a/Zend/tests/type_declarations/array_shapes/param_basic.phpt b/Zend/tests/type_declarations/array_shapes/param_basic.phpt
index 84c2e0b1..28bbadde 100644
--- a/Zend/tests/type_declarations/array_shapes/param_basic.phpt
+++ b/Zend/tests/type_declarations/array_shapes/param_basic.phpt
@@ -2,7 +2,6 @@
 Array shape as parameter type - basic validation
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function processPoint(array{x: int, y: int} $point): int {
     return $point['x'] + $point['y'];
diff --git a/Zend/tests/type_declarations/array_shapes/param_missing_key.phpt b/Zend/tests/type_declarations/array_shapes/param_missing_key.phpt
index 8dbe8bad..45673817 100644
--- a/Zend/tests/type_declarations/array_shapes/param_missing_key.phpt
+++ b/Zend/tests/type_declarations/array_shapes/param_missing_key.phpt
@@ -2,7 +2,6 @@
 Array shape as parameter type - missing required key
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function processPoint(array{x: int, y: int} $point): int {
     return $point['x'] + $point['y'];
@@ -16,4 +15,4 @@ function processPoint(array{x: int, y: int} $point): int {
 
 ?>
 --EXPECT--
-TypeError: Argument #1 must be of type array{y: ...}, missing required key "y"
+TypeError: processPoint(): Argument #1 ($point) must be of type array{y: int, ...}, array given with missing key "y"
diff --git a/Zend/tests/type_declarations/array_shapes/param_nested_shape.phpt b/Zend/tests/type_declarations/array_shapes/param_nested_shape.phpt
index 0e92ee01..ead95d7c 100644
--- a/Zend/tests/type_declarations/array_shapes/param_nested_shape.phpt
+++ b/Zend/tests/type_declarations/array_shapes/param_nested_shape.phpt
@@ -1,8 +1,8 @@
 --TEST--
 Array shape as parameter type - nested shapes
+--XLEAK--
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function processUser(array{
     id: int,
diff --git a/Zend/tests/type_declarations/array_shapes/param_optional_keys.phpt b/Zend/tests/type_declarations/array_shapes/param_optional_keys.phpt
index c64f8c50..cc395e26 100644
--- a/Zend/tests/type_declarations/array_shapes/param_optional_keys.phpt
+++ b/Zend/tests/type_declarations/array_shapes/param_optional_keys.phpt
@@ -1,8 +1,8 @@
 --TEST--
 Array shape as parameter type - optional keys
+--XLEAK--
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function processConfig(array{host: string, port?: int, ssl?: bool} $config): string {
     $result = $config['host'];
diff --git a/Zend/tests/type_declarations/array_shapes/param_typed_array.phpt b/Zend/tests/type_declarations/array_shapes/param_typed_array.phpt
index b5b462f2..17b0741b 100644
--- a/Zend/tests/type_declarations/array_shapes/param_typed_array.phpt
+++ b/Zend/tests/type_declarations/array_shapes/param_typed_array.phpt
@@ -2,7 +2,6 @@
 Typed array as parameter type - array<T>
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function sumNumbers(array<int> $numbers): int {
     return array_sum($numbers);
diff --git a/Zend/tests/type_declarations/array_shapes/param_typed_array_error.phpt b/Zend/tests/type_declarations/array_shapes/param_typed_array_error.phpt
index be2bfd1b..e3234569 100644
--- a/Zend/tests/type_declarations/array_shapes/param_typed_array_error.phpt
+++ b/Zend/tests/type_declarations/array_shapes/param_typed_array_error.phpt
@@ -2,7 +2,6 @@
 Typed array as parameter type - wrong element type
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function sumNumbers(array<int> $numbers): int {
     return array_sum($numbers);
diff --git a/Zend/tests/type_declarations/array_shapes/param_wrong_type.phpt b/Zend/tests/type_declarations/array_shapes/param_wrong_type.phpt
index b48df2a5..5e1159a0 100644
--- a/Zend/tests/type_declarations/array_shapes/param_wrong_type.phpt
+++ b/Zend/tests/type_declarations/array_shapes/param_wrong_type.phpt
@@ -2,7 +2,6 @@
 Array shape as parameter type - wrong value type
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function processPoint(array{x: int, y: int} $point): int {
     return $point['x'] + $point['y'];
@@ -16,4 +15,4 @@ function processPoint(array{x: int, y: int} $point): int {
 
 ?>
 --EXPECT--
-TypeError: Argument #1 key "y" must be of type int, string given
+TypeError: processPoint(): Argument #1 ($point) must be of type array{y: int, ...}, array key "y" is string
diff --git a/Zend/tests/type_declarations/array_shapes/return_basic.phpt b/Zend/tests/type_declarations/array_shapes/return_basic.phpt
index 99e61988..a346d6ed 100644
--- a/Zend/tests/type_declarations/array_shapes/return_basic.phpt
+++ b/Zend/tests/type_declarations/array_shapes/return_basic.phpt
@@ -2,7 +2,6 @@
 Array shape as return type - basic validation
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function getPoint(): array{x: int, y: int} {
     return ['x' => 10, 'y' => 20];
diff --git a/Zend/tests/type_declarations/array_shapes/return_missing_key.phpt b/Zend/tests/type_declarations/array_shapes/return_missing_key.phpt
index 0134821d..996382a1 100644
--- a/Zend/tests/type_declarations/array_shapes/return_missing_key.phpt
+++ b/Zend/tests/type_declarations/array_shapes/return_missing_key.phpt
@@ -2,7 +2,6 @@
 Array shape as return type - missing required key
 --FILE--
 <?php
-declare(strict_arrays=1);
 
 function getPoint(): array{x: int, y: int} {
     return ['x' => 10];
@@ -16,4 +15,4 @@ function getPoint(): array{x: int, y: int} {
 
 ?>
 --EXPECT--
-TypeError: getPoint(): Return value must be of type array{y: ...}, missing required key "y"
+TypeError: getPoint(): Return value must be of type array{y: int, ...}, array given with missing key "y"
diff --git a/Zend/tests/type_declarations/array_shapes/shape_autoload.phpt b/Zend/tests/type_declarations/array_shapes/shape_autoload.phpt
new file mode 100644
index 00000000..9b995411
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_autoload.phpt
@@ -0,0 +1,42 @@
+--TEST--
+Shape type alias autoloading
+--XLEAK--
+--FILE--
+<?php
+
+// Create temporary shape file
+$tempDir = sys_get_temp_dir() . '/php_shape_autoload_test_' . getmypid();
+mkdir($tempDir);
+file_put_contents($tempDir . '/User.php', '<?php
+shape User = array{id: int, name: string};
+');
+
+$autoloaded = [];
+spl_autoload_register(function($class) use ($tempDir, &$autoloaded) {
+    $autoloaded[] = $class;
+    $file = "$tempDir/$class.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// Shape should not exist before autoload
+var_dump(shape_exists('User', false));
+
+// Trigger autoload via shape_exists
+var_dump(shape_exists('User', true));
+
+// Verify autoloader was called
+var_dump($autoloaded);
+
+// Clean up
+unlink($tempDir . '/User.php');
+rmdir($tempDir);
+?>
+--EXPECT--
+bool(false)
+bool(true)
+array(1) {
+  [0]=>
+  string(4) "User"
+}
diff --git a/Zend/tests/type_declarations/array_shapes/shape_autoload_type_checking.phpt b/Zend/tests/type_declarations/array_shapes/shape_autoload_type_checking.phpt
new file mode 100644
index 00000000..dcd49b17
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_autoload_type_checking.phpt
@@ -0,0 +1,46 @@
+--TEST--
+Shape type alias autoloading with type checking
+--XLEAK--
+--FILE--
+<?php
+
+// Create temporary shape file
+$tempDir = sys_get_temp_dir() . '/php_shape_autoload_test_' . getmypid();
+mkdir($tempDir);
+file_put_contents($tempDir . '/User.php', '<?php
+shape User = array{id: int, name: string};
+');
+
+spl_autoload_register(function($class) use ($tempDir) {
+    $file = "$tempDir/$class.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// Define function using the shape type
+function getUser(): User {
+    return ["id" => 1, "name" => "Alice"];
+}
+
+function processUser(User $user): void {
+    echo "Processing user: {$user['name']}\n";
+}
+
+// Use the functions - should trigger autoload and work correctly
+$user = getUser();
+var_dump($user);
+processUser($user);
+
+// Clean up
+unlink($tempDir . '/User.php');
+rmdir($tempDir);
+?>
+--EXPECT--
+array(2) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(5) "Alice"
+}
+Processing user: Alice
diff --git a/Zend/tests/type_declarations/array_shapes/shape_cannot_extend_class.phpt b/Zend/tests/type_declarations/array_shapes/shape_cannot_extend_class.phpt
new file mode 100644
index 00000000..cd3d9771
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_cannot_extend_class.phpt
@@ -0,0 +1,11 @@
+--TEST--
+Shape cannot extend a class
+--FILE--
+<?php
+
+class MyClass {}
+shape BadShape extends MyClass = array{id: int};
+
+?>
+--EXPECTF--
+Fatal error: Shape BadShape cannot extend class MyClass in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_cross_file.phpt b/Zend/tests/type_declarations/array_shapes/shape_cross_file.phpt
new file mode 100644
index 00000000..8ec49401
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_cross_file.phpt
@@ -0,0 +1,44 @@
+--TEST--
+Shape type alias cross-file usage via require
+--XLEAK--
+--FILE--
+<?php
+// Create temporary shape file
+$tempDir = sys_get_temp_dir() . '/php_shape_test_' . getmypid();
+mkdir($tempDir);
+file_put_contents($tempDir . '/shapes.php', '<?php
+shape User = array{id: int, name: string};
+shape Address = array{street: string, city: string};
+');
+
+$mainCode = <<<'MAIN'
+<?php
+require_once "%s/shapes.php";
+
+function getUser(): User {
+    return ["id" => 1, "name" => "Bob"];
+}
+
+function getAddress(): Address {
+    return ["street" => "123 Main St", "city" => "NYC"];
+}
+
+$user = getUser();
+$address = getAddress();
+
+echo "User: " . $user["name"] . "\n";
+echo "Address: " . $address["street"] . ", " . $address["city"] . "\n";
+MAIN;
+
+file_put_contents($tempDir . '/main.php', sprintf($mainCode, $tempDir));
+
+include $tempDir . '/main.php';
+
+// Clean up
+unlink($tempDir . '/shapes.php');
+unlink($tempDir . '/main.php');
+rmdir($tempDir);
+?>
+--EXPECT--
+User: Bob
+Address: 123 Main St, NYC
diff --git a/Zend/tests/type_declarations/array_shapes/shape_exists.phpt b/Zend/tests/type_declarations/array_shapes/shape_exists.phpt
new file mode 100644
index 00000000..0d26b73e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_exists.phpt
@@ -0,0 +1,32 @@
+--TEST--
+shape_exists() function
+--XLEAK--
+--FILE--
+<?php
+
+// Before defining shape
+var_dump(shape_exists('Point', false));
+var_dump(shape_exists('NonExistent', false));
+
+// Define a shape
+shape Point = array{x: int, y: int};
+
+// After defining shape
+var_dump(shape_exists('Point', false));
+var_dump(shape_exists('point', false));  // Case-insensitive
+var_dump(shape_exists('POINT', false));  // Case-insensitive
+var_dump(shape_exists('NonExistent', false));
+
+// With autoload parameter (should still work without autoloader)
+var_dump(shape_exists('Point', true));
+var_dump(shape_exists('NonExistent', true));
+?>
+--EXPECT--
+bool(true)
+bool(false)
+bool(true)
+bool(true)
+bool(true)
+bool(false)
+bool(true)
+bool(false)
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_basic.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_basic.phpt
new file mode 100644
index 00000000..a06641f2
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_basic.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Shape inheritance - basic extends syntax
+--XLEAK--
+--FILE--
+<?php
+
+shape BaseShape = array{id: int, name: string};
+shape ExtendedShape extends BaseShape = array{email: string};
+
+function test(ExtendedShape $data): void {
+    var_dump($data);
+}
+
+// Test with all required fields from both parent and child
+test(['id' => 1, 'name' => 'John', 'email' => 'john@example.com']);
+
+// Test that parent fields are accessible
+function getParentFields(ExtendedShape $data): array {
+    return ['id' => $data['id'], 'name' => $data['name']];
+}
+
+var_dump(getParentFields(['id' => 2, 'name' => 'Jane', 'email' => 'jane@example.com']));
+
+echo "Done\n";
+?>
+--EXPECT--
+array(3) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(4) "John"
+  ["email"]=>
+  string(16) "john@example.com"
+}
+array(2) {
+  ["id"]=>
+  int(2)
+  ["name"]=>
+  string(4) "Jane"
+}
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_covariance.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_covariance.phpt
new file mode 100644
index 00000000..0b74b5f0
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_covariance.phpt
@@ -0,0 +1,54 @@
+--TEST--
+Shape inheritance - valid type covariance
+--XLEAK--
+--FILE--
+<?php
+
+// Test 1: Child can narrow union type to single type
+shape BaseUnion = array{id: int, value: string|int};
+shape ChildNarrow extends BaseUnion = array{value: string};  // Valid: string|int -> string
+
+function testNarrow(ChildNarrow $data): void {
+    echo "value type narrowed: ";
+    var_dump($data['value']);
+}
+testNarrow(['id' => 1, 'value' => 'hello']);
+
+// Test 2: Child can keep same type
+shape BaseSame = array{id: int, name: string};
+shape ChildSame extends BaseSame = array{name: string};  // Valid: same type
+
+function testSame(ChildSame $data): void {
+    echo "value type same: ";
+    var_dump($data['name']);
+}
+testSame(['id' => 2, 'name' => 'Alice']);
+
+// Test 3: Child can make optional required (valid)
+shape BaseOptional = array{id: int, status?: string};
+shape ChildRequired extends BaseOptional = array{status: string};  // Valid: optional -> required
+
+function testRequired(ChildRequired $data): void {
+    echo "optional made required: ";
+    var_dump($data['status']);
+}
+testRequired(['id' => 3, 'status' => 'active']);
+
+// Test 4: Child can add new properties
+shape BaseMinimal = array{id: int};
+shape ChildExtended extends BaseMinimal = array{name: string, email: string};
+
+function testExtended(ChildExtended $data): void {
+    echo "extended with new props: ";
+    var_dump($data['name']);
+}
+testExtended(['id' => 4, 'name' => 'Bob', 'email' => 'bob@example.com']);
+
+echo "Done\n";
+?>
+--EXPECT--
+value type narrowed: string(5) "hello"
+value type same: string(5) "Alice"
+optional made required: string(6) "active"
+extended with new props: string(3) "Bob"
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_nested.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_nested.phpt
new file mode 100644
index 00000000..aab63f78
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_nested.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Shape inheritance - nested/chained inheritance
+--XLEAK--
+--FILE--
+<?php
+
+shape Base = array{a: int};
+shape Middle extends Base = array{b: string};
+shape Top extends Middle = array{c: bool};
+
+function test(Top $data): void {
+    echo "a=" . $data['a'] . ", b=" . $data['b'] . ", c=" . ($data['c'] ? 'true' : 'false') . "\n";
+}
+
+test(['a' => 42, 'b' => 'hello', 'c' => true]);
+test(['a' => 100, 'b' => 'world', 'c' => false]);
+
+echo "Done\n";
+?>
+--EXPECT--
+a=42, b=hello, c=true
+a=100, b=world, c=false
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_override.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_override.phpt
new file mode 100644
index 00000000..2a5642a1
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_override.phpt
@@ -0,0 +1,12 @@
+--TEST--
+Shape inheritance - invalid covariance (widening type error)
+--XLEAK--
+--FILE--
+<?php
+
+shape Base = array{id: int, value: string};
+shape Child extends Base = array{value: int};  // Invalid: string -> int is not covariant
+
+?>
+--EXPECTF--
+Fatal error: Shape Child property 'value' type int is not compatible with parent type string in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_reflection.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_reflection.phpt
new file mode 100644
index 00000000..b777ade9
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_reflection.phpt
@@ -0,0 +1,34 @@
+--TEST--
+Shape inheritance - reflection shows flattened structure
+--XLEAK--
+--FILE--
+<?php
+
+shape BaseShape = array{id: int, name: string};
+shape ExtendedShape extends BaseShape = array{email: string};
+
+$rf = new ReflectionFunction(function(ExtendedShape $arg) {});
+$params = $rf->getParameters();
+$type = $params[0]->getType();
+
+echo "Type string: " . $type . "\n";
+echo "Element count: " . $type->getElementCount() . "\n";
+echo "Required count: " . $type->getRequiredElementCount() . "\n";
+
+echo "\nElements:\n";
+foreach ($type->getElements() as $elem) {
+    echo "  - " . $elem->getName() . ": " . $elem->getType() . "\n";
+}
+
+echo "Done\n";
+?>
+--EXPECT--
+Type string: array{id: int, name: string, email: string}
+Element count: 3
+Required count: 3
+
+Elements:
+  - id: int
+  - name: string
+  - email: string
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_inheritance_required_to_optional_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_inheritance_required_to_optional_error.phpt
new file mode 100644
index 00000000..60730c0f
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_inheritance_required_to_optional_error.phpt
@@ -0,0 +1,12 @@
+--TEST--
+Shape inheritance - cannot make required property optional
+--XLEAK--
+--FILE--
+<?php
+
+shape Base = array{id: int, name: string};
+shape Child extends Base = array{name?: string};  // Invalid: required -> optional
+
+?>
+--EXPECTF--
+Fatal error: Shape Child cannot make required property 'name' optional (inherited as required from parent) in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_name_basic.phpt b/Zend/tests/type_declarations/array_shapes/shape_name_basic.phpt
new file mode 100644
index 00000000..e08a556a
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_name_basic.phpt
@@ -0,0 +1,23 @@
+--TEST--
+::shape syntax - basic usage
+--XLEAK--
+--FILE--
+<?php
+
+shape UserShape = array{id: int, name: string};
+
+echo UserShape::shape . "\n";
+
+$name = UserShape::shape;
+echo $name . "\n";
+
+// Use in an expression
+echo "Shape name is: " . UserShape::shape . "\n";
+
+echo "Done\n";
+?>
+--EXPECT--
+UserShape
+UserShape
+Shape name is: UserShape
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_name_namespaced.phpt b/Zend/tests/type_declarations/array_shapes/shape_name_namespaced.phpt
new file mode 100644
index 00000000..761de143
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_name_namespaced.phpt
@@ -0,0 +1,24 @@
+--TEST--
+::shape syntax - with namespaces
+--XLEAK--
+--FILE--
+<?php
+
+namespace App\Types;
+
+shape UserShape = array{id: int, name: string};
+
+// Should return fully qualified name
+echo UserShape::shape . "\n";
+
+namespace App\Other;
+
+// Reference shape from another namespace
+echo \App\Types\UserShape::shape . "\n";
+
+echo "Done\n";
+?>
+--EXPECT--
+App\Types\UserShape
+App\Types\UserShape
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_name_on_class_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_name_on_class_error.phpt
new file mode 100644
index 00000000..3c9aee2e
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_name_on_class_error.phpt
@@ -0,0 +1,11 @@
+--TEST--
+::shape syntax - cannot use on class
+--FILE--
+<?php
+
+class MyClass {}
+
+echo MyClass::shape;
+?>
+--EXPECTF--
+Fatal error: Cannot use ::shape on class MyClass, use ::class instead in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_namespaced.phpt b/Zend/tests/type_declarations/array_shapes/shape_namespaced.phpt
new file mode 100644
index 00000000..67cfea57
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_namespaced.phpt
@@ -0,0 +1,87 @@
+--TEST--
+Namespaced shape type aliases with autoloading
+--XLEAK--
+--FILE--
+<?php
+
+// Create temporary directory structure for namespaced shapes
+$tempDir = sys_get_temp_dir() . '/php_shape_ns_test_' . getmypid();
+mkdir($tempDir . '/App/Shapes', 0755, true);
+mkdir($tempDir . '/App/Services', 0755, true);
+
+// Create namespaced shape file
+file_put_contents($tempDir . '/App/Shapes/UserShape.php', '<?php
+namespace App\Shapes;
+
+shape UserShape = array{id: int, name: string, email: string};
+');
+
+// Create service that uses the namespaced shape
+file_put_contents($tempDir . '/App/Services/UserService.php', '<?php
+namespace App\Services;
+
+use App\Shapes\UserShape;
+
+class UserService {
+    public function getUser(int $id): UserShape {
+        return ["id" => $id, "name" => "Alice", "email" => "alice@example.com"];
+    }
+
+    public function processUser(UserShape $user): string {
+        return "Processing: " . $user["name"];
+    }
+}
+');
+
+// Register PSR-4 style autoloader
+$autoloaded = [];
+spl_autoload_register(function($name) use ($tempDir, &$autoloaded) {
+    $autoloaded[] = $name;
+    $file = $tempDir . '/' . str_replace('\\', '/', $name) . '.php';
+    if (file_exists($file)) {
+        require_once $file;
+        return true;
+    }
+    return false;
+});
+
+// Test 1: shape_exists with namespaced shape (no autoload)
+echo "Before autoload (no trigger): ";
+var_dump(shape_exists('App\Shapes\UserShape', false));
+
+// Test 2: shape_exists with namespaced shape (with autoload)
+echo "With autoload trigger: ";
+var_dump(shape_exists('App\Shapes\UserShape', true));
+
+// Test 3: Use namespaced shape in class method
+$service = new App\Services\UserService();
+$user = $service->getUser(42);
+echo "User ID: " . $user['id'] . ", Name: " . $user['name'] . "\n";
+
+// Test 4: Shape as parameter type
+echo $service->processUser($user) . "\n";
+
+// Test 5: Verify autoloader was called for both shape and class
+echo "Autoloaded:\n";
+foreach ($autoloaded as $name) {
+    echo "  - $name\n";
+}
+
+// Clean up
+unlink($tempDir . '/App/Shapes/UserShape.php');
+unlink($tempDir . '/App/Services/UserService.php');
+rmdir($tempDir . '/App/Services');
+rmdir($tempDir . '/App/Shapes');
+rmdir($tempDir . '/App');
+rmdir($tempDir);
+echo "Done\n";
+?>
+--EXPECT--
+Before autoload (no trigger): bool(false)
+With autoload trigger: bool(true)
+User ID: 42, Name: Alice
+Processing: Alice
+Autoloaded:
+  - App\Shapes\UserShape
+  - App\Services\UserService
+Done
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_basic.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_basic.phpt
new file mode 100644
index 00000000..7de0ecc2
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_basic.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Shape type alias basic usage
+--XLEAK--
+--FILE--
+<?php
+
+shape User = array{id: int, name: string};
+
+function getUser(): User {
+    return ["id" => 1, "name" => "John"];
+}
+
+function greetUser(User $user): string {
+    return "Hello, " . $user["name"];
+}
+
+$user = getUser();
+var_dump($user);
+echo greetUser($user) . "\n";
+?>
+--EXPECT--
+array(2) {
+  ["id"]=>
+  int(1)
+  ["name"]=>
+  string(4) "John"
+}
+Hello, John
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_nested.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_nested.phpt
new file mode 100644
index 00000000..d062f2f4
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_nested.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Shape type alias with nested shapes
+--XLEAK--
+--FILE--
+<?php
+
+shape Address = array{street: string, city: string, zip: string};
+shape Person = array{name: string, address: Address};
+
+function getPerson(): Person {
+    return [
+        "name" => "John Doe",
+        "address" => [
+            "street" => "123 Main St",
+            "city" => "Springfield",
+            "zip" => "12345"
+        ]
+    ];
+}
+
+$person = getPerson();
+echo $person["name"] . " lives at " . $person["address"]["street"] . "\n";
+?>
+--EXPECT--
+John Doe lives at 123 Main St
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_redeclare_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_redeclare_error.phpt
new file mode 100644
index 00000000..85f430be
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_redeclare_error.phpt
@@ -0,0 +1,11 @@
+--TEST--
+Shape type alias redeclaration error
+--FILE--
+<?php
+
+shape User = array{id: int};
+shape User = array{name: string};
+
+?>
+--EXPECTF--
+Fatal error: Cannot redeclare shape User in %s on line %d
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_type_error.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_type_error.phpt
new file mode 100644
index 00000000..3e91db31
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_type_error.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Shape type alias type error
+--XLEAK--
+--FILE--
+<?php
+
+shape User = array{id: int, name: string};
+
+function getUser(): User {
+    return ["id" => "not-an-int", "name" => "John"];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+?>
+--EXPECT--
+Caught: getUser(): Return value must be of type array{id: int, ...}, array key "id" is string
diff --git a/Zend/tests/type_declarations/array_shapes/shape_type_alias_with_typed_arrays.phpt b/Zend/tests/type_declarations/array_shapes/shape_type_alias_with_typed_arrays.phpt
new file mode 100644
index 00000000..3fa8d10d
--- /dev/null
+++ b/Zend/tests/type_declarations/array_shapes/shape_type_alias_with_typed_arrays.phpt
@@ -0,0 +1,27 @@
+--TEST--
+Shape type alias with typed arrays
+--XLEAK--
+--FILE--
+<?php
+
+shape Order = array{
+    id: int,
+    items: array<string>,
+    total: float
+};
+
+function getOrder(): Order {
+    return [
+        "id" => 42,
+        "items" => ["apple", "banana", "orange"],
+        "total" => 12.99
+    ];
+}
+
+$order = getOrder();
+echo "Order #" . $order["id"] . " - $" . $order["total"] . "\n";
+echo "Items: " . implode(", ", $order["items"]) . "\n";
+?>
+--EXPECT--
+Order #42 - $12.99
+Items: apple, banana, orange
diff --git a/Zend/tests/typed_arrays/abstract_class_typed_array.phpt b/Zend/tests/typed_arrays/abstract_class_typed_array.phpt
new file mode 100644
index 00000000..b1ec3a25
--- /dev/null
+++ b/Zend/tests/typed_arrays/abstract_class_typed_array.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Abstract class: typed array in abstract method
+--FILE--
+<?php
+
+
+abstract class DataStore {
+    abstract public function getItems(): array<string>;
+    abstract public function addItem(string $item): void;
+}
+
+class InMemoryStore extends DataStore {
+    private array<string> $items = [];
+
+    public function getItems(): array<string> {
+        return $this->items;
+    }
+
+    public function addItem(string $item): void {
+        $this->items[] = $item;
+    }
+}
+
+$store = new InMemoryStore();
+$store->addItem("first");
+$store->addItem("second");
+echo "Items: " . implode(", ", $store->getItems()) . "\n";
+
+?>
+--EXPECT--
+Items: first, second
diff --git a/Zend/tests/typed_arrays/arrow_function_typed_array.phpt b/Zend/tests/typed_arrays/arrow_function_typed_array.phpt
new file mode 100644
index 00000000..ce4e89a6
--- /dev/null
+++ b/Zend/tests/typed_arrays/arrow_function_typed_array.phpt
@@ -0,0 +1,14 @@
+--TEST--
+Arrow function: typed array in arrow function parameter and return type
+--FILE--
+<?php
+
+
+$filter = fn(array<int> $nums): array<int> => array_filter($nums, fn($n) => $n > 2);
+
+$result = $filter([1, 2, 3, 4, 5]);
+echo "Filtered: " . implode(", ", $result) . "\n";
+
+?>
+--EXPECT--
+Filtered: 3, 4, 5
diff --git a/Zend/tests/typed_arrays/basic_int_array.phpt b/Zend/tests/typed_arrays/basic_int_array.phpt
new file mode 100644
index 00000000..6d9b7766
--- /dev/null
+++ b/Zend/tests/typed_arrays/basic_int_array.phpt
@@ -0,0 +1,41 @@
+--TEST--
+Typed array: array<int> basic functionality
+--FILE--
+<?php
+
+
+function getNumbers(): array<int> {
+    return [1, 2, 3, 4, 5];
+}
+
+function sumNumbers(array<int> $nums): int {
+    return array_sum($nums);
+}
+
+$nums = getNumbers();
+var_dump($nums);
+echo "Sum: " . sumNumbers($nums) . "\n";
+
+// Empty array is valid
+function emptyInts(): array<int> {
+    return [];
+}
+var_dump(emptyInts());
+
+?>
+--EXPECT--
+array(5) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(2)
+  [2]=>
+  int(3)
+  [3]=>
+  int(4)
+  [4]=>
+  int(5)
+}
+Sum: 15
+array(0) {
+}
diff --git a/Zend/tests/typed_arrays/basic_shape.phpt b/Zend/tests/typed_arrays/basic_shape.phpt
new file mode 100644
index 00000000..27f5ad4e
--- /dev/null
+++ b/Zend/tests/typed_arrays/basic_shape.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Array shape: basic array{key: type} functionality
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string, email: string} {
+    return [
+        'id' => 1,
+        'name' => 'Alice',
+        'email' => 'alice@example.com'
+    ];
+}
+
+$user = getUser();
+echo "ID: {$user['id']}\n";
+echo "Name: {$user['name']}\n";
+echo "Email: {$user['email']}\n";
+
+?>
+--EXPECT--
+ID: 1
+Name: Alice
+Email: alice@example.com
diff --git a/Zend/tests/typed_arrays/basic_string_array.phpt b/Zend/tests/typed_arrays/basic_string_array.phpt
new file mode 100644
index 00000000..b954375e
--- /dev/null
+++ b/Zend/tests/typed_arrays/basic_string_array.phpt
@@ -0,0 +1,29 @@
+--TEST--
+Typed array: array<string> basic functionality
+--FILE--
+<?php
+
+
+function getNames(): array<string> {
+    return ["Alice", "Bob", "Charlie"];
+}
+
+function joinNames(array<string> $names): string {
+    return implode(", ", $names);
+}
+
+$names = getNames();
+var_dump($names);
+echo "Names: " . joinNames($names) . "\n";
+
+?>
+--EXPECT--
+array(3) {
+  [0]=>
+  string(5) "Alice"
+  [1]=>
+  string(3) "Bob"
+  [2]=>
+  string(7) "Charlie"
+}
+Names: Alice, Bob, Charlie
diff --git a/Zend/tests/typed_arrays/bool_array.phpt b/Zend/tests/typed_arrays/bool_array.phpt
new file mode 100644
index 00000000..7f6bfa51
--- /dev/null
+++ b/Zend/tests/typed_arrays/bool_array.phpt
@@ -0,0 +1,17 @@
+--TEST--
+Typed array: array<bool> functionality
+--FILE--
+<?php
+
+
+function getFlags(): array<bool> {
+    return [true, false, true, true];
+}
+
+$flags = getFlags();
+$trueCount = count(array_filter($flags));
+echo "True count: $trueCount out of " . count($flags) . "\n";
+
+?>
+--EXPECT--
+True count: 3 out of 4
diff --git a/Zend/tests/typed_arrays/closure_typed_array.phpt b/Zend/tests/typed_arrays/closure_typed_array.phpt
new file mode 100644
index 00000000..7e3cd4e7
--- /dev/null
+++ b/Zend/tests/typed_arrays/closure_typed_array.phpt
@@ -0,0 +1,17 @@
+--TEST--
+Closure: typed array in closure parameter and return type
+--FILE--
+<?php
+
+
+$transform = function(array<int> $numbers): array<int> {
+    return array_map(fn($n) => $n * 2, $numbers);
+};
+
+$numbers = [1, 2, 3, 4, 5];
+$doubled = $transform($numbers);
+echo "Doubled: " . implode(", ", $doubled) . "\n";
+
+?>
+--EXPECT--
+Doubled: 2, 4, 6, 8, 10
diff --git a/Zend/tests/typed_arrays/empty_shape.phpt b/Zend/tests/typed_arrays/empty_shape.phpt
new file mode 100644
index 00000000..536e8106
--- /dev/null
+++ b/Zend/tests/typed_arrays/empty_shape.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Edge case: empty array shape (no fields)
+--FILE--
+<?php
+
+
+// Empty shape - accepts any array but provides no type guarantees
+function processEmpty(array{} $data): void {
+    echo "Got array with " . count($data) . " elements\n";
+}
+
+processEmpty([]);
+processEmpty(['extra' => 'data']);
+
+?>
+--EXPECT--
+Got array with 0 elements
+Got array with 1 elements
diff --git a/Zend/tests/typed_arrays/float_array.phpt b/Zend/tests/typed_arrays/float_array.phpt
new file mode 100644
index 00000000..12424353
--- /dev/null
+++ b/Zend/tests/typed_arrays/float_array.phpt
@@ -0,0 +1,22 @@
+--TEST--
+Typed array: array<float> functionality
+--FILE--
+<?php
+
+
+function getPrices(): array<float> {
+    return [19.99, 29.99, 39.99];
+}
+
+function calculateTotal(array<float> $prices): float {
+    return array_sum($prices);
+}
+
+$prices = getPrices();
+echo "Prices: " . implode(", ", $prices) . "\n";
+echo "Total: " . calculateTotal($prices) . "\n";
+
+?>
+--EXPECT--
+Prices: 19.99, 29.99, 39.99
+Total: 89.97
diff --git a/Zend/tests/typed_arrays/int_array_param_error.phpt b/Zend/tests/typed_arrays/int_array_param_error.phpt
new file mode 100644
index 00000000..666ed047
--- /dev/null
+++ b/Zend/tests/typed_arrays/int_array_param_error.phpt
@@ -0,0 +1,19 @@
+--TEST--
+Typed array: array<int> parameter type error
+--FILE--
+<?php
+
+
+function sumNumbers(array<int> $nums): int {
+    return array_sum($nums);
+}
+
+try {
+    sumNumbers([1, 2, "three"]);
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: sumNumbers(): Argument #1 ($nums) must be of type array<int>, array element at index 2 is string
diff --git a/Zend/tests/typed_arrays/int_array_type_error.phpt b/Zend/tests/typed_arrays/int_array_type_error.phpt
new file mode 100644
index 00000000..8bcca561
--- /dev/null
+++ b/Zend/tests/typed_arrays/int_array_type_error.phpt
@@ -0,0 +1,19 @@
+--TEST--
+Typed array: array<int> type error when returning wrong type
+--FILE--
+<?php
+
+
+function getNumbers(): array<int> {
+    return [1, 2, "three", 4];
+}
+
+try {
+    getNumbers();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getNumbers(): Return value must be of type array<int>, array element at index 2 is string
diff --git a/Zend/tests/typed_arrays/interface_typed_array.phpt b/Zend/tests/typed_arrays/interface_typed_array.phpt
new file mode 100644
index 00000000..da627feb
--- /dev/null
+++ b/Zend/tests/typed_arrays/interface_typed_array.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Interface: typed array in interface method
+--XLEAK--
+--FILE--
+<?php
+
+
+interface Repository {
+    public function findAll(): array<array{id: int, name: string}>;
+    public function save(array{id: int, name: string} $item): void;
+}
+
+class UserRepository implements Repository {
+    private array<array{id: int, name: string}> $items = [];
+
+    public function findAll(): array<array{id: int, name: string}> {
+        return $this->items;
+    }
+
+    public function save(array{id: int, name: string} $item): void {
+        $this->items[] = $item;
+    }
+}
+
+$repo = new UserRepository();
+$repo->save(['id' => 1, 'name' => 'Alice']);
+$repo->save(['id' => 2, 'name' => 'Bob']);
+
+foreach ($repo->findAll() as $user) {
+    echo "{$user['id']}: {$user['name']}\n";
+}
+
+?>
+--EXPECT--
+1: Alice
+2: Bob
diff --git a/Zend/tests/typed_arrays/keyed_typed_array.phpt b/Zend/tests/typed_arrays/keyed_typed_array.phpt
new file mode 100644
index 00000000..7124765c
--- /dev/null
+++ b/Zend/tests/typed_arrays/keyed_typed_array.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Typed array: array<string, int> with string keys
+--FILE--
+<?php
+
+
+function getCounts(): array<string, int> {
+    return [
+        'apples' => 5,
+        'oranges' => 3,
+        'bananas' => 7
+    ];
+}
+
+$counts = getCounts();
+foreach ($counts as $fruit => $count) {
+    echo "$fruit: $count\n";
+}
+
+?>
+--EXPECT--
+apples: 5
+oranges: 3
+bananas: 7
diff --git a/Zend/tests/typed_arrays/keyed_typed_array_error.phpt b/Zend/tests/typed_arrays/keyed_typed_array_error.phpt
new file mode 100644
index 00000000..e69ac7b4
--- /dev/null
+++ b/Zend/tests/typed_arrays/keyed_typed_array_error.phpt
@@ -0,0 +1,22 @@
+--TEST--
+Typed array: array<string, int> key type error
+--FILE--
+<?php
+
+
+function getCounts(): array<string, int> {
+    return [
+        0 => 5,  // Error: integer key, expected string
+        'oranges' => 3
+    ];
+}
+
+getCounts();
+
+?>
+--EXPECTF--
+Fatal error: Uncaught TypeError: getCounts(): Return value must be of type array<string, ...>, array contains int key in %s:%d
+Stack trace:
+#0 %s(%d): getCounts()
+#1 {main}
+  thrown in %s on line %d
diff --git a/Zend/tests/typed_arrays/method_typed_array.phpt b/Zend/tests/typed_arrays/method_typed_array.phpt
new file mode 100644
index 00000000..9fa46915
--- /dev/null
+++ b/Zend/tests/typed_arrays/method_typed_array.phpt
@@ -0,0 +1,40 @@
+--TEST--
+Typed array: class method with typed array return and parameter
+--XLEAK--
+--FILE--
+<?php
+
+
+class UserRepository {
+    private array<array{id: int, name: string}> $users = [];
+
+    public function add(array{id: int, name: string} $user): void {
+        $this->users[] = $user;
+    }
+
+    public function getAll(): array<array{id: int, name: string}> {
+        return $this->users;
+    }
+
+    public function getIds(): array<int> {
+        return array_column($this->users, 'id');
+    }
+}
+
+$repo = new UserRepository();
+$repo->add(['id' => 1, 'name' => 'Alice']);
+$repo->add(['id' => 2, 'name' => 'Bob']);
+
+echo "Users:\n";
+foreach ($repo->getAll() as $user) {
+    echo "  - {$user['name']}\n";
+}
+
+echo "IDs: " . implode(", ", $repo->getIds()) . "\n";
+
+?>
+--EXPECT--
+Users:
+  - Alice
+  - Bob
+IDs: 1, 2
diff --git a/Zend/tests/typed_arrays/mixed_element_type.phpt b/Zend/tests/typed_arrays/mixed_element_type.phpt
new file mode 100644
index 00000000..1f649d8b
--- /dev/null
+++ b/Zend/tests/typed_arrays/mixed_element_type.phpt
@@ -0,0 +1,21 @@
+--TEST--
+Typed array: array<mixed> accepts any values
+--FILE--
+<?php
+
+
+function processAny(array<mixed> $items): void {
+    foreach ($items as $item) {
+        echo gettype($item) . ": " . (is_scalar($item) ? var_export($item, true) : gettype($item)) . "\n";
+    }
+}
+
+processAny([1, 'hello', true, null, [1, 2, 3]]);
+
+?>
+--EXPECT--
+integer: 1
+string: 'hello'
+boolean: true
+NULL: NULL
+array: array
diff --git a/Zend/tests/typed_arrays/named_args_shape.phpt b/Zend/tests/typed_arrays/named_args_shape.phpt
new file mode 100644
index 00000000..8001b465
--- /dev/null
+++ b/Zend/tests/typed_arrays/named_args_shape.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Edge case: array shape with named arguments
+--XLEAK--
+--FILE--
+<?php
+
+
+function createUser(array{id: int, name: string, active?: bool} $data): void {
+    echo "User: {$data['id']} - {$data['name']}";
+    if (isset($data['active'])) {
+        echo " (active: " . ($data['active'] ? 'yes' : 'no') . ")";
+    }
+    echo "\n";
+}
+
+// Named arguments at call site with array literal
+createUser(data: ['id' => 1, 'name' => 'Alice']);
+createUser(data: ['id' => 2, 'name' => 'Bob', 'active' => true]);
+
+?>
+--EXPECT--
+User: 1 - Alice
+User: 2 - Bob (active: yes)
diff --git a/Zend/tests/typed_arrays/nested_typed_array.phpt b/Zend/tests/typed_arrays/nested_typed_array.phpt
new file mode 100644
index 00000000..9440dfbb
--- /dev/null
+++ b/Zend/tests/typed_arrays/nested_typed_array.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Typed array: nested array<array<int>> functionality
+--FILE--
+<?php
+
+
+function getMatrix(): array<array<int>> {
+    return [
+        [1, 2, 3],
+        [4, 5, 6],
+        [7, 8, 9]
+    ];
+}
+
+$matrix = getMatrix();
+foreach ($matrix as $i => $row) {
+    echo "Row $i: " . implode(", ", $row) . "\n";
+}
+
+?>
+--EXPECT--
+Row 0: 1, 2, 3
+Row 1: 4, 5, 6
+Row 2: 7, 8, 9
diff --git a/Zend/tests/typed_arrays/nullable_typed_array.phpt b/Zend/tests/typed_arrays/nullable_typed_array.phpt
new file mode 100644
index 00000000..e10bc053
--- /dev/null
+++ b/Zend/tests/typed_arrays/nullable_typed_array.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Typed array: nullable array<int>|null
+--FILE--
+<?php
+
+
+function maybeGetNumbers(): ?array<int> {
+    return null;
+}
+
+function maybeGetNumbers2(): ?array<int> {
+    return [1, 2, 3];
+}
+
+var_dump(maybeGetNumbers());
+var_dump(maybeGetNumbers2());
+
+?>
+--EXPECT--
+NULL
+array(3) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(2)
+  [2]=>
+  int(3)
+}
diff --git a/Zend/tests/typed_arrays/object_array.phpt b/Zend/tests/typed_arrays/object_array.phpt
new file mode 100644
index 00000000..8a60b837
--- /dev/null
+++ b/Zend/tests/typed_arrays/object_array.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Typed array: array<ClassName> with objects
+--FILE--
+<?php
+
+
+class User {
+    public function __construct(
+        public int $id,
+        public string $name
+    ) {}
+}
+
+function getUsers(): array<User> {
+    return [
+        new User(1, "Alice"),
+        new User(2, "Bob"),
+    ];
+}
+
+function processUsers(array<User> $users): void {
+    foreach ($users as $user) {
+        echo "User {$user->id}: {$user->name}\n";
+    }
+}
+
+$users = getUsers();
+processUsers($users);
+
+?>
+--EXPECT--
+User 1: Alice
+User 2: Bob
diff --git a/Zend/tests/typed_arrays/object_array_type_error.phpt b/Zend/tests/typed_arrays/object_array_type_error.phpt
new file mode 100644
index 00000000..b6d29218
--- /dev/null
+++ b/Zend/tests/typed_arrays/object_array_type_error.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Typed array: array<ClassName> type error with wrong object type
+--XLEAK--
+--FILE--
+<?php
+
+
+class User {
+    public function __construct(public int $id) {}
+}
+
+class Product {
+    public function __construct(public int $id) {}
+}
+
+function getUsers(): array<User> {
+    return [
+        new User(1),
+        new Product(2),  // Wrong type!
+    ];
+}
+
+try {
+    getUsers();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getUsers(): Return value must be of type array<User>, array element at index 1 is Product
diff --git a/Zend/tests/typed_arrays/opcache_shape_persistence.phpt b/Zend/tests/typed_arrays/opcache_shape_persistence.phpt
new file mode 100644
index 00000000..988211b1
--- /dev/null
+++ b/Zend/tests/typed_arrays/opcache_shape_persistence.phpt
@@ -0,0 +1,60 @@
+--TEST--
+OPcache: shape types persist correctly in cache
+--EXTENSIONS--
+opcache
+--INI--
+opcache.enable=1
+opcache.enable_cli=1
+opcache.jit=off
+--FILE--
+<?php
+
+
+// This test verifies that typed arrays and shapes work correctly
+// when scripts are cached by OPcache
+
+function getUsers(): array<array{id: int, name: string}> {
+    return [
+        ['id' => 1, 'name' => 'Alice'],
+        ['id' => 2, 'name' => 'Bob'],
+    ];
+}
+
+function getNumbers(): array<int> {
+    return [1, 2, 3, 4, 5];
+}
+
+class Config {
+    public array{host: string, port: int} $database = [
+        'host' => 'localhost',
+        'port' => 3306
+    ];
+}
+
+// Test typed arrays
+$numbers = getNumbers();
+echo "Numbers: " . implode(", ", $numbers) . "\n";
+
+// Test array shapes
+$users = getUsers();
+foreach ($users as $user) {
+    echo "User: {$user['name']} (ID: {$user['id']})\n";
+}
+
+// Test property shapes
+$config = new Config();
+echo "Database: {$config->database['host']}:{$config->database['port']}\n";
+
+// Verify opcache is active
+if (function_exists('opcache_get_status')) {
+    $status = opcache_get_status();
+    echo "OPcache enabled: " . ($status['opcache_enabled'] ? 'yes' : 'no') . "\n";
+}
+
+?>
+--EXPECT--
+Numbers: 1, 2, 3, 4, 5
+User: Alice (ID: 1)
+User: Bob (ID: 2)
+Database: localhost:3306
+OPcache enabled: yes
diff --git a/Zend/tests/typed_arrays/promoted_property_typed_array.phpt b/Zend/tests/typed_arrays/promoted_property_typed_array.phpt
new file mode 100644
index 00000000..29a46f21
--- /dev/null
+++ b/Zend/tests/typed_arrays/promoted_property_typed_array.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Constructor promoted property: typed array in promoted property
+--FILE--
+<?php
+
+
+class User {
+    public function __construct(
+        public int $id,
+        public string $name,
+        public array<string> $roles = []
+    ) {}
+
+    public function hasRole(string $role): bool {
+        return in_array($role, $this->roles, true);
+    }
+}
+
+$admin = new User(1, 'Alice', ['admin', 'editor']);
+$guest = new User(2, 'Bob');
+
+echo "{$admin->name} is admin: " . ($admin->hasRole('admin') ? 'yes' : 'no') . "\n";
+echo "{$guest->name} is admin: " . ($guest->hasRole('admin') ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Alice is admin: yes
+Bob is admin: no
diff --git a/Zend/tests/typed_arrays/property_typed_array.phpt b/Zend/tests/typed_arrays/property_typed_array.phpt
new file mode 100644
index 00000000..2ace0391
--- /dev/null
+++ b/Zend/tests/typed_arrays/property_typed_array.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Typed array: property with array<int> type
+--FILE--
+<?php
+
+
+class Counter {
+    public array<int> $counts = [];
+
+    public function add(int $n): void {
+        $this->counts[] = $n;
+    }
+
+    public function getSum(): int {
+        return array_sum($this->counts);
+    }
+}
+
+$c = new Counter();
+$c->add(1);
+$c->add(2);
+$c->add(3);
+echo "Sum: " . $c->getSum() . "\n";
+var_dump($c->counts);
+
+?>
+--EXPECT--
+Sum: 6
+array(3) {
+  [0]=>
+  int(1)
+  [1]=>
+  int(2)
+  [2]=>
+  int(3)
+}
diff --git a/Zend/tests/typed_arrays/readonly_property_typed_array.phpt b/Zend/tests/typed_arrays/readonly_property_typed_array.phpt
new file mode 100644
index 00000000..a58377ec
--- /dev/null
+++ b/Zend/tests/typed_arrays/readonly_property_typed_array.phpt
@@ -0,0 +1,18 @@
+--TEST--
+Readonly property: typed array in readonly property
+--FILE--
+<?php
+
+
+class ImmutableConfig {
+    public function __construct(
+        public readonly array<string> $allowedHosts
+    ) {}
+}
+
+$config = new ImmutableConfig(['localhost', 'example.com']);
+echo "Allowed hosts: " . implode(", ", $config->allowedHosts) . "\n";
+
+?>
+--EXPECT--
+Allowed hosts: localhost, example.com
diff --git a/Zend/tests/typed_arrays/reflection_shape.phpt b/Zend/tests/typed_arrays/reflection_shape.phpt
new file mode 100644
index 00000000..ca13d5df
--- /dev/null
+++ b/Zend/tests/typed_arrays/reflection_shape.phpt
@@ -0,0 +1,21 @@
+--TEST--
+Reflection: ReflectionType for array shapes
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1, 'name' => 'Alice'];
+}
+
+$rf = new ReflectionFunction('getUser');
+$returnType = $rf->getReturnType();
+
+echo "Return type: " . $returnType . "\n";
+echo "Class: " . get_class($returnType) . "\n";
+
+?>
+--EXPECT--
+Return type: array{id: int, name: string}
+Class: ReflectionArrayShapeType
diff --git a/Zend/tests/typed_arrays/reflection_typed_array.phpt b/Zend/tests/typed_arrays/reflection_typed_array.phpt
new file mode 100644
index 00000000..5b7bcd4b
--- /dev/null
+++ b/Zend/tests/typed_arrays/reflection_typed_array.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Reflection: ReflectionType for typed arrays
+--XLEAK--
+--FILE--
+<?php
+
+
+function getNumbers(): array<int> {
+    return [1, 2, 3];
+}
+
+$rf = new ReflectionFunction('getNumbers');
+$returnType = $rf->getReturnType();
+
+echo "Return type: " . $returnType . "\n";
+echo "Class: " . get_class($returnType) . "\n";
+echo "Allows null: " . ($returnType->allowsNull() ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Return type: array<int>
+Class: ReflectionArrayType
+Allows null: no
diff --git a/Zend/tests/typed_arrays/shape_alias.phpt b/Zend/tests/typed_arrays/shape_alias.phpt
new file mode 100644
index 00000000..a6865d85
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_alias.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Shape alias: using shape keyword to define reusable types
+--XLEAK--
+--FILE--
+<?php
+
+
+shape User = array{id: int, name: string, email: string};
+
+function createUser(int $id, string $name, string $email): User {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email
+    ];
+}
+
+function getUsers(): array<User> {
+    return [
+        createUser(1, 'Alice', 'alice@example.com'),
+        createUser(2, 'Bob', 'bob@example.com'),
+    ];
+}
+
+$users = getUsers();
+foreach ($users as $user) {
+    echo "{$user['name']} <{$user['email']}>\n";
+}
+
+?>
+--EXPECT--
+Alice <alice@example.com>
+Bob <bob@example.com>
diff --git a/Zend/tests/typed_arrays/shape_alias_circular_warning.phpt b/Zend/tests/typed_arrays/shape_alias_circular_warning.phpt
new file mode 100644
index 00000000..6a4ba553
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_alias_circular_warning.phpt
@@ -0,0 +1,42 @@
+--TEST--
+Shape alias: circular reference triggers warning
+--XLEAK--
+--FILE--
+<?php
+
+
+// Define shapes that reference each other creating a cycle
+// When validating, this should hit the recursion depth limit
+
+shape Node = array{
+    value: int,
+    next?: Node
+};
+
+function createNode(Node $node): void {
+    echo "Node value: {$node['value']}\n";
+}
+
+// Simple case - no recursion
+createNode(['value' => 1]);
+
+// Nested case - one level deep
+createNode(['value' => 1, 'next' => ['value' => 2]]);
+
+// Deeply nested - tests recursion handling
+$deep = ['value' => 1];
+$current = &$deep;
+for ($i = 2; $i <= 10; $i++) {
+    $current['next'] = ['value' => $i];
+    $current = &$current['next'];
+}
+createNode($deep);
+
+echo "All validations passed\n";
+
+?>
+--EXPECT--
+Node value: 1
+Node value: 1
+Node value: 1
+All validations passed
diff --git a/Zend/tests/typed_arrays/shape_all_optional.phpt b/Zend/tests/typed_arrays/shape_all_optional.phpt
new file mode 100644
index 00000000..4d76fd61
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_all_optional.phpt
@@ -0,0 +1,25 @@
+--TEST--
+Array shape: all optional keys allows empty array
+--XLEAK--
+--FILE--
+<?php
+
+
+function getConfig(): array{timeout?: int, retries?: int, debug?: bool} {
+    return [];
+}
+
+function getPartialConfig(): array{timeout?: int, retries?: int, debug?: bool} {
+    return ['timeout' => 30];
+}
+
+$empty = getConfig();
+$partial = getPartialConfig();
+
+echo "Empty config: " . count($empty) . " keys\n";
+echo "Partial config timeout: " . ($partial['timeout'] ?? 'not set') . "\n";
+
+?>
+--EXPECT--
+Empty config: 0 keys
+Partial config timeout: 30
diff --git a/Zend/tests/typed_arrays/shape_deeply_nested.phpt b/Zend/tests/typed_arrays/shape_deeply_nested.phpt
new file mode 100644
index 00000000..0c4fb297
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_deeply_nested.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Array shape: deeply nested shapes work correctly
+--XLEAK--
+--FILE--
+<?php
+
+
+function getNestedData(): array{
+    level1: array{
+        level2: array{
+            level3: array{
+                value: int
+            }
+        }
+    }
+} {
+    return [
+        'level1' => [
+            'level2' => [
+                'level3' => [
+                    'value' => 42
+                ]
+            ]
+        ]
+    ];
+}
+
+$data = getNestedData();
+echo "Value: " . $data['level1']['level2']['level3']['value'] . "\n";
+
+?>
+--EXPECT--
+Value: 42
diff --git a/Zend/tests/typed_arrays/shape_extra_keys.phpt b/Zend/tests/typed_arrays/shape_extra_keys.phpt
new file mode 100644
index 00000000..43a33c44
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_extra_keys.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Array shape: extra keys beyond shape definition are allowed
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return [
+        'id' => 1,
+        'name' => 'Alice',
+        'email' => 'alice@example.com',  // Extra key, should be allowed
+        'age' => 30                       // Another extra key
+    ];
+}
+
+$user = getUser();
+echo "ID: {$user['id']}\n";
+echo "Name: {$user['name']}\n";
+echo "Email: {$user['email']}\n";
+echo "Age: {$user['age']}\n";
+
+?>
+--EXPECT--
+ID: 1
+Name: Alice
+Email: alice@example.com
+Age: 30
diff --git a/Zend/tests/typed_arrays/shape_extra_keys_allowed.phpt b/Zend/tests/typed_arrays/shape_extra_keys_allowed.phpt
new file mode 100644
index 00000000..987fcb4c
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_extra_keys_allowed.phpt
@@ -0,0 +1,21 @@
+--TEST--
+Array shape: extra keys beyond defined shape are allowed
+--XLEAK--
+--FILE--
+<?php
+
+
+function processUser(array{id: int, name: string} $user): void {
+    echo "Processing: {$user['name']} (ID: {$user['id']})\n";
+    if (isset($user['email'])) {
+        echo "  Email: {$user['email']}\n";
+    }
+}
+
+// Extra 'email' key is allowed - shapes validate required keys exist, not exclusive
+processUser(['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com']);
+
+?>
+--EXPECT--
+Processing: Alice (ID: 1)
+  Email: alice@example.com
diff --git a/Zend/tests/typed_arrays/shape_missing_key_error.phpt b/Zend/tests/typed_arrays/shape_missing_key_error.phpt
new file mode 100644
index 00000000..39b41bbb
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_missing_key_error.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Array shape: error when required key is missing
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return [
+        'id' => 1
+        // 'name' is required but missing
+    ];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getUser(): Return value must be of type array{name: string, ...}, array given with missing key "name"
diff --git a/Zend/tests/typed_arrays/shape_mixed_keys.phpt b/Zend/tests/typed_arrays/shape_mixed_keys.phpt
new file mode 100644
index 00000000..4edff60f
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_mixed_keys.phpt
@@ -0,0 +1,53 @@
+--TEST--
+Array shape: mixed required and optional keys
+--XLEAK--
+--FILE--
+<?php
+
+
+function createUser(
+    array{
+        id: int,
+        name: string,
+        email?: string,
+        age?: int,
+        active: bool
+    } $data
+): void {
+    echo "User: {$data['name']} (ID: {$data['id']})\n";
+    if (isset($data['email'])) {
+        echo "  Email: {$data['email']}\n";
+    }
+    if (isset($data['age'])) {
+        echo "  Age: {$data['age']}\n";
+    }
+    echo "  Active: " . ($data['active'] ? 'yes' : 'no') . "\n";
+}
+
+// All fields
+createUser([
+    'id' => 1,
+    'name' => 'Alice',
+    'email' => 'alice@example.com',
+    'age' => 30,
+    'active' => true
+]);
+
+echo "---\n";
+
+// Only required fields
+createUser([
+    'id' => 2,
+    'name' => 'Bob',
+    'active' => false
+]);
+
+?>
+--EXPECT--
+User: Alice (ID: 1)
+  Email: alice@example.com
+  Age: 30
+  Active: yes
+---
+User: Bob (ID: 2)
+  Active: no
diff --git a/Zend/tests/typed_arrays/shape_numeric_string_key.phpt b/Zend/tests/typed_arrays/shape_numeric_string_key.phpt
new file mode 100644
index 00000000..04dbb679
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_numeric_string_key.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Array shape: keys that could be numeric work correctly
+--XLEAK--
+--FILE--
+<?php
+
+
+// Shape keys must be identifiers, so numeric-looking keys use identifier syntax
+// This tests that keys starting with numbers or containing special chars need different approach
+
+function getCoordinates(): array{x: int, y: int} {
+    return [
+        "x" => 10,
+        "y" => 20
+    ];
+}
+
+$coords = getCoordinates();
+echo "x: " . $coords['x'] . ", y: " . $coords['y'] . "\n";
+
+?>
+--EXPECT--
+x: 10, y: 20
diff --git a/Zend/tests/typed_arrays/shape_optional_key.phpt b/Zend/tests/typed_arrays/shape_optional_key.phpt
new file mode 100644
index 00000000..a010c4e2
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_optional_key.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Array shape: optional keys with key?: type syntax
+--XLEAK--
+--FILE--
+<?php
+
+
+function getConfig(): array{host: string, port: int, ssl?: bool} {
+    return [
+        'host' => 'localhost',
+        'port' => 3306
+        // ssl is optional, not provided
+    ];
+}
+
+function getConfigWithSsl(): array{host: string, port: int, ssl?: bool} {
+    return [
+        'host' => 'localhost',
+        'port' => 3306,
+        'ssl' => true
+    ];
+}
+
+$config1 = getConfig();
+echo "Host: {$config1['host']}, Port: {$config1['port']}\n";
+
+$config2 = getConfigWithSsl();
+echo "Host: {$config2['host']}, Port: {$config2['port']}, SSL: " . ($config2['ssl'] ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Host: localhost, Port: 3306
+Host: localhost, Port: 3306, SSL: yes
diff --git a/Zend/tests/typed_arrays/shape_property_assignment.phpt b/Zend/tests/typed_arrays/shape_property_assignment.phpt
new file mode 100644
index 00000000..77e7e744
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_assignment.phpt
@@ -0,0 +1,30 @@
+--TEST--
+Array shape: property assignment validation
+--XLEAK--
+--FILE--
+<?php
+
+
+class Config {
+    public array{host: string, port: int} $database;
+
+    public function __construct() {
+        $this->database = ['host' => 'localhost', 'port' => 3306];
+    }
+}
+
+$config = new Config();
+echo "Host: {$config->database['host']}\n";
+echo "Port: {$config->database['port']}\n";
+
+// Update with valid data
+$config->database = ['host' => '127.0.0.1', 'port' => 5432];
+echo "Updated host: {$config->database['host']}\n";
+echo "Updated port: {$config->database['port']}\n";
+
+?>
+--EXPECT--
+Host: localhost
+Port: 3306
+Updated host: 127.0.0.1
+Updated port: 5432
diff --git a/Zend/tests/typed_arrays/shape_property_error.phpt b/Zend/tests/typed_arrays/shape_property_error.phpt
new file mode 100644
index 00000000..693f92ab
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_error.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Array shape: function return type error (shapes work for function returns)
+--XLEAK--
+--FILE--
+<?php
+
+
+function getConfig(): array{host: string, port: int} {
+    return ['host' => 'localhost']; // Missing 'port'
+}
+
+try {
+    getConfig();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getConfig(): Return value must be of type array{port: int, ...}, array given with missing key "port"
diff --git a/Zend/tests/typed_arrays/shape_property_missing_key_error.phpt b/Zend/tests/typed_arrays/shape_property_missing_key_error.phpt
new file mode 100644
index 00000000..3713beda
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_missing_key_error.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Array shape: property assignment missing required key error
+--XLEAK--
+--FILE--
+<?php
+
+
+class Config {
+    public array{host: string, port: int} $database;
+}
+
+$config = new Config();
+
+// Valid assignment
+$config->database = ['host' => 'localhost', 'port' => 3306];
+echo "Valid assignment: OK\n";
+
+// Invalid assignment - missing 'port'
+try {
+    $config->database = ['host' => 'localhost'];
+} catch (TypeError $e) {
+    echo "Missing key: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Valid assignment: OK
+Missing key: Cannot assign to property Config::$database of type array{port: int, ...}, array given with missing key "port"
diff --git a/Zend/tests/typed_arrays/shape_property_wrong_type_error.phpt b/Zend/tests/typed_arrays/shape_property_wrong_type_error.phpt
new file mode 100644
index 00000000..d306d9e5
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_property_wrong_type_error.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Array shape: property assignment wrong type error
+--XLEAK--
+--FILE--
+<?php
+
+
+class User {
+    public array{id: int, name: string} $user;
+}
+
+$u = new User();
+
+// Valid assignment
+$u->user = ['id' => 1, 'name' => 'Alice'];
+echo "Valid assignment: OK\n";
+
+// Invalid assignment - wrong type for 'id'
+try {
+    $u->user = ['id' => 'one', 'name' => 'Alice'];
+} catch (TypeError $e) {
+    echo "Wrong type: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Valid assignment: OK
+Wrong type: Cannot assign to property User::$user of type array{id: int, ...}, array key "id" is string
diff --git a/Zend/tests/typed_arrays/shape_recursion_depth_limit.phpt b/Zend/tests/typed_arrays/shape_recursion_depth_limit.phpt
new file mode 100644
index 00000000..f5463d42
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_recursion_depth_limit.phpt
@@ -0,0 +1,46 @@
+--TEST--
+Shape alias: recursion depth limit prevents infinite loops
+--XLEAK--
+--FILE--
+<?php
+
+
+// This test verifies that the recursion depth limit (64) prevents
+// infinite loops when shapes reference themselves
+
+shape RecursiveShape = array{
+    id: int,
+    child?: RecursiveShape
+};
+
+function processShape(RecursiveShape $shape): int {
+    $count = 1;
+    if (isset($shape['child'])) {
+        $count += processShape($shape['child']);
+    }
+    return $count;
+}
+
+// Build a deeply nested structure (but within limits)
+function buildNested(int $depth): array {
+    if ($depth <= 0) {
+        return ['id' => 0];
+    }
+    return ['id' => $depth, 'child' => buildNested($depth - 1)];
+}
+
+// Test with 50 levels (within 64 limit)
+$nested = buildNested(50);
+echo "Depth 50: " . processShape($nested) . " nodes\n";
+
+// Test with 60 levels (still within 64 limit)
+$nested = buildNested(60);
+echo "Depth 60: " . processShape($nested) . " nodes\n";
+
+echo "Recursion limit working correctly\n";
+
+?>
+--EXPECT--
+Depth 50: 51 nodes
+Depth 60: 61 nodes
+Recursion limit working correctly
diff --git a/Zend/tests/typed_arrays/shape_wrong_type_error.phpt b/Zend/tests/typed_arrays/shape_wrong_type_error.phpt
new file mode 100644
index 00000000..62fa8776
--- /dev/null
+++ b/Zend/tests/typed_arrays/shape_wrong_type_error.phpt
@@ -0,0 +1,23 @@
+--TEST--
+Array shape: error when key has wrong type
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUser(): array{id: int, name: string} {
+    return [
+        'id' => "not_an_int",  // Wrong type!
+        'name' => 'Alice'
+    ];
+}
+
+try {
+    getUser();
+} catch (TypeError $e) {
+    echo "Caught: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Caught: getUser(): Return value must be of type array{id: int, ...}, array key "id" is string
diff --git a/Zend/tests/typed_arrays/static_property_typed_array.phpt b/Zend/tests/typed_arrays/static_property_typed_array.phpt
new file mode 100644
index 00000000..ed98138a
--- /dev/null
+++ b/Zend/tests/typed_arrays/static_property_typed_array.phpt
@@ -0,0 +1,33 @@
+--TEST--
+Static property: typed array in static class property
+--FILE--
+<?php
+
+
+class Registry {
+    private static array<string> $items = [];
+
+    public static function add(string $item): void {
+        self::$items[] = $item;
+    }
+
+    public static function getAll(): array<string> {
+        return self::$items;
+    }
+
+    public static function clear(): void {
+        self::$items = [];
+    }
+}
+
+Registry::add("item1");
+Registry::add("item2");
+echo "Items: " . implode(", ", Registry::getAll()) . "\n";
+
+Registry::clear();
+echo "After clear: " . count(Registry::getAll()) . " items\n";
+
+?>
+--EXPECT--
+Items: item1, item2
+After clear: 0 items
diff --git a/Zend/tests/typed_arrays/trait_typed_array.phpt b/Zend/tests/typed_arrays/trait_typed_array.phpt
new file mode 100644
index 00000000..e293847c
--- /dev/null
+++ b/Zend/tests/typed_arrays/trait_typed_array.phpt
@@ -0,0 +1,36 @@
+--TEST--
+Trait: typed array in trait method
+--FILE--
+<?php
+
+
+trait Taggable {
+    private array<string> $tags = [];
+
+    public function addTag(string $tag): void {
+        $this->tags[] = $tag;
+    }
+
+    public function getTags(): array<string> {
+        return $this->tags;
+    }
+}
+
+class Article {
+    use Taggable;
+
+    public function __construct(public string $title) {}
+}
+
+$article = new Article("PHP Typed Arrays");
+$article->addTag("php");
+$article->addTag("types");
+$article->addTag("arrays");
+
+echo "Title: {$article->title}\n";
+echo "Tags: " . implode(", ", $article->getTags()) . "\n";
+
+?>
+--EXPECT--
+Title: PHP Typed Arrays
+Tags: php, types, arrays
diff --git a/Zend/tests/typed_arrays/typed_array_empty.phpt b/Zend/tests/typed_arrays/typed_array_empty.phpt
new file mode 100644
index 00000000..43d97c8e
--- /dev/null
+++ b/Zend/tests/typed_arrays/typed_array_empty.phpt
@@ -0,0 +1,31 @@
+--TEST--
+Typed array: empty array is valid for any typed array
+--XLEAK--
+--FILE--
+<?php
+
+
+function getInts(): array<int> {
+    return [];
+}
+
+function getStrings(): array<string> {
+    return [];
+}
+
+function getUsers(): array<array{id: int, name: string}> {
+    return [];
+}
+
+var_dump(getInts());
+var_dump(getStrings());
+var_dump(getUsers());
+
+?>
+--EXPECT--
+array(0) {
+}
+array(0) {
+}
+array(0) {
+}
diff --git a/Zend/tests/typed_arrays/typed_array_property_error.phpt b/Zend/tests/typed_arrays/typed_array_property_error.phpt
new file mode 100644
index 00000000..89e95e13
--- /dev/null
+++ b/Zend/tests/typed_arrays/typed_array_property_error.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Typed array: property assignment type error
+--XLEAK--
+--FILE--
+<?php
+
+
+class Counter {
+    public array<int> $counts = [];
+}
+
+$c = new Counter();
+
+// Valid assignment
+$c->counts = [1, 2, 3];
+echo "Valid assignment: OK\n";
+
+// Invalid assignment - string in int array
+try {
+    $c->counts = [1, 'two', 3];
+} catch (TypeError $e) {
+    echo "Invalid assignment: " . $e->getMessage() . "\n";
+}
+
+?>
+--EXPECTF--
+Valid assignment: OK
+Invalid assignment: Cannot assign to property Counter::$counts of type array<int>, array element at index 1 is string
diff --git a/Zend/tests/typed_arrays/typed_array_with_shape.phpt b/Zend/tests/typed_arrays/typed_array_with_shape.phpt
new file mode 100644
index 00000000..e06e0ce0
--- /dev/null
+++ b/Zend/tests/typed_arrays/typed_array_with_shape.phpt
@@ -0,0 +1,27 @@
+--TEST--
+Typed array: array<shape> combining typed arrays with shapes
+--XLEAK--
+--FILE--
+<?php
+
+
+function getUsers(): array<array{id: int, name: string}> {
+    return [
+        ['id' => 1, 'name' => 'Alice'],
+        ['id' => 2, 'name' => 'Bob'],
+        ['id' => 3, 'name' => 'Charlie'],
+    ];
+}
+
+$users = getUsers();
+echo "Found " . count($users) . " users:\n";
+foreach ($users as $user) {
+    echo "  - {$user['name']} (ID: {$user['id']})\n";
+}
+
+?>
+--EXPECT--
+Found 3 users:
+  - Alice (ID: 1)
+  - Bob (ID: 2)
+  - Charlie (ID: 3)
diff --git a/Zend/tests/typed_arrays/union_shape.phpt b/Zend/tests/typed_arrays/union_shape.phpt
new file mode 100644
index 00000000..6d093c51
--- /dev/null
+++ b/Zend/tests/typed_arrays/union_shape.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Union types: array shape in union with null
+--XLEAK--
+--FILE--
+<?php
+
+
+function findUser(int $id): array{id: int, name: string}|null {
+    if ($id === 1) {
+        return ['id' => 1, 'name' => 'Alice'];
+    }
+    return null;
+}
+
+$user = findUser(1);
+echo "Found: " . ($user ? $user['name'] : "nobody") . "\n";
+
+$nobody = findUser(999);
+echo "Found: " . ($nobody ? $nobody['name'] : "nobody") . "\n";
+
+?>
+--EXPECT--
+Found: Alice
+Found: nobody
diff --git a/Zend/tests/typed_arrays/union_typed_array.phpt b/Zend/tests/typed_arrays/union_typed_array.phpt
new file mode 100644
index 00000000..6ace0b70
--- /dev/null
+++ b/Zend/tests/typed_arrays/union_typed_array.phpt
@@ -0,0 +1,24 @@
+--TEST--
+Union types: typed array in union with null
+--FILE--
+<?php
+
+
+function getNumbers(): array<int>|null {
+    return [1, 2, 3];
+}
+
+function getNothing(): array<int>|null {
+    return null;
+}
+
+$nums = getNumbers();
+echo "Numbers: " . ($nums ? implode(", ", $nums) : "none") . "\n";
+
+$nothing = getNothing();
+echo "Nothing: " . ($nothing ? implode(", ", $nothing) : "none") . "\n";
+
+?>
+--EXPECT--
+Numbers: 1, 2, 3
+Nothing: none
diff --git a/Zend/tests/typed_arrays/variadic_typed_array.phpt b/Zend/tests/typed_arrays/variadic_typed_array.phpt
new file mode 100644
index 00000000..c4b92afc
--- /dev/null
+++ b/Zend/tests/typed_arrays/variadic_typed_array.phpt
@@ -0,0 +1,20 @@
+--TEST--
+Edge case: variadic parameter with typed array
+--FILE--
+<?php
+
+
+function mergeArrays(array<int> ...$arrays): array<int> {
+    $result = [];
+    foreach ($arrays as $arr) {
+        $result = array_merge($result, $arr);
+    }
+    return $result;
+}
+
+$merged = mergeArrays([1, 2], [3, 4], [5, 6]);
+echo "Merged: " . implode(", ", $merged) . "\n";
+
+?>
+--EXPECT--
+Merged: 1, 2, 3, 4, 5, 6
diff --git a/Zend/tests/typed_arrays/variance_contravariant_param.phpt b/Zend/tests/typed_arrays/variance_contravariant_param.phpt
new file mode 100644
index 00000000..ac677cc4
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_contravariant_param.phpt
@@ -0,0 +1,28 @@
+--TEST--
+Variance: contravariant parameter type - child can accept more general typed array
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+
+class AnimalProcessor {
+    public function process(array<Dog> $dogs): void {
+        echo "Processing " . count($dogs) . " dogs\n";
+    }
+}
+
+class GeneralProcessor extends AnimalProcessor {
+    // Contravariant: array<Animal> is more general than array<Dog>
+    public function process(array<Animal> $animals): void {
+        echo "Processing " . count($animals) . " animals\n";
+    }
+}
+
+$processor = new GeneralProcessor();
+$processor->process([new Dog(), new Dog()]);
+
+?>
+--EXPECT--
+Processing 2 animals
diff --git a/Zend/tests/typed_arrays/variance_covariant_return.phpt b/Zend/tests/typed_arrays/variance_covariant_return.phpt
new file mode 100644
index 00000000..d8e5fbc1
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_covariant_return.phpt
@@ -0,0 +1,32 @@
+--TEST--
+Variance: covariant return type - child can return more specific typed array
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+class Cat extends Animal {}
+
+class AnimalShelter {
+    public function getAnimals(): array<Animal> {
+        return [new Animal(), new Animal()];
+    }
+}
+
+class DogShelter extends AnimalShelter {
+    // Covariant: array<Dog> is more specific than array<Animal>
+    public function getAnimals(): array<Dog> {
+        return [new Dog(), new Dog()];
+    }
+}
+
+$shelter = new DogShelter();
+$dogs = $shelter->getAnimals();
+echo "Got " . count($dogs) . " dogs\n";
+echo "First is Dog: " . ($dogs[0] instanceof Dog ? 'yes' : 'no') . "\n";
+
+?>
+--EXPECT--
+Got 2 dogs
+First is Dog: yes
diff --git a/Zend/tests/typed_arrays/variance_invalid_contravariant.phpt b/Zend/tests/typed_arrays/variance_invalid_contravariant.phpt
new file mode 100644
index 00000000..294ea8a4
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_invalid_contravariant.phpt
@@ -0,0 +1,29 @@
+--TEST--
+Variance: valid contravariant parameter - child can accept more general type
+--XLEAK--
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+
+class DogProcessor {
+    public function process(array<Dog> $dogs): void {
+        echo "Processing dogs\n";
+    }
+}
+
+class AnimalProcessor extends DogProcessor {
+    // Valid: array<Animal> is more general than array<Dog> for parameters
+    public function process(array<Animal> $animals): void {
+        echo "Processing animals\n";
+    }
+}
+
+$processor = new AnimalProcessor();
+$processor->process([new Dog()]);
+
+?>
+--EXPECT--
+Processing animals
diff --git a/Zend/tests/typed_arrays/variance_invalid_covariant.phpt b/Zend/tests/typed_arrays/variance_invalid_covariant.phpt
new file mode 100644
index 00000000..6fbb8d9d
--- /dev/null
+++ b/Zend/tests/typed_arrays/variance_invalid_covariant.phpt
@@ -0,0 +1,30 @@
+--TEST--
+Variance: valid covariant return - child can return more specific type
+--XLEAK--
+--FILE--
+<?php
+
+
+class Animal {}
+class Dog extends Animal {}
+
+class AnimalShelter {
+    public function getAnimals(): array<Animal> {
+        return [new Animal()];
+    }
+}
+
+class DogShelter extends AnimalShelter {
+    // Valid: array<Dog> is more specific than array<Animal> for return types
+    public function getAnimals(): array<Dog> {
+        return [new Dog()];
+    }
+}
+
+$shelter = new DogShelter();
+$dogs = $shelter->getAnimals();
+echo "Got " . count($dogs) . " dogs\n";
+
+?>
+--EXPECT--
+Got 1 dogs
diff --git a/Zend/zend.c b/Zend/zend.c
index 045d2513..7b0e1f1e 100644
--- a/Zend/zend.c
+++ b/Zend/zend.c
@@ -57,17 +57,20 @@ static HashTable *global_function_table = NULL;
 static HashTable *global_class_table = NULL;
 static HashTable *global_constants_table = NULL;
 static HashTable *global_auto_globals_table = NULL;
+static HashTable *global_shape_table = NULL;
 static HashTable *global_persistent_list = NULL;
 TSRMLS_MAIN_CACHE_DEFINE()
 # define GLOBAL_FUNCTION_TABLE		global_function_table
 # define GLOBAL_CLASS_TABLE			global_class_table
 # define GLOBAL_CONSTANTS_TABLE		global_constants_table
 # define GLOBAL_AUTO_GLOBALS_TABLE	global_auto_globals_table
+# define GLOBAL_SHAPE_TABLE			global_shape_table
 #else
 # define GLOBAL_FUNCTION_TABLE		CG(function_table)
 # define GLOBAL_CLASS_TABLE			CG(class_table)
 # define GLOBAL_AUTO_GLOBALS_TABLE	CG(auto_globals)
 # define GLOBAL_CONSTANTS_TABLE		EG(zend_constants)
+# define GLOBAL_SHAPE_TABLE			CG(shape_table)
 #endif
 
 ZEND_API zend_utility_values zend_uv;
@@ -278,6 +281,8 @@ ZEND_INI_BEGIN()
 	/* Subtracted from the max allowed stack size, as a buffer, when checking for overflow. 0: auto detect. */
 	STD_ZEND_INI_ENTRY("zend.reserved_stack_size",	"0",	ZEND_INI_SYSTEM,	OnUpdateReservedStackSize,	reserved_stack_size,		zend_executor_globals,	executor_globals)
 #endif
+	/* Maximum recursion depth for shape/typed array validation. Default 64. */
+	STD_ZEND_INI_ENTRY("zend.shape_max_recursion_depth",	"64",	ZEND_INI_ALL,	OnUpdateLongGEZero,	shape_max_recursion_depth,	zend_executor_globals,	executor_globals)
 
 ZEND_INI_END()
 
@@ -724,6 +729,10 @@ static void compiler_globals_ctor(zend_compiler_globals *compiler_globals) /* {{
 	zend_hash_init(compiler_globals->class_table, 64, NULL, ZEND_CLASS_DTOR, 1);
 	zend_hash_copy(compiler_globals->class_table, global_class_table, zend_class_add_ref);
 
+	compiler_globals->shape_table = (HashTable *) malloc(sizeof(HashTable));
+	zend_hash_init(compiler_globals->shape_table, 32, NULL, zend_shape_dtor, 1);
+	zend_hash_copy(compiler_globals->shape_table, global_shape_table, NULL);
+
 	zend_set_default_compile_time_values();
 
 	compiler_globals->auto_globals = (HashTable *) malloc(sizeof(HashTable));
@@ -781,6 +790,10 @@ static void compiler_globals_dtor(zend_compiler_globals *compiler_globals) /* {{
 		zend_hash_destroy(compiler_globals->auto_globals);
 		free(compiler_globals->auto_globals);
 	}
+	if (compiler_globals->shape_table != GLOBAL_SHAPE_TABLE) {
+		zend_hash_destroy(compiler_globals->shape_table);
+		free(compiler_globals->shape_table);
+	}
 	if (compiler_globals->script_encoding_list) {
 		pefree((char*)compiler_globals->script_encoding_list, 1);
 	}
@@ -914,6 +927,59 @@ static bool php_auto_globals_create_globals(zend_string *name) /* {{{ */
 }
 /* }}} */
 
+static void zend_shape_type_free(zend_type type) /* {{{ */
+{
+	/* Free array shape structure and its elements */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(type);
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			if (shape->elements[i].key) {
+				zend_string_release(shape->elements[i].key);
+			}
+			/* Recursively free element types */
+			zend_shape_type_free(shape->elements[i].type);
+		}
+		/* Free cached expected_keys hash table for closed shapes */
+		if (shape->expected_keys) {
+			zend_hash_destroy(shape->expected_keys);
+			pefree(shape->expected_keys, 1);
+		}
+		pefree(shape, 1);
+	} else if ((type.type_mask & (1u << IS_ARRAY)) && type.ptr != NULL
+			&& !ZEND_TYPE_IS_COMPLEX(type)) {
+		/* Free typed array element structure */
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(type);
+		zend_shape_type_free(elem->element_type);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_shape_type_free(elem->key_type);
+		}
+		pefree(elem, 1);
+	} else if (ZEND_TYPE_HAS_NAME(type)) {
+		/* Free type name if present */
+		zend_string_release(ZEND_TYPE_NAME(type));
+	} else if (ZEND_TYPE_HAS_LIST(type)) {
+		/* Handle type lists (unions) */
+		zend_type *list_type;
+		ZEND_TYPE_LIST_FOREACH(ZEND_TYPE_LIST(type), list_type) {
+			zend_shape_type_free(*list_type);
+		} ZEND_TYPE_LIST_FOREACH_END();
+		pefree(ZEND_TYPE_LIST(type), 1);
+	}
+}
+/* }}} */
+
+static void zend_shape_dtor(zval *zv) /* {{{ */
+{
+	zend_shape_entry *entry = Z_PTR_P(zv);
+	if (entry->name) {
+		zend_string_release(entry->name);
+	}
+	/* Free the type data (allocated with pemalloc) */
+	zend_shape_type_free(entry->type);
+	pefree(entry, 1);
+}
+/* }}} */
+
 void zend_startup(zend_utility_functions *utility_functions) /* {{{ */
 {
 #ifdef ZTS
@@ -1008,11 +1074,13 @@ void zend_startup(zend_utility_functions *utility_functions) /* {{{ */
 	GLOBAL_CLASS_TABLE = (HashTable *) malloc(sizeof(HashTable));
 	GLOBAL_AUTO_GLOBALS_TABLE = (HashTable *) malloc(sizeof(HashTable));
 	GLOBAL_CONSTANTS_TABLE = (HashTable *) malloc(sizeof(HashTable));
+	GLOBAL_SHAPE_TABLE = (HashTable *) malloc(sizeof(HashTable));
 
 	zend_hash_init(GLOBAL_FUNCTION_TABLE, 1024, NULL, ZEND_FUNCTION_DTOR, 1);
 	zend_hash_init(GLOBAL_CLASS_TABLE, 64, NULL, ZEND_CLASS_DTOR, 1);
 	zend_hash_init(GLOBAL_AUTO_GLOBALS_TABLE, 8, NULL, auto_global_dtor, 1);
 	zend_hash_init(GLOBAL_CONSTANTS_TABLE, 128, NULL, ZEND_CONSTANT_DTOR, 1);
+	zend_hash_init(GLOBAL_SHAPE_TABLE, 32, NULL, zend_shape_dtor, 1);
 
 	zend_hash_init(&module_registry, 32, NULL, module_destructor_zval, 1);
 	zend_init_rsrc_list_dtors();
@@ -1029,9 +1097,11 @@ void zend_startup(zend_utility_functions *utility_functions) /* {{{ */
 	compiler_globals->in_compilation = 0;
 	compiler_globals->function_table = (HashTable *) malloc(sizeof(HashTable));
 	compiler_globals->class_table = (HashTable *) malloc(sizeof(HashTable));
+	compiler_globals->shape_table = (HashTable *) malloc(sizeof(HashTable));
 
 	*compiler_globals->function_table = *GLOBAL_FUNCTION_TABLE;
 	*compiler_globals->class_table = *GLOBAL_CLASS_TABLE;
+	*compiler_globals->shape_table = *GLOBAL_SHAPE_TABLE;
 	compiler_globals->auto_globals = GLOBAL_AUTO_GLOBALS_TABLE;
 
 	zend_hash_destroy(executor_globals->zend_constants);
diff --git a/Zend/zend_ast.c b/Zend/zend_ast.c
index 9cb3c7aa..096780e3 100644
--- a/Zend/zend_ast.c
+++ b/Zend/zend_ast.c
@@ -129,6 +129,9 @@ ZEND_API zend_ast * ZEND_FASTCALL zend_ast_create_class_const_or_name(zend_ast *
 	if (zend_string_equals_ci(name_str, ZSTR_KNOWN(ZEND_STR_CLASS))) {
 		zend_string_release(name_str);
 		return zend_ast_create(ZEND_AST_CLASS_NAME, class_name);
+	} else if (zend_string_equals_literal_ci(name_str, "shape")) {
+		zend_string_release(name_str);
+		return zend_ast_create(ZEND_AST_SHAPE_NAME, class_name);
 	} else {
 		return zend_ast_create(ZEND_AST_CLASS_CONST, class_name, name);
 	}
diff --git a/Zend/zend_ast.h b/Zend/zend_ast.h
index 5b60d0df..adf37406 100644
--- a/Zend/zend_ast.h
+++ b/Zend/zend_ast.h
@@ -101,6 +101,7 @@ enum _zend_ast_kind {
 	ZEND_AST_POST_DEC,
 	ZEND_AST_YIELD_FROM,
 	ZEND_AST_CLASS_NAME,
+	ZEND_AST_SHAPE_NAME,
 
 	ZEND_AST_GLOBAL,
 	ZEND_AST_UNSET,
@@ -174,6 +175,7 @@ enum _zend_ast_kind {
 
 	// Pseudo node for initializing enums
 	ZEND_AST_CONST_ENUM_INIT,
+	ZEND_AST_SHAPE_DECL,
 
 	/* 4 child nodes */
 	ZEND_AST_FOR = 4 << ZEND_AST_NUM_CHILDREN_SHIFT,
diff --git a/Zend/zend_builtin_functions.c b/Zend/zend_builtin_functions.c
index 0d8be49a..018f4b20 100644
--- a/Zend/zend_builtin_functions.c
+++ b/Zend/zend_builtin_functions.c
@@ -1196,6 +1196,41 @@ ZEND_FUNCTION(enum_exists)
 	class_exists_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, ZEND_ACC_ENUM, 0);
 }
 
+/* {{{ Checks if the shape type alias exists */
+ZEND_FUNCTION(shape_exists)
+{
+	zend_string *name;
+	bool autoload = true;
+	zend_string *lcname;
+	zend_shape_entry *shape;
+
+	ZEND_PARSE_PARAMETERS_START(1, 2)
+		Z_PARAM_STR(name)
+		Z_PARAM_OPTIONAL
+		Z_PARAM_BOOL(autoload)
+	ZEND_PARSE_PARAMETERS_END();
+
+	if (ZSTR_VAL(name)[0] == '\\') {
+		/* Ignore leading "\" */
+		lcname = zend_string_alloc(ZSTR_LEN(name) - 1, 0);
+		zend_str_tolower_copy(ZSTR_VAL(lcname), ZSTR_VAL(name) + 1, ZSTR_LEN(name) - 1);
+	} else {
+		lcname = zend_string_tolower(name);
+	}
+
+	if (!autoload) {
+		/* Check the shape table without autoloading */
+		shape = zend_hash_find_ptr(EG(shape_table), lcname);
+	} else {
+		/* Use zend_lookup_shape which supports autoloading */
+		shape = zend_lookup_shape_ex(name, lcname, 0);
+	}
+
+	zend_string_release_ex(lcname, 0);
+	RETURN_BOOL(shape != NULL);
+}
+/* }}} */
+
 /* {{{ Checks if the function exists */
 ZEND_FUNCTION(function_exists)
 {
diff --git a/Zend/zend_builtin_functions.stub.php b/Zend/zend_builtin_functions.stub.php
index 9b2267b5..ea63774f 100644
--- a/Zend/zend_builtin_functions.stub.php
+++ b/Zend/zend_builtin_functions.stub.php
@@ -94,6 +94,8 @@ function trait_exists(string $trait, bool $autoload = true): bool {}
 
 function enum_exists(string $enum, bool $autoload = true): bool {}
 
+function shape_exists(string $shape, bool $autoload = true): bool {}
+
 function function_exists(string $function): bool {}
 
 function class_alias(string $class, string $alias, bool $autoload = true): bool {}
diff --git a/Zend/zend_builtin_functions_arginfo.h b/Zend/zend_builtin_functions_arginfo.h
index cf349b55..b7fcf746 100644
Binary files a/Zend/zend_builtin_functions_arginfo.h and b/Zend/zend_builtin_functions_arginfo.h differ
diff --git a/Zend/zend_compile.c b/Zend/zend_compile.c
index ca9d1f24..ca1232b7 100644
--- a/Zend/zend_compile.c
+++ b/Zend/zend_compile.c
@@ -38,6 +38,7 @@
 #include "zend_call_stack.h"
 #include "zend_frameless_function.h"
 #include "zend_property_hooks.h"
+#include "zend_smart_str.h"
 
 #define SET_NODE(target, src) do { \
 		target ## _type = (src)->op_type; \
@@ -403,6 +404,7 @@ void zend_file_context_begin(zend_file_context *prev_context) /* {{{ */
 	FC(imports) = NULL;
 	FC(imports_function) = NULL;
 	FC(imports_const) = NULL;
+	FC(shapes) = NULL;
 	FC(current_namespace) = NULL;
 	FC(in_namespace) = 0;
 	FC(has_bracketed_namespaces) = 0;
@@ -415,6 +417,11 @@ void zend_file_context_end(zend_file_context *prev_context) /* {{{ */
 {
 	zend_end_namespace();
 	zend_hash_destroy(&FC(seen_symbols));
+	if (FC(shapes)) {
+		zend_hash_destroy(FC(shapes));
+		efree(FC(shapes));
+		FC(shapes) = NULL;
+	}
 	CG(file_context) = *prev_context;
 }
 /* }}} */
@@ -1478,7 +1485,54 @@ zend_string *zend_type_to_string_resolved(const zend_type type, zend_class_entry
 		str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_OBJECT), /* is_intersection */ false);
 	}
 	if (type_mask & MAY_BE_ARRAY) {
-		str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_ARRAY), /* is_intersection */ false);
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(type)) {
+			zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(type);
+			zend_string *elem_str = zend_type_to_string(elem->element_type);
+			if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem)) {
+				zend_string *key_str = zend_type_to_string(elem->key_type);
+				zend_string *array_str = zend_string_concat3(
+					"array<", 6, ZSTR_VAL(key_str), ZSTR_LEN(key_str), ", ", 2);
+				zend_string *full_str = zend_string_concat3(
+					ZSTR_VAL(array_str), ZSTR_LEN(array_str),
+					ZSTR_VAL(elem_str), ZSTR_LEN(elem_str), ">", 1);
+				zend_string_release(key_str);
+				zend_string_release(array_str);
+				zend_string_release(elem_str);
+				str = add_type_string(str, full_str, /* is_intersection */ false);
+				zend_string_release(full_str);
+			} else {
+				zend_string *array_str = zend_string_concat3(
+					"array<", 6, ZSTR_VAL(elem_str), ZSTR_LEN(elem_str), ">", 1);
+				zend_string_release(elem_str);
+				str = add_type_string(str, array_str, /* is_intersection */ false);
+				zend_string_release(array_str);
+			}
+		} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(type);
+			smart_str buf = {0};
+			smart_str_appends(&buf, "array{");
+			for (uint32_t i = 0; i < shape->num_elements; i++) {
+				if (i > 0) {
+					smart_str_appends(&buf, ", ");
+				}
+				zend_array_shape_element *elem = &shape->elements[i];
+				smart_str_append(&buf, elem->key);
+				if (elem->is_optional) {
+					smart_str_appendc(&buf, '?');
+				}
+				smart_str_appends(&buf, ": ");
+				zend_string *elem_type_str = zend_type_to_string(elem->type);
+				smart_str_append(&buf, elem_type_str);
+				zend_string_release(elem_type_str);
+			}
+			smart_str_appendc(&buf, '}');
+			if (shape->is_closed) {
+				smart_str_appendc(&buf, '!');
+			}
+			str = add_type_string(str, smart_str_extract(&buf), /* is_intersection */ false);
+		} else {
+			str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_ARRAY), /* is_intersection */ false);
+		}
 	}
 	if (type_mask & MAY_BE_STRING) {
 		str = add_type_string(str, ZSTR_KNOWN(ZEND_STR_STRING), /* is_intersection */ false);
@@ -2755,8 +2809,12 @@ static void zend_emit_return_type_check(
 			if (Z_TYPE(expr->u.constant) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(type)) {
 				const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(type);
 				if (elem_type) {
-					/* Try to verify at compile time (works for primitive types and unions of primitives) */
-					if (zend_const_array_elements_match_type(&expr->u.constant, &elem_type->element_type)) {
+					/* If there's a key type constraint, we can't skip runtime check
+					 * (compile-time key type validation would need additional implementation) */
+					if (ZEND_TYPED_ARRAY_HAS_KEY_TYPE(elem_type)) {
+						/* Fall through to emit runtime check */
+					} else if (zend_const_array_elements_match_type(&expr->u.constant, &elem_type->element_type)) {
+						/* Try to verify at compile time (works for primitive types and unions of primitives) */
 						return; /* All elements match - no runtime check needed */
 					}
 				}
@@ -7236,14 +7294,23 @@ static zend_type zend_compile_single_typename(zend_ast *ast)
 		type.ptr = elem_type;
 		return type;
 	} else if (ast->kind == ZEND_AST_TYPE_ARRAY_SHAPE) {
-		/* array{key: type, ...} */
+		/* array{key: type, ...} or array{key: type, ...}! (closed) */
 		zend_ast *element_list = ast->child[0];
 		uint32_t num_elements = element_list ? zend_ast_get_list(element_list)->children : 0;
 		uint32_t num_required = 0;
+		bool is_closed = (ast->attr != 0);
+
+		/* Validate element count to prevent excessive memory allocation */
+		if (UNEXPECTED(num_elements > ZEND_SHAPE_MAX_ELEMENTS)) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Array shape cannot have more than %d elements", ZEND_SHAPE_MAX_ELEMENTS);
+		}
 
 		size_t shape_size = sizeof(zend_array_shape) + num_elements * sizeof(zend_array_shape_element);
 		zend_array_shape *shape = zend_arena_alloc(&CG(arena), shape_size);
 		shape->num_elements = num_elements;
+		shape->is_closed = is_closed;
+		shape->expected_keys = NULL;  /* Will be built during persistence for closed shapes */
 
 		if (element_list) {
 			zend_ast_list *list = zend_ast_get_list(element_list);
@@ -7251,7 +7318,7 @@ static zend_type zend_compile_single_typename(zend_ast *ast)
 				zend_ast *elem_ast = list->child[i];
 				zend_ast *key_ast = elem_ast->child[0];
 				zend_ast *type_ast = elem_ast->child[1];
-				bool is_optional = (elem_ast->attr != 0);
+				bool is_optional = (elem_ast->attr & ZEND_SHAPE_ELEM_OPTIONAL_FLAG) != 0;
 
 				shape->elements[i].key = zend_string_copy(zend_ast_get_str(key_ast));
 				shape->elements[i].type = zend_compile_typename(type_ast);
@@ -7288,7 +7355,35 @@ static zend_type zend_compile_single_typename(zend_ast *ast)
 			}
 
 			return (zend_type) ZEND_TYPE_INIT_CODE(type_code, 0, 0);
-		} else {
+		}
+
+		/* Check if this is a shape type alias */
+		{
+			zend_string *resolved_name = zend_resolve_class_name_ast(ast);
+			zend_string *lcname = zend_string_tolower(resolved_name);
+			zend_shape_entry *shape = NULL;
+
+			/* First check file-local shapes */
+			if (FC(shapes)) {
+				shape = zend_hash_find_ptr(FC(shapes), lcname);
+			}
+			/* Then check global shape table */
+			if (!shape && CG(shape_table)) {
+				shape = zend_hash_find_ptr(CG(shape_table), lcname);
+			}
+
+			zend_string_release(lcname);
+			zend_string_release(resolved_name);
+
+			if (shape) {
+				return shape->type;
+			}
+			/* If not found, fall through to class handling.
+			 * The class type checking at runtime will check for shapes
+			 * before triggering class autoloading. */
+		}
+
+		{
 			const char *correct_name;
 			uint32_t fetch_type = zend_get_class_fetch_type_ast(ast);
 			zend_string *class_name = type_name;
@@ -9504,6 +9599,21 @@ static void zend_compile_class_decl(znode *result, zend_ast *ast, bool toplevel)
 	if (extends_ast) {
 		ce->parent_name =
 			zend_resolve_const_class_name_reference(extends_ast, "class name");
+
+		/* Check that parent is not a shape - classes cannot extend shapes */
+		zend_string *parent_lcname = zend_string_tolower(ce->parent_name);
+		zend_shape_entry *parent_shape = NULL;
+		if (FC(shapes)) {
+			parent_shape = zend_hash_find_ptr(FC(shapes), parent_lcname);
+		}
+		if (!parent_shape && CG(shape_table)) {
+			parent_shape = zend_hash_find_ptr(CG(shape_table), parent_lcname);
+		}
+		zend_string_release(parent_lcname);
+		if (parent_shape) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Class %s cannot extend shape %s", ZSTR_VAL(name), ZSTR_VAL(ce->parent_name));
+		}
 	}
 
 	CG(active_class_entry) = ce;
@@ -9918,6 +10028,412 @@ static void zend_compile_const_decl(zend_ast *ast) /* {{{ */
 }
 /* }}}*/
 
+/* Persist a shape key string using interning when possible.
+ * Tries to find an existing interned string for common keys like "id", "name", etc.
+ * This saves memory and enables fast pointer comparison. */
+static zend_string *zend_persist_shape_key(zend_string *key) /* {{{ */
+{
+	zend_string *interned = zend_string_init_existing_interned(
+		ZSTR_VAL(key), ZSTR_LEN(key), 1);
+	if (interned) {
+		return interned;
+	}
+	/* No existing interned string - create persistent copy */
+	return zend_string_dup(key, 1);
+}
+/* }}} */
+
+/* Copy type data to persistent memory for shape storage.
+ * This is needed because zend_compile_typename uses arena allocation,
+ * but shapes are stored in a persistent table that survives across requests. */
+static zend_type zend_persist_shape_type(zend_type type) /* {{{ */
+{
+	zend_type result = type;
+
+	/* Early return for unset types */
+	if (!ZEND_TYPE_IS_SET(type)) {
+		return result;
+	}
+
+	/* Handle array shape: copy structure to persistent memory */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(type) && type.ptr != NULL) {
+		zend_array_shape *arena_shape = ZEND_ARRAY_SHAPE(type);
+		size_t shape_size = sizeof(zend_array_shape)
+			+ arena_shape->num_elements * sizeof(zend_array_shape_element);
+
+		zend_array_shape *persistent_shape = pemalloc(shape_size, 1);
+		memcpy(persistent_shape, arena_shape, shape_size);
+
+		/* Persist each element's key and type */
+		for (uint32_t i = 0; i < persistent_shape->num_elements; i++) {
+			if (persistent_shape->elements[i].key) {
+				persistent_shape->elements[i].key =
+					zend_persist_shape_key(persistent_shape->elements[i].key);
+			}
+			persistent_shape->elements[i].type =
+				zend_persist_shape_type(persistent_shape->elements[i].type);
+		}
+
+		/* Build cached hash table of expected keys for closed shapes */
+		if (persistent_shape->is_closed && persistent_shape->num_elements > 0) {
+			persistent_shape->expected_keys = pemalloc(sizeof(HashTable), 1);
+			zend_hash_init(persistent_shape->expected_keys, persistent_shape->num_elements, NULL, NULL, 1);
+			for (uint32_t i = 0; i < persistent_shape->num_elements; i++) {
+				zend_hash_add_empty_element(persistent_shape->expected_keys, persistent_shape->elements[i].key);
+			}
+		} else {
+			persistent_shape->expected_keys = NULL;
+		}
+
+		result.ptr = persistent_shape;
+		return result;
+	}
+
+	/* Handle typed array: copy element structure to persistent memory */
+	if ((type.type_mask & (1u << IS_ARRAY)) && type.ptr != NULL
+			&& !ZEND_TYPE_IS_COMPLEX(type)) {
+		zend_typed_array_element *arena_elem = ZEND_TYPED_ARRAY_ELEMENT(type);
+		zend_typed_array_element *persistent_elem = pemalloc(sizeof(zend_typed_array_element), 1);
+
+		persistent_elem->element_type = zend_persist_shape_type(arena_elem->element_type);
+		if (ZEND_TYPE_IS_SET(arena_elem->key_type)) {
+			persistent_elem->key_type = zend_persist_shape_type(arena_elem->key_type);
+		} else {
+			persistent_elem->key_type = arena_elem->key_type;
+		}
+
+		result.ptr = persistent_elem;
+		return result;
+	}
+
+	/* Handle class/type name: copy to persistent memory */
+	if (ZEND_TYPE_HAS_NAME(type) && type.ptr != NULL) {
+		/* Use dup with persistent=1 since arena strings will be freed */
+		zend_string *persistent_name = zend_string_dup(ZEND_TYPE_NAME(type), 1);
+		ZEND_TYPE_SET_PTR(result, persistent_name);
+		return result;
+	}
+
+	/* Handle type lists (unions): copy list to persistent memory */
+	if (ZEND_TYPE_HAS_LIST(type) && type.ptr != NULL) {
+		zend_type_list *arena_list = ZEND_TYPE_LIST(type);
+		size_t list_size = ZEND_TYPE_LIST_SIZE(arena_list->num_types);
+		zend_type_list *persistent_list = pemalloc(list_size, 1);
+
+		persistent_list->num_types = arena_list->num_types;
+		for (uint32_t i = 0; i < arena_list->num_types; i++) {
+			persistent_list->types[i] = zend_persist_shape_type(arena_list->types[i]);
+		}
+
+		ZEND_TYPE_SET_LIST(result, persistent_list);
+		/* Clear arena bit since we're using malloc now */
+		result.type_mask &= ~_ZEND_TYPE_ARENA_BIT;
+		return result;
+	}
+
+	/* Simple type (int, string, etc.) - no allocation needed */
+	return result;
+}
+/* }}} */
+
+/* Helper function to deep copy a zend_type for persistent storage in shape inheritance */
+static zend_type zend_shape_type_deep_copy(zend_type type) /* {{{ */
+{
+	zend_type result = type;
+
+	if (ZEND_TYPE_HAS_LIST(type)) {
+		/* Copy type list (unions/intersections) */
+		zend_type_list *old_list = ZEND_TYPE_LIST(type);
+		size_t list_size = ZEND_TYPE_LIST_SIZE(old_list->num_types);
+		zend_type_list *new_list = pemalloc(list_size, 1);
+		memcpy(new_list, old_list, list_size);
+
+		/* Update references in copied list elements */
+		for (uint32_t i = 0; i < old_list->num_types; i++) {
+			new_list->types[i] = zend_shape_type_deep_copy(old_list->types[i]);
+		}
+
+		ZEND_TYPE_SET_PTR(result, new_list);
+	} else if (ZEND_TYPE_HAS_NAME(type)) {
+		/* Copy and reference the string */
+		zend_string *name = ZEND_TYPE_NAME(type);
+		ZEND_TYPE_SET_PTR(result, zend_string_dup(name, 1));
+	} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(type)) {
+		/* Deep copy nested array shape */
+		zend_array_shape *old_shape = ZEND_ARRAY_SHAPE(type);
+		size_t shape_size = sizeof(zend_array_shape) + old_shape->num_elements * sizeof(zend_array_shape_element);
+		zend_array_shape *new_shape = pemalloc(shape_size, 1);
+		memcpy(new_shape, old_shape, sizeof(zend_array_shape));
+
+		for (uint32_t i = 0; i < old_shape->num_elements; i++) {
+			new_shape->elements[i].key = zend_string_dup(old_shape->elements[i].key, 1);
+			new_shape->elements[i].type = zend_shape_type_deep_copy(old_shape->elements[i].type);
+			new_shape->elements[i].is_optional = old_shape->elements[i].is_optional;
+		}
+
+		ZEND_TYPE_SET_PTR(result, new_shape);
+	}
+	/* Simple types (int, string, etc.) have no pointers, so shallow copy is fine */
+
+	return result;
+}
+/* }}} */
+
+/* Check if child type is a valid override for parent type (covariance for shape elements).
+ * Returns true if valid, false if the override would violate type safety.
+ * For simple types: child must be a subset of parent (can narrow, cannot widen).
+ * For complex types: we allow the override (could be enhanced with full type checking). */
+static bool zend_shape_type_is_covariant(zend_type child_type, zend_type parent_type) /* {{{ */
+{
+	/* If parent is not set, any child type is valid */
+	if (!ZEND_TYPE_IS_SET(parent_type)) {
+		return true;
+	}
+
+	/* If child is not set but parent is, that's invalid */
+	if (!ZEND_TYPE_IS_SET(child_type)) {
+		return false;
+	}
+
+	/* For simple type masks: child type mask must be a subset of parent */
+	uint32_t child_mask = ZEND_TYPE_PURE_MASK(child_type);
+	uint32_t parent_mask = ZEND_TYPE_PURE_MASK(parent_type);
+
+	/* Child cannot add types that parent doesn't have */
+	uint32_t added_types = child_mask & ~parent_mask;
+	if (added_types != 0) {
+		/* Exception: if parent allows 'mixed', child can be anything */
+		if (parent_mask == MAY_BE_ANY) {
+			return true;
+		}
+		return false;
+	}
+
+	/* For complex types (classes, shapes), we'd need more sophisticated checking.
+	 * For now, allow if the type masks are compatible. */
+	return true;
+}
+/* }}} */
+
+/* Helper function to merge parent shape elements into child shape */
+static zend_type zend_merge_shape_types(zend_type parent_type, zend_type child_type, zend_string *shape_name) /* {{{ */
+{
+	/* Both must be array shapes */
+	if (!ZEND_TYPE_HAS_ARRAY_SHAPE(parent_type) || !ZEND_TYPE_HAS_ARRAY_SHAPE(child_type)) {
+		return child_type;  /* If either is not a shape, just return child */
+	}
+
+	zend_array_shape *parent_shape = ZEND_ARRAY_SHAPE(parent_type);
+	zend_array_shape *child_shape = ZEND_ARRAY_SHAPE(child_type);
+
+	/* Build hash table of parent keys -> index for O(1) lookup instead of O(n) nested loops.
+	 * This optimizes inheritance merging from O(n*m) to O(n+m). */
+	HashTable parent_key_index;
+	zend_hash_init(&parent_key_index, parent_shape->num_elements, NULL, NULL, 0);
+	for (uint32_t i = 0; i < parent_shape->num_elements; i++) {
+		zend_hash_add_ptr(&parent_key_index, parent_shape->elements[i].key, (void *)(uintptr_t)i);
+	}
+
+	/* Build hash table of child keys -> index */
+	HashTable child_key_index;
+	zend_hash_init(&child_key_index, child_shape->num_elements, NULL, NULL, 0);
+	for (uint32_t i = 0; i < child_shape->num_elements; i++) {
+		zend_hash_add_ptr(&child_key_index, child_shape->elements[i].key, (void *)(uintptr_t)i);
+	}
+
+	/* First pass: validate overrides before allocating merged shape */
+	for (uint32_t i = 0; i < child_shape->num_elements; i++) {
+		void *parent_idx_ptr = zend_hash_find_ptr(&parent_key_index, child_shape->elements[i].key);
+		if (parent_idx_ptr != NULL) {
+			uint32_t j = (uint32_t)(uintptr_t)parent_idx_ptr;
+			/* Child is overriding parent element - validate */
+
+			/* Rule 1: Cannot make required property optional */
+			if (!parent_shape->elements[j].is_optional && child_shape->elements[i].is_optional) {
+				zend_hash_destroy(&parent_key_index);
+				zend_hash_destroy(&child_key_index);
+				zend_error_noreturn(E_COMPILE_ERROR,
+					"Shape %s cannot make required property '%s' optional (inherited as required from parent)",
+					ZSTR_VAL(shape_name), ZSTR_VAL(child_shape->elements[i].key));
+			}
+
+			/* Rule 2: Child type must be covariant (subset of parent type) */
+			if (!zend_shape_type_is_covariant(child_shape->elements[i].type, parent_shape->elements[j].type)) {
+				zend_string *parent_type_str = zend_type_to_string(parent_shape->elements[j].type);
+				zend_string *child_type_str = zend_type_to_string(child_shape->elements[i].type);
+				zend_hash_destroy(&parent_key_index);
+				zend_hash_destroy(&child_key_index);
+				zend_error_noreturn(E_COMPILE_ERROR,
+					"Shape %s property '%s' type %s is not compatible with parent type %s",
+					ZSTR_VAL(shape_name), ZSTR_VAL(child_shape->elements[i].key),
+					ZSTR_VAL(child_type_str), ZSTR_VAL(parent_type_str));
+			}
+		}
+	}
+
+	/* Calculate total elements: parent elements + new child elements (not overriding) */
+	uint32_t child_new_elements = 0;
+	for (uint32_t i = 0; i < child_shape->num_elements; i++) {
+		if (!zend_hash_exists(&parent_key_index, child_shape->elements[i].key)) {
+			child_new_elements++;
+		}
+	}
+	uint32_t total_elements = parent_shape->num_elements + child_new_elements;
+
+	/* Allocate merged shape */
+	size_t shape_size = sizeof(zend_array_shape) + total_elements * sizeof(zend_array_shape_element);
+	zend_array_shape *merged_shape = pemalloc(shape_size, 1);
+	merged_shape->num_elements = total_elements;
+	merged_shape->is_closed = child_shape->is_closed;
+
+	uint32_t merged_idx = 0;
+	uint32_t num_required = 0;
+
+	/* First, copy parent elements (can be overridden by child) */
+	for (uint32_t i = 0; i < parent_shape->num_elements; i++) {
+		void *child_idx_ptr = zend_hash_find_ptr(&child_key_index, parent_shape->elements[i].key);
+		if (child_idx_ptr != NULL) {
+			/* Child overrides - persist child's version */
+			uint32_t j = (uint32_t)(uintptr_t)child_idx_ptr;
+			merged_shape->elements[merged_idx].key = zend_persist_shape_key(child_shape->elements[j].key);
+			merged_shape->elements[merged_idx].type = zend_shape_type_deep_copy(child_shape->elements[j].type);
+			merged_shape->elements[merged_idx].is_optional = child_shape->elements[j].is_optional;
+			if (!child_shape->elements[j].is_optional) {
+				num_required++;
+			}
+		} else {
+			/* Persist parent's version */
+			merged_shape->elements[merged_idx].key = zend_persist_shape_key(parent_shape->elements[i].key);
+			merged_shape->elements[merged_idx].type = zend_shape_type_deep_copy(parent_shape->elements[i].type);
+			merged_shape->elements[merged_idx].is_optional = parent_shape->elements[i].is_optional;
+			if (!parent_shape->elements[i].is_optional) {
+				num_required++;
+			}
+		}
+		merged_idx++;
+	}
+
+	/* Then add child elements that weren't overriding parent */
+	for (uint32_t i = 0; i < child_shape->num_elements; i++) {
+		if (!zend_hash_exists(&parent_key_index, child_shape->elements[i].key)) {
+			merged_shape->elements[merged_idx].key = zend_persist_shape_key(child_shape->elements[i].key);
+			merged_shape->elements[merged_idx].type = zend_shape_type_deep_copy(child_shape->elements[i].type);
+			merged_shape->elements[merged_idx].is_optional = child_shape->elements[i].is_optional;
+			if (!child_shape->elements[i].is_optional) {
+				num_required++;
+			}
+			merged_idx++;
+		}
+	}
+
+	/* Clean up temporary hash tables */
+	zend_hash_destroy(&parent_key_index);
+	zend_hash_destroy(&child_key_index);
+
+	merged_shape->num_required = num_required;
+
+	/* Build cached hash table of expected keys for closed shapes */
+	if (merged_shape->is_closed && merged_shape->num_elements > 0) {
+		merged_shape->expected_keys = pemalloc(sizeof(HashTable), 1);
+		zend_hash_init(merged_shape->expected_keys, merged_shape->num_elements, NULL, NULL, 1);
+		for (uint32_t i = 0; i < merged_shape->num_elements; i++) {
+			zend_hash_add_empty_element(merged_shape->expected_keys, merged_shape->elements[i].key);
+		}
+	} else {
+		merged_shape->expected_keys = NULL;
+	}
+
+	/* Create merged type */
+	zend_type merged_type = (zend_type) ZEND_TYPE_INIT_PTR_MASK(merged_shape, _ZEND_TYPE_ARRAY_SHAPE_BIT | MAY_BE_ARRAY);
+	return merged_type;
+}
+/* }}} */
+
+static void zend_compile_shape_decl(zend_ast *ast) /* {{{ */
+{
+	zend_ast *name_ast = ast->child[0];
+	zend_ast *parent_ast = ast->child[1];
+	zend_ast *type_ast = ast->child[2];
+	zend_string *name = zend_ast_get_str(name_ast);
+	zend_string *lcname;
+
+	/* Prefix with namespace if applicable */
+	name = zend_prefix_with_ns(name);
+	lcname = zend_string_tolower(name);
+
+	/* Check for duplicate shape definition in global table */
+	if (zend_hash_exists(CG(shape_table), lcname)) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"Cannot redeclare shape %s", ZSTR_VAL(name));
+	}
+
+	/* Handle inheritance */
+	zend_type final_type;
+	if (parent_ast) {
+		/* Resolve parent shape name */
+		zend_string *parent_name = zend_resolve_class_name_ast(parent_ast);
+		zend_string *parent_lcname = zend_string_tolower(parent_name);
+
+		/* Check that parent is not a class */
+		zend_class_entry *ce = zend_hash_find_ptr(CG(class_table), parent_lcname);
+		if (ce) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Shape %s cannot extend class %s", ZSTR_VAL(name), ZSTR_VAL(parent_name));
+		}
+
+		/* Look up parent shape - first in file-local, then global */
+		zend_shape_entry *parent_shape = NULL;
+		if (FC(shapes)) {
+			parent_shape = zend_hash_find_ptr(FC(shapes), parent_lcname);
+		}
+		if (!parent_shape && CG(shape_table)) {
+			parent_shape = zend_hash_find_ptr(CG(shape_table), parent_lcname);
+		}
+
+		if (!parent_shape) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Shape %s extends undefined shape %s", ZSTR_VAL(name), ZSTR_VAL(parent_name));
+		}
+
+		/* Check for circular inheritance */
+		if (zend_string_equals_ci(parent_lcname, lcname)) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Shape %s cannot extend itself", ZSTR_VAL(name));
+		}
+
+		zend_string_release(parent_name);
+		zend_string_release(parent_lcname);
+
+		/* Compile child type and merge with parent */
+		zend_type child_type = zend_compile_typename(type_ast);
+		zend_type child_persistent = zend_persist_shape_type(child_type);
+		final_type = zend_merge_shape_types(parent_shape->type, child_persistent, name);
+	} else {
+		/* No inheritance - compile type directly */
+		zend_type arena_type = zend_compile_typename(type_ast);
+		final_type = zend_persist_shape_type(arena_type);
+	}
+
+	/* Create and store the shape entry in global table */
+	zend_shape_entry *entry = pemalloc(sizeof(zend_shape_entry), 1);
+	/* Use dup with persistent=1 since name may be arena-allocated */
+	entry->name = zend_string_dup(name, 1);
+	entry->type = final_type;
+
+	zend_hash_add_ptr(CG(shape_table), lcname, entry);
+
+	/* Also add to file-local shapes for compile-time resolution */
+	if (!FC(shapes)) {
+		ALLOC_HASHTABLE(FC(shapes));
+		zend_hash_init(FC(shapes), ZEND_SHAPE_DEFAULT_HASHTABLE_SIZE, NULL, NULL, 0);  /* No dtor - just references */
+	}
+	zend_hash_add_ptr(FC(shapes), lcname, entry);
+
+	zend_string_release(lcname);
+	zend_string_release(name);
+}
+/* }}} */
+
 static void zend_compile_namespace(zend_ast *ast) /* {{{ */
 {
 	zend_ast *name_ast = ast->child[0];
@@ -11309,6 +11825,47 @@ static void zend_compile_class_name(znode *result, zend_ast *ast) /* {{{ */
 }
 /* }}} */
 
+static void zend_compile_shape_name(znode *result, zend_ast *ast) /* {{{ */
+{
+	zend_ast *shape_ast = ast->child[0];
+
+	if (shape_ast->kind != ZEND_AST_ZVAL) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"::shape requires a constant shape name, dynamic names are not allowed");
+	}
+
+	/* Resolve the shape name */
+	zend_string *shape_name = zend_resolve_class_name_ast(shape_ast);
+	zend_string *lcname = zend_string_tolower(shape_name);
+
+	/* Look up the shape */
+	zend_shape_entry *shape = NULL;
+	if (FC(shapes)) {
+		shape = zend_hash_find_ptr(FC(shapes), lcname);
+	}
+	if (!shape && CG(shape_table)) {
+		shape = zend_hash_find_ptr(CG(shape_table), lcname);
+	}
+
+	/* If not a shape, check if it's a class - if so, error */
+	if (!shape) {
+		zend_class_entry *ce = zend_hash_find_ptr(CG(class_table), lcname);
+		if (ce) {
+			zend_error_noreturn(E_COMPILE_ERROR,
+				"Cannot use ::shape on class %s, use ::class instead", ZSTR_VAL(shape_name));
+		}
+		/* Not found - might be autoloaded at runtime */
+		/* For now, return the resolved name */
+	}
+
+	/* Return the shape name as a string constant */
+	result->op_type = IS_CONST;
+	ZVAL_STR(&result->u.constant, shape_name);
+
+	zend_string_release(lcname);
+}
+/* }}} */
+
 static zend_op *zend_compile_rope_add_ex(zend_op *opline, znode *result, uint32_t num, znode *elem_node) /* {{{ */
 {
 	if (num == 0) {
@@ -11507,7 +12064,7 @@ static bool zend_is_allowed_in_const_expr(zend_ast_kind kind) /* {{{ */
 		|| kind == ZEND_AST_ARRAY || kind == ZEND_AST_ARRAY_ELEM
 		|| kind == ZEND_AST_UNPACK
 		|| kind == ZEND_AST_CONST || kind == ZEND_AST_CLASS_CONST
-		|| kind == ZEND_AST_CLASS_NAME
+		|| kind == ZEND_AST_CLASS_NAME || kind == ZEND_AST_SHAPE_NAME
 		|| kind == ZEND_AST_MAGIC_CONST || kind == ZEND_AST_COALESCE
 		|| kind == ZEND_AST_CONST_ENUM_INIT
 		|| kind == ZEND_AST_NEW || kind == ZEND_AST_ARG_LIST
@@ -11584,6 +12141,34 @@ static void zend_compile_const_expr_class_name(zend_ast **ast_ptr) /* {{{ */
 	}
 }
 
+static void zend_compile_const_expr_shape_name(zend_ast **ast_ptr) /* {{{ */
+{
+	zend_ast *ast = *ast_ptr;
+	zend_ast *shape_ast = ast->child[0];
+	if (shape_ast->kind != ZEND_AST_ZVAL) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"(expression)::shape cannot be used in constant expressions");
+	}
+
+	/* Resolve the shape name and verify it's not a special class keyword */
+	zend_string *shape_name = zend_ast_get_str(shape_ast);
+	uint32_t fetch_type = zend_get_class_fetch_type(shape_name);
+
+	if (fetch_type != ZEND_FETCH_CLASS_DEFAULT) {
+		zend_error_noreturn(E_COMPILE_ERROR,
+			"Cannot use %s::shape - shapes do not have self, parent, or static",
+			ZSTR_VAL(shape_name));
+	}
+
+	/* Resolve to fully qualified name */
+	zend_string *resolved_name = zend_resolve_class_name_ast(shape_ast);
+	zend_string_release(shape_name);
+	zval *zv = zend_ast_get_zval(shape_ast);
+	ZVAL_STR(zv, resolved_name);
+	shape_ast->attr = ZEND_NAME_FQ;
+}
+/* }}} */
+
 static void zend_compile_const_expr_const(zend_ast **ast_ptr) /* {{{ */
 {
 	zend_ast *ast = *ast_ptr;
@@ -11776,6 +12361,9 @@ static void zend_compile_const_expr(zend_ast **ast_ptr, void *context) /* {{{ */
 		case ZEND_AST_CLASS_NAME:
 			zend_compile_const_expr_class_name(ast_ptr);
 			break;
+		case ZEND_AST_SHAPE_NAME:
+			zend_compile_const_expr_shape_name(ast_ptr);
+			break;
 		case ZEND_AST_CONST:
 			zend_compile_const_expr_const(ast_ptr);
 			break;
@@ -11956,6 +12544,9 @@ static void zend_compile_stmt(zend_ast *ast) /* {{{ */
 		case ZEND_AST_CONST_DECL:
 			zend_compile_const_decl(ast);
 			break;
+		case ZEND_AST_SHAPE_DECL:
+			zend_compile_shape_decl(ast);
+			break;
 		case ZEND_AST_NAMESPACE:
 			zend_compile_namespace(ast);
 			break;
@@ -12099,6 +12690,9 @@ static void zend_compile_expr_inner(znode *result, zend_ast *ast) /* {{{ */
 		case ZEND_AST_CLASS_NAME:
 			zend_compile_class_name(result, ast);
 			return;
+		case ZEND_AST_SHAPE_NAME:
+			zend_compile_shape_name(result, ast);
+			return;
 		case ZEND_AST_ENCAPS_LIST:
 			zend_compile_encaps_list(result, ast);
 			return;
@@ -12515,6 +13109,17 @@ static void zend_eval_const_expr(zend_ast **ast_ptr) /* {{{ */
 			}
 			break;
 		}
+		case ZEND_AST_SHAPE_NAME:
+		{
+			/* Shape names are always constant - just resolve the name */
+			zend_ast *shape_ast = ast->child[0];
+			if (shape_ast->kind != ZEND_AST_ZVAL) {
+				return;  /* Dynamic, cannot evaluate at compile time */
+			}
+			zend_string *resolved_name = zend_resolve_class_name_ast(shape_ast);
+			ZVAL_STR(&result, resolved_name);
+			break;
+		}
 		// TODO: We should probably use zend_ast_apply to recursively walk nodes without
 		// special handling. It is required that all nodes that are part of a const expr
 		// are visited. Probably we should be distinguishing evaluation of const expr and
diff --git a/Zend/zend_compile.h b/Zend/zend_compile.h
index 3bb612c8..742c9ead 100644
--- a/Zend/zend_compile.h
+++ b/Zend/zend_compile.h
@@ -125,6 +125,9 @@ typedef struct _zend_typed_array_element {
 	(ZEND_TYPE_IS_ONLY_MASK((elem)->element_type) ? \
 		(uint8_t)ZEND_TYPE_PURE_MASK((elem)->element_type) : 0)
 
+/* Maximum nesting depth for typed array validation (prevents stack overflow) */
+#define ZEND_TYPED_ARRAY_MAX_DEPTH 128
+
 /* Array shape element for array{key: type, key?: type} syntax */
 typedef struct _zend_array_shape_element {
 	zend_string *key;        /* Key name */
@@ -136,6 +139,8 @@ typedef struct _zend_array_shape_element {
 typedef struct _zend_array_shape {
 	uint32_t num_elements;               /* Number of shape elements */
 	uint32_t num_required;               /* Number of required (non-optional) elements */
+	bool is_closed;                      /* If true, no extra keys allowed (array{...}!) */
+	HashTable *expected_keys;            /* Cached hash set of keys for closed shapes (NULL for open shapes) */
 	zend_array_shape_element elements[]; /* Flexible array member */
 } zend_array_shape;
 
@@ -148,6 +153,53 @@ typedef struct _zend_array_shape {
 	((zend_array_shape *) (t).ptr)
 
 /* Compilation context that is different for each file, but shared between op arrays. */
+/* Shape type alias entry */
+typedef struct _zend_shape_entry {
+	zend_string *name;
+	zend_type type;
+} zend_shape_entry;
+
+/* ============================================================================
+ * Typed Array & Array Shape Constants
+ * ============================================================================ */
+
+/* Maximum recursion depth for shape/typed array validation.
+ * Prevents infinite loops in case of circular shape references
+ * (e.g., shape A references shape B which references shape A).
+ * Similar to other PHP recursion limits like MAX_INCLUDE_DEPTH. */
+#define ZEND_SHAPE_MAX_RECURSION_DEPTH 64
+
+/* Maximum number of elements in a single array shape definition.
+ * Prevents excessive memory allocation from malformed AST.
+ * 255 is sufficient for any practical shape definition. */
+#define ZEND_SHAPE_MAX_ELEMENTS 255
+
+/* Default initial size for shape-related hash tables.
+ * Chosen as a power of 2 for efficient hashing, and 8 provides
+ * good balance between memory usage and resize frequency. */
+#define ZEND_SHAPE_DEFAULT_HASHTABLE_SIZE 8
+
+/* AST attribute flag indicating an optional shape element (key?: type).
+ * Used in zend_ast->attr during shape compilation. */
+#define ZEND_SHAPE_ELEM_OPTIONAL_FLAG 1
+
+/* Error result codes for shape validation */
+typedef enum {
+	SHAPE_OK = 0,           /* Validation passed */
+	SHAPE_MISSING_KEY = 1,  /* Required key is missing from array */
+	SHAPE_WRONG_TYPE = 2,   /* Key exists but value has wrong type */
+	SHAPE_EXTRA_KEY = 3     /* Extra key found in closed shape */
+} zend_shape_check_result;
+
+/* Error message format for shape type errors.
+ * Used consistently across return, argument, and property error messages. */
+#define ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY \
+	"array{%s: %s, ...}, array given with missing key \"%s\""
+#define ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE \
+	"array{%s: %s, ...}, array key \"%s\" is %s"
+#define ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY \
+	"closed shape, unexpected extra key \"%s\""
+
 typedef struct _zend_file_context {
 	zend_declarables declarables;
 
@@ -158,6 +210,7 @@ typedef struct _zend_file_context {
 	HashTable *imports;
 	HashTable *imports_function;
 	HashTable *imports_const;
+	HashTable *shapes;  /* shape type aliases (name -> zend_shape_entry) */
 
 	HashTable seen_symbols;
 } zend_file_context;
@@ -762,14 +815,12 @@ ZEND_STATIC_ASSERT(ZEND_MM_ALIGNED_SIZE(sizeof(zval)) == sizeof(zval),
 #define EX_USES_STRICT_TYPES() \
 	ZEND_CALL_USES_STRICT_TYPES(execute_data)
 
-#define ZEND_CALL_USES_STRICT_ARRAYS(call) \
-	(((call)->func->common.fn_flags & ZEND_ACC_STRICT_ARRAYS) != 0)
+/* Typed array checking is always enabled - no declare directive needed */
+#define ZEND_CALL_USES_STRICT_ARRAYS(call) (1)
 
-#define EX_USES_STRICT_ARRAYS() \
-	ZEND_CALL_USES_STRICT_ARRAYS(execute_data)
+#define EX_USES_STRICT_ARRAYS() (1)
 
-#define ZEND_RET_USES_STRICT_ARRAYS() \
-	ZEND_CALL_USES_STRICT_ARRAYS(EG(current_execute_data))
+#define ZEND_RET_USES_STRICT_ARRAYS() (1)
 
 #define ZEND_ARG_USES_STRICT_TYPES() \
 	(EG(current_execute_data)->prev_execute_data && \
diff --git a/Zend/zend_execute.c b/Zend/zend_execute.c
index bd39b79a..34540c7d 100644
--- a/Zend/zend_execute.c
+++ b/Zend/zend_execute.c
@@ -1068,6 +1068,9 @@ ZEND_API bool zend_never_inline zend_verify_property_type(const zend_property_in
 	return i_zend_verify_property_type(info, property, strict);
 }
 
+/* Forward declaration - defined later after zend_check_array_shape */
+ZEND_API bool zend_verify_array_prop_shape(const zend_property_info *info, zval *arr, const zend_array_shape *shape);
+
 static zend_never_inline zval* zend_assign_to_typed_prop(const zend_property_info *info, zval *property_val, zval *value, zend_refcounted **garbage_ptr EXECUTE_DATA_DC)
 {
 	zval tmp;
@@ -1091,12 +1094,20 @@ static zend_never_inline zval* zend_assign_to_typed_prop(const zend_property_inf
 		return &EG(uninitialized_zval);
 	}
 
-	/* Check array element types if strict_arrays is enabled */
-	if (EX_USES_STRICT_ARRAYS() && Z_TYPE(tmp) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(info->type)) {
-		zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(info->type);
-		if (!zend_verify_array_prop_element_types(info, &tmp, elem_type)) {
-			zval_ptr_dtor(&tmp);
-			return &EG(uninitialized_zval);
+	/* Check array element types for typed arrays/shapes */
+	if (Z_TYPE(tmp) == IS_ARRAY) {
+		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(info->type)) {
+			zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(info->type);
+			if (UNEXPECTED(!zend_verify_array_prop_element_types(info, &tmp, elem_type))) {
+				zval_ptr_dtor(&tmp);
+				return &EG(uninitialized_zval);
+			}
+		} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(info->type)) {
+			zend_array_shape *shape = ZEND_ARRAY_SHAPE(info->type);
+			if (UNEXPECTED(!zend_verify_array_prop_shape(info, &tmp, shape))) {
+				zval_ptr_dtor(&tmp);
+				return &EG(uninitialized_zval);
+			}
 		}
 	}
 
@@ -1117,6 +1128,9 @@ static zend_always_inline bool zend_value_instanceof_static(const zval *zv) {
 	return instanceof_function(Z_OBJCE_P(zv), called_scope);
 }
 
+/* Forward declaration - defined after zend_check_array_shape */
+static bool zend_check_shape_type(const zend_type *type, zval *arg, bool is_return_type);
+
 static zend_always_inline zend_class_entry *zend_fetch_ce_from_type(
 		const zend_type *type)
 {
@@ -1162,6 +1176,15 @@ static zend_always_inline bool zend_check_type_slow(
 		const zend_type *type, zval *arg, const zend_reference *ref,
 		bool is_return_type, bool is_internal)
 {
+	/* Check for shape types first (shapes accept arrays, not objects) */
+	if (ZEND_TYPE_IS_COMPLEX(*type) && Z_TYPE_P(arg) == IS_ARRAY) {
+		if (!ZEND_TYPE_HAS_LIST(*type) && ZEND_TYPE_HAS_NAME(*type)) {
+			if (zend_check_shape_type(type, arg, is_return_type)) {
+				return true;
+			}
+		}
+	}
+
 	if (ZEND_TYPE_IS_COMPLEX(*type) && EXPECTED(Z_TYPE_P(arg) == IS_OBJECT)) {
 		zend_class_entry *ce;
 		if (UNEXPECTED(ZEND_TYPE_HAS_LIST(*type))) {
@@ -1524,6 +1547,17 @@ static zend_always_inline bool zend_verify_array_key_types(
 		return true;
 	}
 
+	/* Fast path: check key type cache */
+	if (HT_KEY_TYPE_IS_VALID(ht) && HT_VALIDATED_KEY_TYPE(ht) == (uint8_t)expected_key_mask) {
+		return true;
+	}
+
+	/* Fast path: packed arrays only have integer keys */
+	if (expected_key_mask == MAY_BE_LONG && HT_IS_PACKED(ht)) {
+		HT_SET_VALIDATED_KEY_TYPE(ht, MAY_BE_LONG);
+		return true;
+	}
+
 	bool expects_int = (expected_key_mask == MAY_BE_LONG);
 
 	ZEND_HASH_FOREACH_KEY(ht, num_key, str_key) {
@@ -1537,6 +1571,8 @@ static zend_always_inline bool zend_verify_array_key_types(
 		}
 	} ZEND_HASH_FOREACH_END();
 
+	/* Cache the validated key type */
+	HT_SET_VALIDATED_KEY_TYPE(ht, expected_key_mask);
 	return true;
 }
 
@@ -1562,6 +1598,100 @@ static zend_always_inline const char *zend_find_invalid_key_type(
 	return "unknown";
 }
 
+/*
+ * SIMD-optimized packed array validators for large arrays.
+ *
+ * These use AVX2/SSE2 to check multiple zval type fields in parallel.
+ * The zval struct is 16 bytes with type at offset 8 (u1.type_info).
+ * We use gather operations to collect type bytes, then compare in parallel.
+ *
+ * Minimum array size for SIMD: 16 elements (to amortize setup cost)
+ */
+#ifdef __AVX2__
+#include <immintrin.h>
+
+/* AVX2: Check 8 zvals in parallel using gather */
+static zend_always_inline bool zend_verify_packed_elements_long_avx2(zval *data, uint32_t count)
+{
+	const __m256i expected_type = _mm256_set1_epi32(IS_LONG);
+	/* Gather indices: offset 8 bytes (type_info) for each of 8 consecutive zvals (16 bytes apart) */
+	const __m256i gather_indices = _mm256_setr_epi32(0, 4, 8, 12, 16, 20, 24, 28);
+
+	/* Process 8 elements at a time */
+	while (count >= 8) {
+		/* Gather type_info from 8 consecutive zvals
+		 * Base pointer is at the type_info field of first zval */
+		uint32_t *type_ptr = &data->u1.type_info;
+		__m256i types = _mm256_i32gather_epi32((const int*)type_ptr, gather_indices, 4);
+
+		/* Mask to extract just the type byte (lower 8 bits) */
+		__m256i type_bytes = _mm256_and_si256(types, _mm256_set1_epi32(0xFF));
+
+		/* Compare with IS_LONG */
+		__m256i cmp = _mm256_cmpeq_epi32(type_bytes, expected_type);
+
+		/* Check if all 8 matched */
+		if (_mm256_movemask_epi8(cmp) != (int)0xFFFFFFFF) {
+			/* At least one didn't match - fall back to scalar for error handling */
+			goto scalar_check;
+		}
+
+		data += 8;
+		count -= 8;
+	}
+
+scalar_check:
+	/* Scalar fallback for remaining elements */
+	while (count > 0) {
+		if (Z_TYPE_P(data) == IS_REFERENCE) {
+			data = Z_REFVAL_P(data);
+		}
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_LONG)) {
+			return false;
+		}
+		data++;
+		count--;
+	}
+	return true;
+}
+
+static zend_always_inline bool zend_verify_packed_elements_string_avx2(zval *data, uint32_t count)
+{
+	const __m256i expected_type = _mm256_set1_epi32(IS_STRING);
+	const __m256i gather_indices = _mm256_setr_epi32(0, 4, 8, 12, 16, 20, 24, 28);
+
+	while (count >= 8) {
+		uint32_t *type_ptr = &data->u1.type_info;
+		__m256i types = _mm256_i32gather_epi32((const int*)type_ptr, gather_indices, 4);
+		__m256i type_bytes = _mm256_and_si256(types, _mm256_set1_epi32(0xFF));
+		__m256i cmp = _mm256_cmpeq_epi32(type_bytes, expected_type);
+
+		if (_mm256_movemask_epi8(cmp) != (int)0xFFFFFFFF) {
+			goto scalar_check;
+		}
+
+		data += 8;
+		count -= 8;
+	}
+
+scalar_check:
+	while (count > 0) {
+		if (Z_TYPE_P(data) == IS_REFERENCE) {
+			data = Z_REFVAL_P(data);
+		}
+		if (UNEXPECTED(Z_TYPE_P(data) != IS_STRING)) {
+			return false;
+		}
+		data++;
+		count--;
+	}
+	return true;
+}
+
+#define ZEND_HAS_SIMD_ARRAY_VALIDATION 1
+#define ZEND_SIMD_MIN_ELEMENTS 16
+#endif /* __AVX2__ */
+
 /* Packed array validator with 4x unrolling and prefetching */
 #define DEFINE_VERIFY_PACKED_ELEMENTS(name, type_check) \
 static zend_always_inline bool name(zval *data, uint32_t count) \
@@ -1617,6 +1747,12 @@ DEFINE_VERIFY_PACKED_ELEMENTS(zend_verify_packed_array_elements_string, IS_STRIN
 static zend_always_inline bool zend_verify_array_elements_long(HashTable *ht)
 {
 	if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+#ifdef ZEND_HAS_SIMD_ARRAY_VALIDATION
+		/* Use SIMD for large arrays */
+		if (ht->nNumOfElements >= ZEND_SIMD_MIN_ELEMENTS) {
+			return zend_verify_packed_elements_long_avx2(ht->arPacked, ht->nNumOfElements);
+		}
+#endif
 		return zend_verify_packed_array_elements_long(ht->arPacked, ht->nNumOfElements);
 	}
 	zval *val;
@@ -1640,6 +1776,12 @@ static zend_always_inline bool zend_verify_array_elements_double(HashTable *ht)
 static zend_always_inline bool zend_verify_array_elements_string(HashTable *ht)
 {
 	if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+#ifdef ZEND_HAS_SIMD_ARRAY_VALIDATION
+		/* Use SIMD for large arrays */
+		if (ht->nNumOfElements >= ZEND_SIMD_MIN_ELEMENTS) {
+			return zend_verify_packed_elements_string_avx2(ht->arPacked, ht->nNumOfElements);
+		}
+#endif
 		return zend_verify_packed_array_elements_string(ht->arPacked, ht->nNumOfElements);
 	}
 	zval *val;
@@ -1660,20 +1802,118 @@ static zend_always_inline bool zend_verify_array_elements_bool(HashTable *ht)
 	return true;
 }
 
+/*
+ * Optimized object array validation with multiple fast paths:
+ *
+ * 1. Exact class match: If object's class == expected class, skip instanceof
+ * 2. Monomorphic arrays: Detect when all objects share same class, use pointer comparison
+ * 3. Polymorphic fallback: Use instanceof_function for inheritance checks
+ *
+ * Most real-world typed arrays are monomorphic (all same concrete class),
+ * so the pointer comparison fast path handles the common case efficiently.
+ */
 static zend_always_inline bool zend_verify_array_elements_object(HashTable *ht, zend_class_entry *ce)
 {
 	zval *val;
+	zend_class_entry *first_ce = NULL;
+	bool is_monomorphic = true;
+
+	/* No class constraint - just check all are objects */
+	if (ce == NULL) {
+		ZEND_HASH_FOREACH_VAL(ht, val) {
+			if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+				val = Z_REFVAL_P(val);
+			}
+			if (UNEXPECTED(Z_TYPE_P(val) != IS_OBJECT)) {
+				return false;
+			}
+		} ZEND_HASH_FOREACH_END();
+		return true;
+	}
+
+	/* First pass: check types and detect monomorphic pattern */
 	ZEND_HASH_FOREACH_VAL(ht, val) {
+		zend_class_entry *obj_ce;
+
 		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
 			val = Z_REFVAL_P(val);
 		}
 		if (UNEXPECTED(Z_TYPE_P(val) != IS_OBJECT)) {
 			return false;
 		}
-		if (ce && UNEXPECTED(!instanceof_function(Z_OBJCE_P(val), ce))) {
+
+		obj_ce = Z_OBJCE_P(val);
+
+		/* Fast path: exact class match (no inheritance check needed) */
+		if (EXPECTED(obj_ce == ce)) {
+			if (first_ce == NULL) {
+				first_ce = obj_ce;
+			}
+			continue;
+		}
+
+		/* Track if array is monomorphic (all same concrete class) */
+		if (first_ce == NULL) {
+			first_ce = obj_ce;
+		} else if (obj_ce != first_ce) {
+			is_monomorphic = false;
+		}
+
+		/* Slow path: check inheritance via instanceof */
+		if (UNEXPECTED(!instanceof_function(obj_ce, ce))) {
 			return false;
 		}
 	} ZEND_HASH_FOREACH_END();
+
+	return true;
+}
+
+/*
+ * Even faster validation for packed object arrays with monomorphic content.
+ * When we know all objects are the same class (common case), we can:
+ * 1. Check first object's class satisfies constraint
+ * 2. Just verify remaining objects are same class (pointer comparison)
+ */
+static zend_always_inline bool zend_verify_packed_array_elements_object_monomorphic(
+	zval *data, uint32_t count, zend_class_entry *ce)
+{
+	if (count == 0) return true;
+
+	/* Check first element */
+	zval *first = data;
+	if (UNEXPECTED(Z_TYPE_P(first) == IS_REFERENCE)) {
+		first = Z_REFVAL_P(first);
+	}
+	if (UNEXPECTED(Z_TYPE_P(first) != IS_OBJECT)) {
+		return false;
+	}
+
+	zend_class_entry *first_ce = Z_OBJCE_P(first);
+
+	/* Verify first element satisfies constraint */
+	if (ce != NULL && first_ce != ce && !instanceof_function(first_ce, ce)) {
+		return false;
+	}
+
+	/* Fast path: compare remaining objects to first (pointer comparison only) */
+	for (uint32_t i = 1; i < count; i++) {
+		zval *val = &data[i];
+		if (UNEXPECTED(Z_TYPE_P(val) == IS_REFERENCE)) {
+			val = Z_REFVAL_P(val);
+		}
+		if (UNEXPECTED(Z_TYPE_P(val) != IS_OBJECT)) {
+			return false;
+		}
+		/* Fast pointer comparison - if same class as first, already validated */
+		if (EXPECTED(Z_OBJCE_P(val) == first_ce)) {
+			continue;
+		}
+		/* Different class - check constraint (polymorphic case) */
+		if (ce != NULL && Z_OBJCE_P(val) != ce && !instanceof_function(Z_OBJCE_P(val), ce)) {
+			return false;
+		}
+	}
+
 	return true;
 }
 
@@ -1759,6 +1999,10 @@ static ZEND_COLD zend_long zend_find_invalid_array_element_union(
 	return -1;
 }
 
+/* Thread-local recursion depth counter for nested array validation.
+ * Protected by zend_try/zend_catch to ensure cleanup on exceptions/bailout. */
+ZEND_TLS int zend_typed_array_recursion_depth = 0;
+
 static zend_always_inline bool zend_verify_array_elements_union(HashTable *ht, const zend_type *element_type)
 {
 	zval *val;
@@ -1780,23 +2024,43 @@ static bool zend_verify_nested_array_type(zval *val, const zend_type *array_type
 		return false;
 	}
 
+	/* Check recursion depth limit. Uses same INI as shape validation. */
+	zend_long max_depth = EG(shape_max_recursion_depth);
+	if (max_depth > 0 && UNEXPECTED(zend_typed_array_recursion_depth >= max_depth)) {
+		zend_error(E_WARNING, "Maximum nested typed array depth of " ZEND_LONG_FMT " exceeded", max_depth);
+		return false;
+	}
+
 	const zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(*array_type);
 	if (!elem_type) {
 		return true;
 	}
 
-	zval *inner_val;
-	ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(val), inner_val) {
-		if (ZEND_TYPE_HAS_ARRAY_ELEMENT(elem_type->element_type)) {
-			if (!zend_verify_nested_array_type(inner_val, &elem_type->element_type)) {
-				return false;
+	/* Track recursion depth with exception-safe cleanup */
+	zend_typed_array_recursion_depth++;
+	bool result = true;
+
+	zend_try {
+		zval *inner_val;
+		ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(val), inner_val) {
+			if (ZEND_TYPE_HAS_ARRAY_ELEMENT(elem_type->element_type)) {
+				if (!zend_verify_nested_array_type(inner_val, &elem_type->element_type)) {
+					result = false;
+					break;
+				}
+			} else if (!zend_check_type(&elem_type->element_type, inner_val, NULL, 0, 0)) {
+				result = false;
+				break;
 			}
-		} else if (!zend_check_type(&elem_type->element_type, inner_val, NULL, 0, 0)) {
-			return false;
-		}
-	} ZEND_HASH_FOREACH_END();
+		} ZEND_HASH_FOREACH_END();
+	} zend_catch {
+		/* Exception/bailout occurred - decrement and re-throw */
+		zend_typed_array_recursion_depth--;
+		zend_bailout();
+	} zend_end_try();
 
-	return true;
+	zend_typed_array_recursion_depth--;
+	return result;
 }
 
 static zend_always_inline uint8_t zend_get_simple_type_code(const zend_type *type)
@@ -1819,6 +2083,35 @@ static zend_always_inline uint8_t zend_get_simple_type_code(const zend_type *typ
 	return 0; /* Complex type */
 }
 
+/*
+ * Thread-local cache for class entry lookups in array<ClassName> validation.
+ * Caches the last looked up class name and its corresponding class entry.
+ * This avoids repeated zend_lookup_class() calls for the same class type.
+ */
+ZEND_TLS zend_string *zend_cached_class_name = NULL;
+ZEND_TLS zend_class_entry *zend_cached_class_entry = NULL;
+
+static zend_always_inline zend_class_entry *zend_lookup_class_cached(zend_string *class_name)
+{
+	/* Check cache first */
+	if (zend_cached_class_name != NULL &&
+		zend_string_equals(class_name, zend_cached_class_name)) {
+		/* Verify the cached class entry is still valid */
+		if (zend_cached_class_entry != NULL) {
+			return zend_cached_class_entry;
+		}
+	}
+
+	/* Cache miss - do the lookup and cache the result */
+	zend_class_entry *ce = zend_lookup_class(class_name);
+
+	/* Update cache (we don't hold a reference, so this is a weak cache) */
+	zend_cached_class_name = class_name;
+	zend_cached_class_entry = ce;
+
+	return ce;
+}
+
 ZEND_API bool zend_verify_array_element_types(
 	const zend_function *zf, zval *arr, const zend_typed_array_element *elem_type)
 {
@@ -1874,9 +2167,15 @@ ZEND_API bool zend_verify_array_element_types(
 			case IS_OBJECT:
 				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
 					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
-					cached_ce = zend_lookup_class(class_name);
+					cached_ce = zend_lookup_class_cached(class_name);
+				}
+				/* Use packed array optimization for monomorphic object arrays */
+				if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+					valid = zend_verify_packed_array_elements_object_monomorphic(
+						ht->arPacked, ht->nNumOfElements, cached_ce);
+				} else {
+					valid = zend_verify_array_elements_object(ht, cached_ce);
 				}
-				valid = zend_verify_array_elements_object(ht, cached_ce);
 				break;
 			default:
 				valid = true;
@@ -1977,9 +2276,15 @@ ZEND_API bool zend_verify_array_arg_element_types(
 			case IS_OBJECT:
 				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
 					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
-					cached_ce = zend_lookup_class(class_name);
+					cached_ce = zend_lookup_class_cached(class_name);
+				}
+				/* Use packed array optimization for monomorphic object arrays */
+				if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+					valid = zend_verify_packed_array_elements_object_monomorphic(
+						ht->arPacked, ht->nNumOfElements, cached_ce);
+				} else {
+					valid = zend_verify_array_elements_object(ht, cached_ce);
 				}
-				valid = zend_verify_array_elements_object(ht, cached_ce);
 				break;
 			default:
 				valid = true;
@@ -2080,9 +2385,15 @@ ZEND_API bool zend_verify_array_prop_element_types(
 			case IS_OBJECT:
 				if (ZEND_TYPE_HAS_NAME(elem_type->element_type)) {
 					zend_string *class_name = ZEND_TYPE_NAME(elem_type->element_type);
-					cached_ce = zend_lookup_class(class_name);
+					cached_ce = zend_lookup_class_cached(class_name);
+				}
+				/* Use packed array optimization for monomorphic object arrays */
+				if (HT_IS_PACKED(ht) && HT_IS_WITHOUT_HOLES(ht)) {
+					valid = zend_verify_packed_array_elements_object_monomorphic(
+						ht->arPacked, ht->nNumOfElements, cached_ce);
+				} else {
+					valid = zend_verify_array_elements_object(ht, cached_ce);
 				}
-				valid = zend_verify_array_elements_object(ht, cached_ce);
 				break;
 			default:
 				valid = true;
@@ -2128,21 +2439,18 @@ ZEND_API bool zend_verify_array_prop_element_types(
 	return false;
 }
 
-typedef enum {
-	SHAPE_OK,
-	SHAPE_MISSING_KEY,
-	SHAPE_WRONG_TYPE
-} zend_shape_check_result;
+/* zend_shape_check_result enum is defined in zend_compile.h */
 
 static zend_always_inline zend_shape_check_result zend_check_array_shape(
 	HashTable *ht, const zend_array_shape *shape,
-	const zend_array_shape_element **failed_elem, zval **failed_val)
+	const zend_array_shape_element **failed_elem, zval **failed_val,
+	zend_string **extra_key)
 {
 	for (uint32_t i = 0; i < shape->num_elements; i++) {
 		const zend_array_shape_element *elem = &shape->elements[i];
 		zval *val = zend_hash_find(ht, elem->key);
 
-		if (val == NULL) {
+		if (UNEXPECTED(val == NULL)) {
 			if (!elem->is_optional) {
 				*failed_elem = elem;
 				*failed_val = NULL;
@@ -2151,51 +2459,102 @@ static zend_always_inline zend_shape_check_result zend_check_array_shape(
 			continue;
 		}
 
-		if (!zend_check_type(&elem->type, val, NULL, 0, false)) {
+		if (UNEXPECTED(!zend_check_type(&elem->type, val, NULL, 0, false))) {
 			*failed_elem = elem;
 			*failed_val = val;
 			return SHAPE_WRONG_TYPE;
 		}
 	}
 
+	/* For closed shapes, check that no extra keys exist */
+	if (UNEXPECTED(shape->is_closed)) {
+		if (zend_hash_num_elements(ht) != shape->num_elements) {
+			/* Use cached expected_keys hash table for O(1) lookup if available */
+			HashTable *expected_keys = shape->expected_keys;
+			HashTable local_keys;
+
+			/* Fallback to building temporary hash if cache is not available (arena shapes) */
+			if (!expected_keys) {
+				zend_hash_init(&local_keys, shape->num_elements, NULL, NULL, 0);
+				for (uint32_t i = 0; i < shape->num_elements; i++) {
+					zend_hash_add_empty_element(&local_keys, shape->elements[i].key);
+				}
+				expected_keys = &local_keys;
+			}
+
+			/* Find the first extra key for error message */
+			zend_string *key;
+			ZEND_HASH_FOREACH_STR_KEY(ht, key) {
+				if (key && !zend_hash_exists(expected_keys, key)) {
+					*extra_key = key;
+					if (expected_keys == &local_keys) {
+						zend_hash_destroy(&local_keys);
+					}
+					return SHAPE_EXTRA_KEY;
+				}
+			} ZEND_HASH_FOREACH_END();
+
+			if (expected_keys == &local_keys) {
+				zend_hash_destroy(&local_keys);
+			}
+		}
+	}
+
 	return SHAPE_OK;
 }
 
 static ZEND_COLD void zend_shape_return_error(
 	const zend_function *zf, zend_shape_check_result result,
-	const zend_array_shape_element *elem, zval *val)
+	const zend_array_shape_element *elem, zval *val, zend_string *extra_key)
 {
 	const char *fname = ZSTR_VAL(zf->common.function_name);
 	const char *fsep = zf->common.scope ? "::" : "";
 	const char *fclass = zf->common.scope ? ZSTR_VAL(zf->common.scope->name) : "";
 
+	if (result == SHAPE_EXTRA_KEY) {
+		zend_type_error("%s%s%s(): Return value must be of type " ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY,
+			fclass, fsep, fname, ZSTR_VAL(extra_key));
+		return;
+	}
+
+	zend_string *expected = zend_type_to_string(elem->type);
+
 	if (result == SHAPE_MISSING_KEY) {
-		zend_type_error("%s%s%s(): Return value must be of type array{%s: ...}, "
-			"missing required key \"%s\"",
-			fclass, fsep, fname, ZSTR_VAL(elem->key), ZSTR_VAL(elem->key));
+		zend_type_error("%s%s%s(): Return value must be of type " ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY,
+			fclass, fsep, fname, ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key));
 	} else {
-		zend_string *expected = zend_type_to_string(elem->type);
-		zend_type_error("%s%s%s(): Return value key \"%s\" must be of type %s, %s given",
-			fclass, fsep, fname, ZSTR_VAL(elem->key),
-			ZSTR_VAL(expected), zend_zval_value_name(val));
-		zend_string_release(expected);
+		zend_type_error("%s%s%s(): Return value must be of type " ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE,
+			fclass, fsep, fname, ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key), zend_zval_value_name(val));
 	}
+	zend_string_release(expected);
 }
 
 static ZEND_COLD void zend_shape_arg_error(
 	uint32_t arg_num, zend_shape_check_result result,
-	const zend_array_shape_element *elem, zval *val)
+	const zend_array_shape_element *elem, zval *val, zend_string *extra_key)
 {
+	if (result == SHAPE_EXTRA_KEY) {
+		zend_argument_type_error(arg_num,
+			"must be of type " ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY,
+			ZSTR_VAL(extra_key));
+		return;
+	}
+
+	zend_string *expected = zend_type_to_string(elem->type);
+
 	if (result == SHAPE_MISSING_KEY) {
-		zend_type_error("Argument #%u must be of type array{%s: ...}, "
-			"missing required key \"%s\"",
-			arg_num, ZSTR_VAL(elem->key), ZSTR_VAL(elem->key));
+		zend_argument_type_error(arg_num,
+			"must be of type " ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY,
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected), ZSTR_VAL(elem->key));
 	} else {
-		zend_string *expected = zend_type_to_string(elem->type);
-		zend_type_error("Argument #%u key \"%s\" must be of type %s, %s given",
-			arg_num, ZSTR_VAL(elem->key), ZSTR_VAL(expected), zend_zval_value_name(val));
-		zend_string_release(expected);
+		zend_argument_type_error(arg_num,
+			"must be of type " ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE,
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key), zend_zval_value_name(val));
 	}
+	zend_string_release(expected);
 }
 
 ZEND_API bool zend_verify_array_shape(
@@ -2203,12 +2562,13 @@ ZEND_API bool zend_verify_array_shape(
 {
 	const zend_array_shape_element *failed_elem;
 	zval *failed_val;
+	zend_string *extra_key = NULL;
 
 	zend_shape_check_result result = zend_check_array_shape(
-		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val);
+		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val, &extra_key);
 
 	if (UNEXPECTED(result != SHAPE_OK)) {
-		zend_shape_return_error(zf, result, failed_elem, failed_val);
+		zend_shape_return_error(zf, result, failed_elem, failed_val, extra_key);
 		return false;
 	}
 	return true;
@@ -2219,17 +2579,150 @@ ZEND_API bool zend_verify_array_arg_shape(
 {
 	const zend_array_shape_element *failed_elem;
 	zval *failed_val;
+	zend_string *extra_key = NULL;
 
 	zend_shape_check_result result = zend_check_array_shape(
-		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val);
+		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val, &extra_key);
 
 	if (UNEXPECTED(result != SHAPE_OK)) {
-		zend_shape_arg_error(arg_num, result, failed_elem, failed_val);
+		zend_shape_arg_error(arg_num, result, failed_elem, failed_val, extra_key);
 		return false;
 	}
 	return true;
 }
 
+static ZEND_COLD void zend_shape_prop_error(
+	const zend_property_info *info, zend_shape_check_result result,
+	const zend_array_shape_element *elem, zval *val, zend_string *extra_key)
+{
+	if (result == SHAPE_EXTRA_KEY) {
+		zend_type_error("Cannot assign to property %s::$%s of type " ZEND_SHAPE_ERROR_FORMAT_EXTRA_KEY,
+			ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name),
+			ZSTR_VAL(extra_key));
+		return;
+	}
+
+	zend_string *expected = zend_type_to_string(elem->type);
+
+	if (result == SHAPE_MISSING_KEY) {
+		zend_type_error("Cannot assign to property %s::$%s of type " ZEND_SHAPE_ERROR_FORMAT_MISSING_KEY,
+			ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name),
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected), ZSTR_VAL(elem->key));
+	} else {
+		zend_type_error("Cannot assign to property %s::$%s of type " ZEND_SHAPE_ERROR_FORMAT_WRONG_TYPE,
+			ZSTR_VAL(info->ce->name), ZSTR_VAL(info->name),
+			ZSTR_VAL(elem->key), ZSTR_VAL(expected),
+			ZSTR_VAL(elem->key), zend_zval_value_name(val));
+	}
+	zend_string_release(expected);
+}
+
+ZEND_API bool zend_verify_array_prop_shape(
+	const zend_property_info *info, zval *arr, const zend_array_shape *shape)
+{
+	const zend_array_shape_element *failed_elem;
+	zval *failed_val;
+	zend_string *extra_key = NULL;
+
+	zend_shape_check_result result = zend_check_array_shape(
+		Z_ARRVAL_P(arr), shape, &failed_elem, &failed_val, &extra_key);
+
+	if (UNEXPECTED(result != SHAPE_OK)) {
+		zend_shape_prop_error(info, result, failed_elem, failed_val, extra_key);
+		return false;
+	}
+	return true;
+}
+
+/* ZEND_SHAPE_MAX_RECURSION_DEPTH is defined in zend_compile.h */
+
+/* Thread-local recursion depth counter for shape validation.
+ * Protected by zend_try/zend_catch to ensure cleanup on exceptions/bailout. */
+ZEND_TLS int zend_shape_recursion_depth = 0;
+
+/* Reset shape recursion depth - called at request startup as defensive measure */
+ZEND_API void zend_reset_shape_recursion_depth(void)
+{
+	zend_shape_recursion_depth = 0;
+	zend_typed_array_recursion_depth = 0;
+}
+
+/* Check if a type name is actually a shape and validate accordingly */
+static bool zend_check_shape_type(const zend_type *type, zval *arg, bool is_return_type ZEND_ATTRIBUTE_UNUSED)
+{
+	if (!ZEND_TYPE_HAS_NAME(*type)) {
+		return false;
+	}
+
+	/* Check for excessive recursion depth (circular shape references).
+	 * This check happens BEFORE incrementing to avoid counter imbalance on error.
+	 * The limit is configurable via zend.shape_max_recursion_depth INI directive. */
+	zend_long max_depth = EG(shape_max_recursion_depth);
+	if (max_depth > 0 && UNEXPECTED(zend_shape_recursion_depth >= max_depth)) {
+		zend_error_noreturn(E_ERROR,
+			"Maximum shape nesting level of " ZEND_LONG_FMT " exceeded, possible circular reference",
+			max_depth);
+	}
+
+	zend_string *name = ZEND_TYPE_NAME(*type);
+	zend_shape_entry *shape = zend_lookup_shape(name);
+
+	if (!shape) {
+		return false;  /* Not a shape, caller should try class */
+	}
+
+	/* It's a shape - validate the value against the shape's type */
+	if (Z_TYPE_P(arg) != IS_ARRAY) {
+		return false;  /* Shapes require arrays */
+	}
+
+	/* Track recursion depth to detect circular references.
+	 * Use zend_try/zend_catch to ensure decrement even on exception/bailout. */
+	zend_shape_recursion_depth++;
+	bool result = false;
+
+	zend_try {
+		/* Use the shape's type for validation */
+		zend_type shape_type = shape->type;
+
+		/* Check if it's an array shape type */
+		if (ZEND_TYPE_HAS_ARRAY_SHAPE(shape_type) && shape_type.ptr != NULL) {
+			zend_array_shape *shape_def = ZEND_ARRAY_SHAPE(shape_type);
+			const zend_array_shape_element *failed_elem;
+			zval *failed_val;
+			zend_string *extra_key = NULL;
+			/* Validate the array against the shape definition */
+			zend_shape_check_result check_result = zend_check_array_shape(
+				Z_ARRVAL_P(arg), shape_def, &failed_elem, &failed_val, &extra_key);
+			result = (check_result == SHAPE_OK);
+		}
+		/* Check if it's a typed array */
+		else if (ZEND_TYPE_HAS_ARRAY_ELEMENT(shape_type)) {
+			zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(shape_type);
+			HashTable *ht = Z_ARRVAL_P(arg);
+			zval *val;
+			result = true;
+			ZEND_HASH_FOREACH_VAL(ht, val) {
+				if (!ZEND_TYPE_CONTAINS_CODE(elem->element_type, Z_TYPE_P(val))) {
+					result = false;
+					break;
+				}
+			} ZEND_HASH_FOREACH_END();
+		}
+		/* For simple array type */
+		else if (ZEND_TYPE_PURE_MASK(shape_type) & MAY_BE_ARRAY) {
+			result = true;
+		}
+	} zend_catch {
+		/* Exception/bailout occurred - decrement and re-throw */
+		zend_shape_recursion_depth--;
+		zend_bailout();
+	} zend_end_try();
+
+	zend_shape_recursion_depth--;
+	return result;
+}
+
 ZEND_API ZEND_COLD void zend_verify_never_error(const zend_function *zf)
 {
 	zend_string *func_name = get_function_or_method_name(zf);
diff --git a/Zend/zend_execute.h b/Zend/zend_execute.h
index fda9b47c..a3d6cfb9 100644
--- a/Zend/zend_execute.h
+++ b/Zend/zend_execute.h
@@ -51,6 +51,9 @@ ZEND_API void execute_internal(zend_execute_data *execute_data, zval *return_val
 ZEND_API bool zend_is_valid_class_name(zend_string *name);
 ZEND_API zend_class_entry *zend_lookup_class(zend_string *name);
 ZEND_API zend_class_entry *zend_lookup_class_ex(zend_string *name, zend_string *lcname, uint32_t flags);
+ZEND_API zend_shape_entry *zend_lookup_shape(zend_string *name);
+ZEND_API void zend_reset_shape_recursion_depth(void);
+ZEND_API zend_shape_entry *zend_lookup_shape_ex(zend_string *name, zend_string *lcname, uint32_t flags);
 ZEND_API zend_class_entry *zend_get_called_scope(zend_execute_data *ex);
 ZEND_API zend_object *zend_get_this_object(zend_execute_data *ex);
 ZEND_API zend_result zend_eval_string(const char *str, zval *retval_ptr, const char *string_name);
@@ -120,6 +123,8 @@ ZEND_API ZEND_COLD void zend_verify_array_prop_element_type_error(
 		const char *expected_type, const char *actual_type);
 ZEND_API bool zend_verify_array_prop_element_types(
 		const zend_property_info *info, zval *arr, const zend_typed_array_element *elem_type);
+ZEND_API bool zend_verify_array_prop_shape(
+		const zend_property_info *info, zval *arr, const zend_array_shape *shape);
 ZEND_API ZEND_COLD void zend_verify_array_key_type_error(
 		const zend_function *zf, const char *expected_key_type, const char *actual_key_type);
 ZEND_API ZEND_COLD void zend_verify_array_arg_key_type_error(
diff --git a/Zend/zend_execute_API.c b/Zend/zend_execute_API.c
index 0719fcbb..f331d7ff 100644
--- a/Zend/zend_execute_API.c
+++ b/Zend/zend_execute_API.c
@@ -129,6 +129,9 @@ void init_executor(void) /* {{{ */
 {
 	zend_init_fpu();
 
+	/* Reset shape/typed array recursion counters (defensive measure) */
+	zend_reset_shape_recursion_depth();
+
 	ZVAL_NULL(&EG(uninitialized_zval));
 	ZVAL_ERROR(&EG(error_zval));
 /* destroys stack frame, therefore makes core dumps worthless */
@@ -144,6 +147,7 @@ void init_executor(void) /* {{{ */
 
 	EG(function_table) = CG(function_table);
 	EG(class_table) = CG(class_table);
+	EG(shape_table) = CG(shape_table);
 
 	EG(in_autoload) = NULL;
 	EG(error_handling) = EH_NORMAL;
@@ -1296,6 +1300,101 @@ ZEND_API zend_class_entry *zend_lookup_class(zend_string *name) /* {{{ */
 }
 /* }}} */
 
+ZEND_API zend_shape_entry *zend_lookup_shape_ex(zend_string *name, zend_string *lc_name, uint32_t flags) /* {{{ */
+{
+	zval *zv;
+	zend_string *lookup_name;
+	bool free_lookup_name = false;
+	zend_shape_entry *shape = NULL;
+
+	if (lc_name) {
+		lookup_name = lc_name;
+	} else {
+		if (!ZSTR_LEN(name)) {
+			return NULL;
+		}
+
+		if (ZSTR_VAL(name)[0] == '\\') {
+			lookup_name = zend_string_alloc(ZSTR_LEN(name) - 1, 0);
+			zend_str_tolower_copy(ZSTR_VAL(lookup_name), ZSTR_VAL(name) + 1, ZSTR_LEN(name) - 1);
+		} else {
+			lookup_name = zend_string_tolower(name);
+		}
+		free_lookup_name = true;
+	}
+
+	zv = zend_hash_find(EG(shape_table), lookup_name);
+	if (zv) {
+		shape = (zend_shape_entry*)Z_PTR_P(zv);
+		goto done;
+	}
+
+	/* Shape not found - try autoloading if allowed */
+	/* The compiler is not-reentrant. Make sure we autoload only during run-time. */
+	if ((flags & ZEND_FETCH_CLASS_NO_AUTOLOAD) || zend_is_compiling()) {
+		goto done;
+	}
+
+	if (!zend_autoload) {
+		goto done;
+	}
+
+	/* Use the same in_autoload hash as classes to prevent recursive autoloading */
+	if (EG(in_autoload) == NULL) {
+		ALLOC_HASHTABLE(EG(in_autoload));
+		zend_hash_init(EG(in_autoload), 8, NULL, NULL, 0);
+	}
+
+	if (zend_hash_add_empty_element(EG(in_autoload), lookup_name) == NULL) {
+		/* Already autoloading this shape */
+		goto done;
+	}
+
+	{
+		zend_string *autoload_name;
+		if (ZSTR_VAL(name)[0] == '\\') {
+			autoload_name = zend_string_init(ZSTR_VAL(name) + 1, ZSTR_LEN(name) - 1, 0);
+		} else {
+			autoload_name = zend_string_copy(name);
+		}
+
+		zend_string *previous_filename = EG(filename_override);
+		zend_long previous_lineno = EG(lineno_override);
+		EG(filename_override) = NULL;
+		EG(lineno_override) = -1;
+		zend_exception_save();
+		/* Call the autoloader - it will include the file defining the shape */
+		zend_autoload(autoload_name, lookup_name);
+		zend_exception_restore();
+		EG(filename_override) = previous_filename;
+		EG(lineno_override) = previous_lineno;
+
+		zend_string_release_ex(autoload_name, 0);
+	}
+
+	zend_hash_del(EG(in_autoload), lookup_name);
+
+	/* Check if the shape was defined by the autoloaded file */
+	zv = zend_hash_find(EG(shape_table), lookup_name);
+	if (zv) {
+		shape = (zend_shape_entry*)Z_PTR_P(zv);
+	}
+
+done:
+	if (free_lookup_name) {
+		zend_string_release_ex(lookup_name, 0);
+	}
+
+	return shape;
+}
+/* }}} */
+
+ZEND_API zend_shape_entry *zend_lookup_shape(zend_string *name) /* {{{ */
+{
+	return zend_lookup_shape_ex(name, NULL, 0);
+}
+/* }}} */
+
 ZEND_API zend_class_entry *zend_get_called_scope(zend_execute_data *ex) /* {{{ */
 {
 	while (ex) {
diff --git a/Zend/zend_globals.h b/Zend/zend_globals.h
index 7d9ef85b..91f7750b 100644
--- a/Zend/zend_globals.h
+++ b/Zend/zend_globals.h
@@ -94,6 +94,7 @@ struct _zend_compiler_globals {
 
 	HashTable *function_table;	/* function symbol table */
 	HashTable *class_table;		/* class table */
+	HashTable *shape_table;		/* shape type aliases */
 
 	HashTable *auto_globals;
 
@@ -191,6 +192,9 @@ struct _zend_executor_globals {
 	HashTable *function_table;	/* function symbol table */
 	HashTable *class_table;		/* class table */
 	HashTable *zend_constants;	/* constants table */
+	HashTable *shape_table;		/* shape type aliases */
+
+	zend_long shape_max_recursion_depth;  /* Configurable max recursion for shape validation */
 
 	zval          *vm_stack_top;
 	zval          *vm_stack_end;
diff --git a/Zend/zend_hash.c b/Zend/zend_hash.c
index 3dfc345e..b46bfbca 100644
--- a/Zend/zend_hash.c
+++ b/Zend/zend_hash.c
@@ -830,6 +830,7 @@ static zend_always_inline zval *_zend_hash_add_or_update_i(HashTable *ht, zend_s
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
 	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 	zend_string_hash_val(key);
 
 	if (UNEXPECTED(HT_FLAGS(ht) & (HASH_FLAG_UNINITIALIZED|HASH_FLAG_PACKED))) {
@@ -912,6 +913,7 @@ static zend_always_inline zval *_zend_hash_str_add_or_update_i(HashTable *ht, co
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
 	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 
 	if (UNEXPECTED(HT_FLAGS(ht) & (HASH_FLAG_UNINITIALIZED|HASH_FLAG_PACKED))) {
 		if (EXPECTED(HT_FLAGS(ht) & HASH_FLAG_UNINITIALIZED)) {
@@ -1098,6 +1100,7 @@ static zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht,
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
 	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 
 	if ((flag & HASH_ADD_NEXT) && h == ZEND_LONG_MIN) {
 		h = 0;
@@ -1455,6 +1458,7 @@ static zend_always_inline void zend_hash_iterators_clamp_max(const HashTable *ht
 static zend_always_inline void _zend_hash_packed_del_val(HashTable *ht, uint32_t idx, zval *zv)
 {
 	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 	idx = HT_HASH_TO_IDX(idx);
 	ht->nNumOfElements--;
 	if (ht->nNumUsed - 1 == idx) {
@@ -1477,6 +1481,7 @@ static zend_always_inline void _zend_hash_packed_del_val(HashTable *ht, uint32_t
 static zend_always_inline void _zend_hash_del_el_ex(HashTable *ht, uint32_t idx, Bucket *p, Bucket *prev)
 {
 	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 	if (prev) {
 		Z_NEXT(prev->val) = Z_NEXT(p->val);
 	} else {
@@ -1882,6 +1887,7 @@ ZEND_API void ZEND_FASTCALL zend_hash_clean(HashTable *ht)
 	IS_CONSISTENT(ht);
 	HT_ASSERT_RC1(ht);
 	HT_INVALIDATE_ELEM_TYPE(ht);
+	HT_INVALIDATE_KEY_TYPE(ht);
 
 	if (ht->nNumUsed) {
 		if (HT_IS_PACKED(ht)) {
diff --git a/Zend/zend_hash.h b/Zend/zend_hash.h
index 0111c64d..b2bf43f1 100644
--- a/Zend/zend_hash.h
+++ b/Zend/zend_hash.h
@@ -86,6 +86,42 @@ typedef enum {
 #define HT_DEC_ITERATORS_COUNT(ht) \
 	HT_SET_ITERATORS_COUNT(ht, HT_ITERATORS_COUNT(ht) - 1)
 
+/*
+ * Typed Array Validation Cache
+ * ============================
+ *
+ * These macros provide caching infrastructure for array<T> and array<K,V>
+ * type validation, significantly reducing runtime overhead for repeated
+ * validations of the same array.
+ *
+ * Cache Structure:
+ * - nValidatedElemType (uint8_t): Stores the last validated element type code
+ *   (IS_LONG, IS_STRING, IS_DOUBLE, etc.) for simple types
+ * - nValidatedKeyType (uint8_t): Stores the validated key type mask
+ *   (MAY_BE_LONG, MAY_BE_STRING, or MAY_BE_LONG|MAY_BE_STRING)
+ * - HASH_FLAG_ELEM_TYPE_VALID (bit 7 of flags): Indicates if element cache is valid
+ *
+ * Cache Invalidation:
+ * The caches are automatically invalidated when the array is mutated:
+ * - Adding elements: zend_hash_add, zend_hash_update, zend_hash_index_add, etc.
+ * - Removing elements: zend_hash_del, zend_hash_index_del, etc.
+ * - Clearing array: zend_hash_clean
+ *
+ * This ensures correctness: after mutation, the next validation will
+ * re-check all elements and update the cache accordingly.
+ *
+ * Performance Notes:
+ * - Cache hit: O(1) - just check the cached type code
+ * - Cache miss: O(n) - validate all elements and update cache
+ * - Empty arrays: O(1) - always valid, no caching needed
+ * - Packed arrays with int keys: Immediate cache hit for MAY_BE_LONG key type
+ *
+ * Limitations:
+ * - Element type cache only works for simple types (not union types)
+ * - Object types with class names are not cached (class may be reloaded)
+ * - Cache is per-array, not per-type (same array, different type = miss)
+ */
+
 /* Element type validation cache for array<T> optimization */
 #define HT_VALIDATED_ELEM_TYPE(ht) (ht)->u.v.nValidatedElemType
 #define HT_ELEM_TYPE_IS_VALID(ht) ((HT_FLAGS(ht) & HASH_FLAG_ELEM_TYPE_VALID) != 0)
@@ -96,6 +132,17 @@ typedef enum {
 		HT_FLAGS(ht) |= HASH_FLAG_ELEM_TYPE_VALID; \
 	} while (0)
 
+/* Key type validation cache for array<K,V> optimization
+ * Stores the validated key type mask (MAY_BE_LONG, MAY_BE_STRING, or both)
+ * Value 0 means not validated, non-zero means validated for that key mask */
+#define HT_VALIDATED_KEY_TYPE(ht) (ht)->u.v.nValidatedKeyType
+#define HT_KEY_TYPE_IS_VALID(ht) ((ht)->u.v.nValidatedKeyType != 0)
+#define HT_INVALIDATE_KEY_TYPE(ht) \
+	do { (ht)->u.v.nValidatedKeyType = 0; } while (0)
+#define HT_SET_VALIDATED_KEY_TYPE(ht, mask) do { \
+		(ht)->u.v.nValidatedKeyType = (uint8_t)(mask); \
+	} while (0)
+
 extern ZEND_API const HashTable zend_empty_array;
 
 #define ZVAL_EMPTY_ARRAY(z) do {						\
diff --git a/Zend/zend_language_parser.y b/Zend/zend_language_parser.y
index 219c9329..161f4d10 100644
--- a/Zend/zend_language_parser.y
+++ b/Zend/zend_language_parser.y
@@ -169,6 +169,7 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %token <ident> T_TRAIT         "'trait'"
 %token <ident> T_INTERFACE     "'interface'"
 %token <ident> T_ENUM          "'enum'"
+%token <ident> T_SHAPE         "'shape'"
 %token <ident> T_EXTENDS       "'extends'"
 %token <ident> T_IMPLEMENTS    "'implements'"
 %token <ident> T_NAMESPACE     "'namespace'"
@@ -288,6 +289,7 @@ static YYSIZE_T zend_yytnamerr(char*, const char*);
 %type <ast> attribute_decl attribute attributes attribute_group namespace_declaration_name
 %type <ast> match match_arm_list non_empty_match_arm_list match_arm match_arm_cond_list
 %type <ast> enum_declaration_statement enum_backing_type enum_case enum_case_expr
+%type <ast> shape_declaration_statement shape_extends_from
 %type <ast> function_name non_empty_member_modifiers
 %type <ast> property_hook property_hook_list optional_property_hook_list hooked_property property_hook_body
 %type <ast> optional_parameter_list clone_argument_list non_empty_clone_argument_list
@@ -315,7 +317,7 @@ reserved_non_modifiers:
 	| T_FUNCTION | T_CONST | T_RETURN | T_PRINT | T_YIELD | T_LIST | T_SWITCH | T_ENDSWITCH | T_CASE | T_DEFAULT | T_BREAK
 	| T_ARRAY | T_CALLABLE | T_EXTENDS | T_IMPLEMENTS | T_NAMESPACE | T_TRAIT | T_INTERFACE | T_CLASS
 	| T_CLASS_C | T_TRAIT_C | T_FUNC_C | T_METHOD_C | T_LINE | T_FILE | T_DIR | T_NS_C | T_FN | T_MATCH | T_ENUM
-	| T_PROPERTY_C
+	| T_PROPERTY_C | T_SHAPE
 ;
 
 semi_reserved:
@@ -396,6 +398,7 @@ attributed_statement:
 	|	trait_declaration_statement			{ $$ = $1; }
 	|	interface_declaration_statement		{ $$ = $1; }
 	|	enum_declaration_statement			{ $$ = $1; }
+	|	shape_declaration_statement			{ $$ = $1; }
 ;
 
 attributed_top_statement:
@@ -670,6 +673,16 @@ enum_case_expr:
 	|	'=' expr { $$ = $2; }
 ;
 
+shape_extends_from:
+		%empty				{ $$ = NULL; }
+	|	T_EXTENDS name		{ $$ = $2; }
+;
+
+shape_declaration_statement:
+		T_SHAPE T_STRING shape_extends_from '=' type_expr ';'
+			{ $$ = zend_ast_create(ZEND_AST_SHAPE_DECL, $2, $3, $5); }
+;
+
 extends_from:
 		%empty				{ $$ = NULL; }
 	|	T_EXTENDS class_name	{ $$ = $2; }
@@ -882,9 +895,13 @@ type_without_static:
 	|	T_ARRAY '<' type_expr ',' type_expr '>'
 			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_MAP, $3, $5); }
 	|	T_ARRAY_SHAPE_START shape_element_list '}'
-			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_SHAPE, $2); }
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 0, $2); }
 	|	T_ARRAY_SHAPE_START '}'
-			{ $$ = zend_ast_create(ZEND_AST_TYPE_ARRAY_SHAPE, NULL); }
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 0, NULL); }
+	|	T_ARRAY_SHAPE_START shape_element_list '}' '!'
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 1, $2); }
+	|	T_ARRAY_SHAPE_START '}' '!'
+			{ $$ = zend_ast_create_ex(ZEND_AST_TYPE_ARRAY_SHAPE, 1, NULL); }
 ;
 
 shape_element_list:
diff --git a/Zend/zend_language_scanner.l b/Zend/zend_language_scanner.l
index 63ec131e..028f0633 100644
--- a/Zend/zend_language_scanner.l
+++ b/Zend/zend_language_scanner.l
@@ -1576,6 +1576,11 @@ OPTIONAL_WHITESPACE_OR_COMMENTS ({WHITESPACE}|{MULTI_LINE_COMMENT}|{SINGLE_LINE_
 	RETURN_TOKEN_WITH_IDENT(T_ENUM);
 }
 
+<ST_IN_SCRIPTING>"shape"{WHITESPACE_OR_COMMENTS}[a-zA-Z_\x80-\xff] {
+	yyless(5);
+	RETURN_TOKEN_WITH_IDENT(T_SHAPE);
+}
+
 <ST_IN_SCRIPTING>"extends" {
 	RETURN_TOKEN_WITH_IDENT(T_EXTENDS);
 }
diff --git a/Zend/zend_object_handlers.c b/Zend/zend_object_handlers.c
index c723e4d6..6a5873d5 100644
--- a/Zend/zend_object_handlers.c
+++ b/Zend/zend_object_handlers.c
@@ -1003,12 +1003,9 @@ static zend_always_inline bool property_uses_strict_types(void) {
 		&& ZEND_CALL_USES_STRICT_TYPES(EG(current_execute_data));
 }
 
+/* Typed array checking is always enabled */
 static zend_always_inline bool property_uses_strict_arrays(void) {
-	zend_execute_data *execute_data = EG(current_execute_data);
-	return execute_data
-		&& execute_data->func
-		&& ZEND_USER_CODE(execute_data->func->type)
-		&& (execute_data->func->op_array.fn_flags & ZEND_ACC_STRICT_ARRAYS);
+	return true;
 }
 
 static zval *forward_write_to_lazy_object(zend_object *zobj,
@@ -1107,13 +1104,22 @@ ZEND_API zval *zend_std_write_property(zend_object *zobj, zend_string *name, zva
 					variable_ptr = &EG(error_zval);
 					goto exit;
 				}
-				/* Check array element types if strict_arrays is enabled */
-				if (property_uses_strict_arrays() && Z_TYPE(tmp) == IS_ARRAY && ZEND_TYPE_HAS_ARRAY_ELEMENT(prop_info->type)) {
-					zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(prop_info->type);
-					if (!zend_verify_array_prop_element_types(prop_info, &tmp, elem_type)) {
-						zval_ptr_dtor(&tmp);
-						variable_ptr = &EG(error_zval);
-						goto exit;
+				/* Check array element types for typed arrays and array shapes */
+				if (Z_TYPE(tmp) == IS_ARRAY) {
+					if (ZEND_TYPE_HAS_ARRAY_ELEMENT(prop_info->type)) {
+						zend_typed_array_element *elem_type = ZEND_TYPED_ARRAY_ELEMENT(prop_info->type);
+						if (UNEXPECTED(!zend_verify_array_prop_element_types(prop_info, &tmp, elem_type))) {
+							zval_ptr_dtor(&tmp);
+							variable_ptr = &EG(error_zval);
+							goto exit;
+						}
+					} else if (ZEND_TYPE_HAS_ARRAY_SHAPE(prop_info->type)) {
+						zend_array_shape *shape = ZEND_ARRAY_SHAPE(prop_info->type);
+						if (UNEXPECTED(!zend_verify_array_prop_shape(prop_info, &tmp, shape))) {
+							zval_ptr_dtor(&tmp);
+							variable_ptr = &EG(error_zval);
+							goto exit;
+						}
 					}
 				}
 				Z_PROP_FLAG_P(variable_ptr) &= ~(IS_PROP_UNINIT|IS_PROP_REINITABLE);
diff --git a/Zend/zend_opcode.c b/Zend/zend_opcode.c
index f3631104..036da43e 100644
--- a/Zend/zend_opcode.c
+++ b/Zend/zend_opcode.c
@@ -121,6 +121,12 @@ ZEND_API void zend_type_release(zend_type type, bool persistent) {
 	} else if (ZEND_TYPE_HAS_NAME(type)) {
 		zend_string_release(ZEND_TYPE_NAME(type));
 	}
+	/* Note: Array shapes and typed arrays are NOT freed here.
+	 * They are either:
+	 * 1. Arena-allocated (inline shapes like array{x: int}) - freed by arena cleanup
+	 * 2. Shape-table-owned (named shapes like MyShape) - freed by zend_shape_dtor
+	 * Freeing here would cause double-free since function arg_info shares
+	 * the same pointer as shape table entries for named shapes. */
 }
 
 void zend_free_internal_arg_info(zend_internal_function *function) {
diff --git a/Zend/zend_types.h b/Zend/zend_types.h
index 9f79a3cb..2ab2c7eb 100644
--- a/Zend/zend_types.h
+++ b/Zend/zend_types.h
@@ -157,8 +157,18 @@ typedef struct {
 #define _ZEND_TYPE_INTERSECTION_BIT (1u << 19)
 /* Whether the type is a union type */
 #define _ZEND_TYPE_UNION_BIT (1u << 18)
-/* Whether the type is an array shape (array{key: type}) */
+
+/* Array shape type bits use high bits (29-30) to avoid conflict with other type flags.
+ * Bit allocation in type_mask:
+ *   Bits 0-17:  MAY_BE_* type bits (IS_UNDEF through IS_NEVER)
+ *   Bits 18-24: Type modifiers (union, intersection, arena, iterable, kind)
+ *   Bits 25-28: Reserved
+ *   Bit 29:     Shape name reference (runtime-resolved shape alias)
+ *   Bit 30:     Array shape (inline array{key: type} definition)
+ *   Bit 31:     Unused (sign bit)
+ */
 #define _ZEND_TYPE_ARRAY_SHAPE_BIT (1u << 30)
+#define _ZEND_TYPE_SHAPE_NAME_BIT (1u << 29)
 /* Type mask for MAY_BE_* type bits only (bits 0-17, including IS_NEVER) */
 #define _ZEND_TYPE_MAY_BE_MASK ((1u << 18) - 1)
 /* Must have same value as MAY_BE_NULL */
@@ -196,6 +206,12 @@ typedef struct {
 #define ZEND_TYPE_HAS_ARRAY_ELEMENT(t) \
 	((((t).type_mask) & (1u << IS_ARRAY)) != 0 && (t).ptr != NULL && !ZEND_TYPE_IS_COMPLEX(t) && !((t).type_mask & _ZEND_TYPE_ARRAY_SHAPE_BIT))
 
+#define ZEND_TYPE_HAS_SHAPE_NAME(t) \
+	((((t).type_mask) & _ZEND_TYPE_SHAPE_NAME_BIT) != 0)
+
+#define ZEND_TYPE_SHAPE_NAME(t) \
+	((zend_string *) (t).ptr)
+
 #define ZEND_TYPE_IS_ONLY_MASK(t) \
 	(ZEND_TYPE_IS_SET(t) && (t).ptr == NULL)
 
@@ -418,7 +434,7 @@ struct _zend_array {
 				uint8_t    flags,
 				uint8_t    nValidatedElemType,  /* Cached validated element type for array<T> */
 				uint8_t    nIteratorsCount,
-				uint8_t    _unused2)
+				uint8_t    nValidatedKeyType)   /* Cached validated key type for array<K,V> */
 		} v;
 		uint32_t flags;
 	} u;
diff --git a/docs/RFC-array-shapes.md b/docs/RFC-array-shapes.md
new file mode 100644
index 00000000..cc5a5575
--- /dev/null
+++ b/docs/RFC-array-shapes.md
@@ -0,0 +1,718 @@
+# RFC: Typed Arrays & Array Shapes for PHP
+
+* Version: 1.3
+* Date: 2026-01-04
+* Author: PHP Array Shapes Implementation
+* Status: Implemented (Proof of Concept)
+* New in 1.3: Compile-time validation for shape/class cross-inheritance
+* New in 1.2: Shape inheritance (`extends`) and `::shape` syntax
+
+## Introduction
+
+This RFC proposes adding **Typed Arrays** and **Array Shapes** to PHP—two complementary
+features that bring type safety to PHP's most versatile data structure. These features
+address different use cases: typed arrays for **collections** and array shapes for
+**structured data**.
+
+## Motivation
+
+PHP arrays serve multiple purposes: lists, dictionaries, records, and complex nested
+structures. However, the type system only allows declaring a value as `array` without
+specifying what it contains:
+
+```php
+function getUsers(): array {
+    // What's in this array? Objects? Associative arrays? Integers?
+    // The type system can't tell you.
+}
+```
+
+This leads to:
+
+1. **Runtime errors** - Type mismatches discovered only during execution
+2. **Poor IDE support** - Limited autocomplete and refactoring capabilities
+3. **Documentation burden** - Developers must rely on PHPDoc annotations
+4. **Maintenance issues** - Changing array structures requires manual updates
+
+Static analysis tools like PHPStan and Psalm have introduced PHPDoc-based array
+shape syntax, demonstrating strong community demand for this feature.
+
+## Two Complementary Features
+
+### Typed Arrays — For Collections
+
+When you have a **list of things of the same type**, use typed arrays:
+
+```php
+// A list of integers
+function getIds(): array<int> {
+    return [1, 2, 3];
+}
+
+// A list of User objects
+function getActiveUsers(): array<User> {
+    return $this->repository->findActive();
+}
+```
+
+### Array Shapes — For Structured Data
+
+When you have **structured data with known keys**, like records from a database or
+responses from an API, use array shapes:
+
+```php
+// Data from a database row
+function getUser(int $id): array{id: int, name: string, email: string} {
+    return $this->db->fetch("SELECT id, name, email FROM users WHERE id = ?", $id);
+}
+
+// Response from an external API
+function getWeather(string $city): array{temp: float, humidity: int} {
+    return json_decode(file_get_contents("https://api.weather.com/$city"), true);
+}
+```
+
+### Why Not Just Use Classes/DTOs?
+
+A common question: "With constructor property promotion, classes are almost as concise.
+Why do we need array shapes?"
+
+#### Side-by-Side Comparison
+
+```php
+// With array shapes (this RFC)
+shape UserResponse = array{id: int, name: string, email: ?string};
+
+function getUser(): UserResponse {
+    return ['id' => 1, 'name' => 'Alice', 'email' => null];
+}
+
+// With classes + constructor property promotion
+readonly class UserResponse {
+    public function __construct(
+        public int $id,
+        public string $name,
+        public ?string $email,
+    ) {}
+}
+
+function getUser(): UserResponse {
+    return new UserResponse(id: 1, name: 'Alice', email: null);
+}
+```
+
+At first glance, these look similar. But there are fundamental differences:
+
+#### 1. JSON Serialization
+
+```php
+// Array shapes: direct serialization
+$user = getUser();  // Returns array
+echo json_encode($user);  // {"id":1,"name":"Alice","email":null}
+
+// Classes: requires extra work
+$user = getUser();  // Returns object
+echo json_encode($user);  // {} (empty without JsonSerializable!)
+
+// Must implement JsonSerializable or add toArray():
+readonly class UserResponse implements JsonSerializable {
+    public function __construct(
+        public int $id,
+        public string $name,
+        public ?string $email,
+    ) {}
+
+    public function jsonSerialize(): array {
+        return ['id' => $this->id, 'name' => $this->name, 'email' => $this->email];
+    }
+}
+```
+
+For API responses, you need `json_encode()` to just work. With array shapes, it does.
+With classes, you must implement `JsonSerializable` for **every single DTO**.
+
+#### 2. Working with Existing Data Sources
+
+```php
+// PDO returns arrays
+$row = $pdo->fetch(PDO::FETCH_ASSOC);  // array{id: int, name: string, ...}
+
+// json_decode returns arrays
+$data = json_decode($json, true);  // array{...}
+
+// config files return arrays
+$config = require 'config.php';  // array{...}
+
+// With array shapes: use directly
+function processUser(UserResponse $user): void { ... }
+processUser($row);  // Works!
+
+// With classes: must transform everything
+processUser(new UserResponse(...$row));  // Extra allocation + mapping
+```
+
+Array shapes work with the data you already have. Classes require transformation.
+
+#### 3. Array Functions and Operations
+
+```php
+// Array shapes: native array operations work
+$users = getUsers();  // array<UserResponse>
+$names = array_column($users, 'name');
+$filtered = array_filter($users, fn($u) => $u['id'] > 10);
+$mapped = array_map(fn($u) => $u['name'], $users);
+$merged = [...$user1, ...$user2];  // Spread operator
+['id' => $id, 'name' => $name] = $user;  // Destructuring
+
+// Classes: none of these work directly
+$users = getUsers();  // array<UserResponse>
+$names = array_map(fn($u) => $u->name, $users);  // Must use closures
+$filtered = array_filter($users, fn($u) => $u->id > 10);
+// No spread, no array_column, no destructuring
+```
+
+#### 4. No File/Class Boilerplate
+
+```php
+// Array shapes: define inline or in any file
+function getPoint(): array{x: int, y: int} {
+    return ['x' => 10, 'y' => 20];
+}
+
+// Or define once, use anywhere
+shape Point = array{x: int, y: int};
+
+// Classes: each needs its own file (PSR-4), own namespace, own declaration
+// src/DTO/Point.php
+namespace App\DTO;
+
+readonly class Point {
+    public function __construct(
+        public int $x,
+        public int $y,
+    ) {}
+}
+```
+
+For a complex API with 50+ response types, that's 50+ class files vs one `shapes.php`.
+
+#### 5. Memory and Performance
+
+```php
+// Array: ~400 bytes for small associative array
+$user = ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+
+// Object: ~600+ bytes (object overhead, property table, class entry reference)
+$user = new UserResponse(1, 'Alice', 'alice@example.com');
+```
+
+When processing thousands of records, this adds up. Arrays are PHP's most optimized
+data structure.
+
+#### 6. Framework Expectations
+
+Many frameworks expect arrays:
+
+```php
+// Laravel
+return response()->json($data);  // Expects array
+Model::create($attributes);       // Expects array
+DB::table('users')->insert($data); // Expects array
+
+// Symfony
+return $this->json($data);        // Expects array
+$serializer->serialize($data);    // Handles arrays natively
+```
+
+#### When to Use Classes Instead
+
+Classes are the right choice when you need:
+
+- **Behavior** (methods that operate on the data)
+- **Encapsulation** (private properties, validation in constructor)
+- **Identity** (instanceof checks, type hierarchies)
+- **Mutability control** (readonly properties with controlled modification)
+
+Array shapes are the right choice when you have:
+
+- **Pure data** (no behavior needed)
+- **External data sources** (APIs, databases, config files)
+- **Serialization needs** (JSON responses)
+- **Existing array-based code** (gradual typing of legacy code)
+
+#### Summary
+
+| Feature | Array Shapes | Classes (CPP) |
+|---------|--------------|---------------|
+| JSON serialization | Direct | Requires JsonSerializable |
+| PDO/json_decode | Direct | Requires transformation |
+| array_map/filter | Native | Requires closures |
+| Spread operator | Yes | No |
+| Destructuring | Yes | No |
+| Memory overhead | Minimal | Higher |
+| File per type | No | Yes (PSR-4) |
+| Inline definition | Yes | No |
+| Methods | No | Yes |
+| Private properties | No | Yes |
+
+Array shapes and classes serve different purposes. This RFC doesn't replace classes—
+it provides first-class typing for the millions of lines of PHP that already use
+arrays for data interchange.
+
+## Proposal
+
+### 1. Typed Arrays (`array<T>`)
+
+Specify that all elements of an array must be of a certain type:
+
+```php
+function getIds(): array<int> {
+    return [1, 2, 3];
+}
+
+function getUsers(): array<User> {
+    return [new User("Alice"), new User("Bob")];
+}
+
+function getValues(): array<int|string> {
+    return [1, "two", 3];
+}
+```
+
+### 2. Key-Value Typed Arrays (`array<K, V>`)
+
+Specify both key and value types:
+
+```php
+function getScores(): array<string, int> {
+    return ['alice' => 95, 'bob' => 87];
+}
+
+function getUsersById(): array<int, User> {
+    return [1 => new User("Alice"), 2 => new User("Bob")];
+}
+```
+
+### 3. Array Shapes (`array{key: type}`)
+
+Define the exact structure of associative arrays:
+
+```php
+function getUser(): array{id: int, name: string, email: string} {
+    return ['id' => 1, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+```
+
+#### Optional Keys
+
+Use `?` after the key name to mark it as optional:
+
+```php
+function getConfig(): array{debug: bool, cache_ttl?: int} {
+    return ['debug' => true];  // cache_ttl is optional
+}
+```
+
+#### Nullable Values
+
+Use `?` before the type to allow null values:
+
+```php
+function getUser(): array{name: string, email: ?string} {
+    return ['name' => 'Alice', 'email' => null];  // email can be null
+}
+```
+
+#### Nested Shapes
+
+Shapes can be nested arbitrarily:
+
+```php
+function getResponse(): array{
+    success: bool,
+    data: array{
+        user: array{id: int, name: string},
+        permissions: array<string>
+    },
+    error: ?string
+} {
+    // ...
+}
+```
+
+### 4. Shape Type Aliases (`shape`)
+
+Define reusable type aliases for array structures using the `shape` keyword:
+
+```php
+shape User = array{id: int, name: string, email: string};
+shape Point = array{x: int, y: int};
+shape Config = array{debug: bool, env: string, cache_ttl?: int};
+
+function getUser(int $id): User {
+    return ['id' => $id, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+
+function processUser(User $user): void {
+    echo "Processing: {$user['name']}";
+}
+```
+
+#### Shape Inheritance
+
+Shapes can extend other shapes using the `extends` keyword. The child shape
+inherits all properties from the parent and can add new ones or override existing ones:
+
+```php
+shape BaseEntity = array{id: int, created_at: string};
+shape User extends BaseEntity = array{name: string, email: string};
+shape Admin extends User = array{role: string, permissions: array<string>};
+
+// User has: id, created_at, name, email
+// Admin has: id, created_at, name, email, role, permissions
+```
+
+Inheritance is resolved at compile time (flattened), so there's no runtime
+overhead. The child shape contains all properties from the entire inheritance chain.
+
+**Property Override:**
+
+Child shapes can override parent properties with a different type:
+
+```php
+shape Base = array{value: string};
+shape Child extends Base = array{value: int};  // Override string to int
+
+// Child's 'value' is now int, not string
+```
+
+**Restrictions:**
+
+Shapes and classes are separate concepts and cannot be mixed in inheritance:
+
+- Shapes cannot extend classes
+- Classes cannot extend shapes
+
+These restrictions are enforced at **compile time** with clear error messages:
+
+```php
+// Shape trying to extend a class
+class MyClass {}
+shape BadShape extends MyClass = array{id: int};
+// Fatal error: Shape BadShape cannot extend class MyClass
+
+// Class trying to extend a shape
+shape MyShape = array{id: int, name: string};
+class BadClass extends MyShape {}
+// Fatal error: Class BadClass cannot extend shape MyShape
+```
+
+#### The `::shape` Syntax
+
+Similar to `::class` for classes, shapes support the `::shape` syntax to get
+the fully qualified name of a shape:
+
+```php
+shape UserShape = array{id: int, name: string};
+
+echo UserShape::shape;  // "UserShape"
+```
+
+With namespaces:
+
+```php
+namespace App\Types;
+
+shape UserShape = array{id: int, name: string};
+
+echo UserShape::shape;  // "App\Types\UserShape"
+```
+
+This is useful for logging, debugging, and working with shape names dynamically.
+
+**Note:** Using `::shape` on a class results in a compile error:
+
+```php
+class MyClass {}
+echo MyClass::shape;  // Error: Cannot use ::shape on class MyClass, use ::class instead
+```
+
+#### Shape Autoloading
+
+Shapes can be autoloaded using the standard `spl_autoload_register()` mechanism:
+
+```php
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// UserShape is autoloaded when first used
+function getUser(): UserShape { ... }
+```
+
+#### shape_exists() Function
+
+Check if a shape type alias is defined:
+
+```php
+// Check without triggering autoload
+if (shape_exists('User', false)) { ... }
+
+// Check with autoloading (default)
+if (shape_exists('User')) { ... }
+```
+
+## Runtime Behavior
+
+### Always-On Validation
+
+Typed array and array shape validation is **always enabled**. When a type constraint
+is declared, it is enforced at runtime:
+
+```php
+function getIds(): array<int> {
+    return [1, "two", 3];  // TypeError at runtime
+}
+
+function getUser(): array{id: int, name: string} {
+    return ['id' => 1];  // TypeError: missing required key 'name'
+}
+```
+
+### Error Messages
+
+Type errors provide detailed, actionable information:
+
+```php
+// For typed arrays
+TypeError: getIds(): Return value must be of type array<int>,
+           array element at index 1 is string
+
+// For array shapes - missing key
+TypeError: getUser(): Return value must be of type array{name: string, ...},
+           array given with missing key "name"
+
+// For array shapes - wrong type
+TypeError: getUser(): Return value must be of type array{id: int, ...},
+           array key "id" is string
+```
+
+## Reflection API
+
+New reflection classes provide runtime introspection:
+
+### ReflectionArrayShapeType
+
+```php
+$ref = new ReflectionFunction('getUser');
+$type = $ref->getReturnType();
+
+if ($type instanceof ReflectionArrayShapeType) {
+    echo $type->getElementCount();          // Number of elements
+    echo $type->getRequiredElementCount();  // Required elements only
+
+    foreach ($type->getElements() as $element) {
+        echo $element->getName();      // Key name
+        echo $element->getType();      // Element type
+        echo $element->isOptional();   // Is optional?
+    }
+}
+```
+
+### ReflectionTypedArrayType
+
+```php
+if ($type instanceof ReflectionTypedArrayType) {
+    echo $type->getElementType();  // Element type (e.g., "int")
+    echo $type->getKeyType();      // Key type for array<K,V>
+}
+```
+
+## Syntax Grammar
+
+```
+array_type:
+    'array' '<' type_list '>'                    // array<T> or array<K,V>
+  | 'array' '{' shape_element_list '}'           // array{...}
+  ;
+
+shape_element_list:
+    shape_element (',' shape_element)* ','?
+  ;
+
+shape_element:
+    T_STRING '?'? ':' type                       // key?: type
+  ;
+
+shape_declaration:
+    'shape' T_STRING shape_extends? '=' array_type ';'
+  ;
+
+shape_extends:
+    'extends' name                               // shape inheritance
+  ;
+
+shape_name_access:
+    name '::' 'shape'                            // MyShape::shape
+  ;
+```
+
+## Comparison with Existing Solutions
+
+### PHPDoc Annotations
+
+```php
+/** @return array{id: int, name: string} */
+function getUser(): array { ... }
+```
+
+**Limitations:**
+- No runtime validation
+- Inconsistent syntax across tools
+- Separated from actual code
+
+### This Proposal
+
+```php
+function getUser(): array{id: int, name: string} { ... }
+```
+
+**Benefits:**
+- Native language syntax
+- Optional runtime validation
+- IDE support via reflection
+- Consistent across all tools
+
+## Implementation Notes
+
+### Compile-Time Validation
+
+The compiler performs several validations at compile time to catch errors early:
+
+| Error Condition | Error Message |
+|----------------|---------------|
+| Shape extends a class | `Shape X cannot extend class Y` |
+| Class extends a shape | `Class X cannot extend shape Y` |
+| Shape redeclaration | `Cannot redeclare shape X` |
+| `::shape` used on a class | `Cannot use ::shape on class X, use ::class instead` |
+| `::class` used on a shape | `Cannot use ::class on shape X, use ::shape instead` |
+
+These compile-time checks ensure that shape inheritance and naming syntax are used correctly, providing immediate feedback during development rather than runtime errors.
+
+### Compile-Time Optimization
+
+The implementation uses escape analysis to optimize constant array validation
+at compile time, avoiding runtime overhead where possible.
+
+### Memory Considerations
+
+Shape type information is stored efficiently:
+- Inline shapes store structure in the type itself
+- Shape aliases store a reference to a global shape table
+- Shapes are interned and shared across functions
+
+### Autoloading Integration
+
+Shape autoloading uses the existing `spl_autoload` infrastructure:
+- Same autoloader handles both classes and shapes
+- Recursive autoload protection
+- Thread-safe implementation
+
+## Backward Compatibility
+
+This proposal is fully backward compatible:
+
+1. New syntax is opt-in via return/parameter type declarations
+2. Existing code without typed array syntax continues to work unchanged
+3. `shape` is a new keyword only valid at file scope for shape declarations
+4. Plain `array` type hints remain valid and unaffected
+
+## Future Scope
+
+Potential future enhancements (not part of this RFC):
+
+1. **Class property types**: `public User $user;`
+2. **Readonly shapes**: Immutable array structures
+3. **Generic shapes**: `shape Result<T> = array{success: bool, data: T}`
+
+**Note:** Shape inheritance (`shape Admin extends User`) and the `::shape` syntax
+are now implemented and documented above.
+
+## Examples
+
+### API Response
+
+```php
+shape ApiResponse = array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    meta: array{timestamp: string, version: string}
+};
+
+function apiSuccess(mixed $data): ApiResponse {
+    return [
+        'success' => true,
+        'data' => $data,
+        'error' => null,
+        'meta' => ['timestamp' => date('c'), 'version' => '1.0']
+    ];
+}
+```
+
+### Configuration
+
+```php
+shape DatabaseConfig = array{
+    host: string,
+    port: int,
+    database: string,
+    username: string,
+    password: string,
+    options?: array<string, mixed>
+};
+
+shape AppConfig = array{
+    debug: bool,
+    environment: string,
+    database: DatabaseConfig,
+    cache: array{driver: string, ttl: int}
+};
+
+function loadConfig(string $path): AppConfig { ... }
+```
+
+### Repository Pattern
+
+```php
+shape UserRecord = array{id: int, name: string, email: string, created_at: string};
+
+class UserRepository {
+    // Single record
+    public function find(int $id): ?UserRecord { ... }
+
+    // Collection of records — combining both features
+    public function findAll(): array<UserRecord> { ... }
+
+    public function save(UserRecord $user): UserRecord { ... }
+    public function delete(int $id): bool { ... }
+}
+```
+
+## Conclusion
+
+This RFC provides two complementary features for typed arrays in PHP:
+
+- **Typed Arrays** (`array<T>`) for collections of the same type
+- **Array Shapes** (`array{key: type}`) for structured data with known keys
+
+Together, they address a long-standing limitation in PHP's type system while
+maintaining full backward compatibility. These features are designed for working
+with arrays—not as a replacement for objects, but as a complement for the many
+situations where arrays are the right tool: database results, API responses,
+configuration files, and more.
+
+The implementation has been tested and all PHP tests pass.
diff --git a/examples/array-shapes/11-shape-type-aliases.php b/examples/array-shapes/11-shape-type-aliases.php
new file mode 100644
index 00000000..d5d338ce
--- /dev/null
+++ b/examples/array-shapes/11-shape-type-aliases.php
@@ -0,0 +1,209 @@
+<?php
+/**
+ * Example 11: Shape Type Aliases
+ *
+ * The `shape` keyword allows you to define reusable array structure type aliases.
+ * Shapes work similarly to typedefs or type aliases in other languages.
+ */
+declare(strict_arrays=1);
+
+echo "=== Shape Type Aliases ===\n\n";
+
+// ============================================================================
+// DEFINING SHAPES
+// ============================================================================
+
+echo "--- Defining Shapes ---\n";
+
+// Define a shape type alias for a User structure
+shape User = array{id: int, name: string, email: string};
+
+// Define a shape for a Point
+shape Point = array{x: int, y: int};
+
+// Define a shape with optional keys
+shape Config = array{debug: bool, env: string, cache_ttl?: int};
+
+// Shapes can include nullable types
+shape ApiResponse = array{success: bool, data: mixed, error: ?string};
+
+echo "Defined shapes: User, Point, Config, ApiResponse\n\n";
+
+// ============================================================================
+// USING SHAPES IN FUNCTION SIGNATURES
+// ============================================================================
+
+echo "--- Using Shapes in Functions ---\n";
+
+// Use shape as return type
+function createUser(int $id, string $name, string $email): User {
+    return [
+        'id' => $id,
+        'name' => $name,
+        'email' => $email
+    ];
+}
+
+// Use shape as parameter type
+function processUser(User $user): void {
+    echo "Processing user: {$user['name']} (ID: {$user['id']})\n";
+}
+
+// Multiple shapes in signature
+function calculateDistance(Point $a, Point $b): float {
+    $dx = $b['x'] - $a['x'];
+    $dy = $b['y'] - $a['y'];
+    return sqrt($dx * $dx + $dy * $dy);
+}
+
+$user = createUser(1, 'Alice', 'alice@example.com');
+processUser($user);
+var_dump($user);
+
+$pointA = ['x' => 0, 'y' => 0];
+$pointB = ['x' => 3, 'y' => 4];
+$distance = calculateDistance($pointA, $pointB);
+echo "Distance: $distance\n\n";
+
+// ============================================================================
+// SHAPES WITH OPTIONAL KEYS
+// ============================================================================
+
+echo "--- Shapes with Optional Keys ---\n";
+
+function getConfig(bool $useCache = false): Config {
+    $config = [
+        'debug' => true,
+        'env' => 'development'
+    ];
+
+    if ($useCache) {
+        $config['cache_ttl'] = 3600;
+    }
+
+    return $config;
+}
+
+$minimalConfig = getConfig(false);
+$fullConfig = getConfig(true);
+
+echo "Minimal config:\n";
+var_dump($minimalConfig);
+
+echo "Full config:\n";
+var_dump($fullConfig);
+echo "\n";
+
+// ============================================================================
+// SHAPES IN CLASSES
+// ============================================================================
+
+echo "--- Shapes in Classes ---\n";
+
+// Define shapes for class usage
+shape ProductData = array{id: int, name: string, price: float, stock?: int};
+
+class ProductRepository {
+    private array $products = [];
+
+    public function save(ProductData $product): void {
+        $this->products[$product['id']] = $product;
+        echo "Saved product: {$product['name']}\n";
+    }
+
+    public function find(int $id): ?ProductData {
+        return $this->products[$id] ?? null;
+    }
+
+    /** @return array<ProductData> */
+    public function all(): array {
+        return array_values($this->products);
+    }
+}
+
+$repo = new ProductRepository();
+$repo->save(['id' => 1, 'name' => 'Widget', 'price' => 29.99, 'stock' => 100]);
+$repo->save(['id' => 2, 'name' => 'Gadget', 'price' => 49.99]);
+
+$product = $repo->find(1);
+if ($product) {
+    echo "Found: {$product['name']} - \${$product['price']}\n";
+}
+echo "\n";
+
+// ============================================================================
+// NESTED SHAPES
+// ============================================================================
+
+echo "--- Nested Shapes ---\n";
+
+// Shapes can reference other shapes
+shape Address = array{street: string, city: string, zip: string};
+shape Person = array{name: string, age: int, address: Address};
+
+function describePerson(Person $person): string {
+    return sprintf(
+        "%s, age %d, lives at %s, %s %s",
+        $person['name'],
+        $person['age'],
+        $person['address']['street'],
+        $person['address']['city'],
+        $person['address']['zip']
+    );
+}
+
+$person = [
+    'name' => 'Bob',
+    'age' => 30,
+    'address' => [
+        'street' => '123 Main St',
+        'city' => 'Springfield',
+        'zip' => '12345'
+    ]
+];
+
+echo describePerson($person) . "\n\n";
+
+// ============================================================================
+// SHAPES WITH TYPED ARRAYS
+// ============================================================================
+
+echo "--- Shapes with Typed Arrays ---\n";
+
+// Shape containing typed arrays
+shape TeamData = array{
+    name: string,
+    members: array<string>,
+    scores: array<int>
+};
+
+function printTeam(TeamData $team): void {
+    echo "Team: {$team['name']}\n";
+    echo "Members: " . implode(', ', $team['members']) . "\n";
+    echo "Scores: " . implode(', ', $team['scores']) . "\n";
+}
+
+$team = [
+    'name' => 'Alpha Squad',
+    'members' => ['Alice', 'Bob', 'Charlie'],
+    'scores' => [95, 87, 92]
+];
+
+printTeam($team);
+echo "\n";
+
+// ============================================================================
+// CHECKING SHAPE EXISTENCE
+// ============================================================================
+
+echo "--- Checking Shape Existence ---\n";
+
+// Use shape_exists() to check if a shape is defined
+echo "User shape exists: " . (shape_exists('User') ? 'yes' : 'no') . "\n";
+echo "Point shape exists: " . (shape_exists('Point') ? 'yes' : 'no') . "\n";
+echo "NonExistent shape exists: " . (shape_exists('NonExistent') ? 'yes' : 'no') . "\n";
+
+// Case-insensitive check
+echo "user (lowercase) exists: " . (shape_exists('user') ? 'yes' : 'no') . "\n";
+
+echo "\n=== Example Complete ===\n";
diff --git a/examples/array-shapes/12-shape-autoloading.php b/examples/array-shapes/12-shape-autoloading.php
new file mode 100644
index 00000000..124ea968
--- /dev/null
+++ b/examples/array-shapes/12-shape-autoloading.php
@@ -0,0 +1,206 @@
+<?php
+/**
+ * Example 12: Shape Autoloading
+ *
+ * Shapes can be autoloaded just like classes using spl_autoload_register().
+ * This enables modular code organization where shapes are defined in
+ * separate files and loaded on demand.
+ */
+declare(strict_arrays=1);
+
+echo "=== Shape Autoloading ===\n\n";
+
+// ============================================================================
+// SETUP: Create temporary shape files for demonstration
+// ============================================================================
+
+$tempDir = sys_get_temp_dir() . '/php_shape_example_' . getmypid();
+if (!is_dir($tempDir)) {
+    mkdir($tempDir, 0755, true);
+}
+
+// Create shape definition files
+file_put_contents($tempDir . '/UserShape.php', '<?php
+declare(strict_arrays=1);
+shape UserShape = array{id: int, username: string, email: string, active: bool};
+');
+
+file_put_contents($tempDir . '/OrderShape.php', '<?php
+declare(strict_arrays=1);
+shape OrderShape = array{
+    id: int,
+    user_id: int,
+    items: array<array{product: string, quantity: int, price: float}>,
+    total: float,
+    status: string
+};
+');
+
+file_put_contents($tempDir . '/ApiResponseShape.php', '<?php
+declare(strict_arrays=1);
+shape ApiResponseShape = array{
+    success: bool,
+    data: mixed,
+    error: ?string,
+    meta: array{timestamp: string, version: string}
+};
+');
+
+echo "Created shape files in: $tempDir\n\n";
+
+// ============================================================================
+// AUTOLOADER REGISTRATION
+// ============================================================================
+
+echo "--- Registering Autoloader ---\n";
+
+$autoloadedShapes = [];
+
+spl_autoload_register(function($name) use ($tempDir, &$autoloadedShapes) {
+    // Check if this looks like a shape (ends with 'Shape')
+    $file = "$tempDir/$name.php";
+    if (file_exists($file)) {
+        $autoloadedShapes[] = $name;
+        echo "  Autoloading: $name from $file\n";
+        require_once $file;
+        return true;
+    }
+    return false;
+});
+
+echo "Autoloader registered.\n\n";
+
+// ============================================================================
+// USING shape_exists() WITH AUTOLOADING
+// ============================================================================
+
+echo "--- Checking Shape Existence ---\n";
+
+// Without autoload (second parameter = false)
+echo "UserShape exists (no autoload): " .
+    (shape_exists('UserShape', false) ? 'yes' : 'no') . "\n";
+
+// With autoload (default behavior)
+echo "UserShape exists (with autoload): " .
+    (shape_exists('UserShape', true) ? 'yes' : 'no') . "\n";
+
+// Now it's loaded, so no-autoload check returns true
+echo "UserShape exists (no autoload, after load): " .
+    (shape_exists('UserShape', false) ? 'yes' : 'no') . "\n\n";
+
+// ============================================================================
+// USING AUTOLOADED SHAPES
+// ============================================================================
+
+echo "--- Using Autoloaded Shapes ---\n";
+
+// Function using autoloaded UserShape
+function createUser(int $id, string $username, string $email): UserShape {
+    return [
+        'id' => $id,
+        'username' => $username,
+        'email' => $email,
+        'active' => true
+    ];
+}
+
+$user = createUser(1, 'alice', 'alice@example.com');
+echo "Created user: {$user['username']}\n";
+var_dump($user);
+echo "\n";
+
+// ============================================================================
+// COMPLEX AUTOLOADED SHAPE
+// ============================================================================
+
+echo "--- Complex Autoloaded Shape (OrderShape) ---\n";
+
+function createOrder(int $id, int $userId, array $items): OrderShape {
+    $total = array_reduce($items, function($sum, $item) {
+        return $sum + ($item['quantity'] * $item['price']);
+    }, 0.0);
+
+    return [
+        'id' => $id,
+        'user_id' => $userId,
+        'items' => $items,
+        'total' => $total,
+        'status' => 'pending'
+    ];
+}
+
+$order = createOrder(101, 1, [
+    ['product' => 'Widget', 'quantity' => 2, 'price' => 29.99],
+    ['product' => 'Gadget', 'quantity' => 1, 'price' => 49.99]
+]);
+
+echo "Created order #{$order['id']} for user #{$order['user_id']}\n";
+echo "Total: \${$order['total']}\n";
+echo "Items:\n";
+foreach ($order['items'] as $item) {
+    echo "  - {$item['quantity']}x {$item['product']} @ \${$item['price']}\n";
+}
+echo "\n";
+
+// ============================================================================
+// API RESPONSE PATTERN
+// ============================================================================
+
+echo "--- API Response Shape ---\n";
+
+function apiSuccess(mixed $data): ApiResponseShape {
+    return [
+        'success' => true,
+        'data' => $data,
+        'error' => null,
+        'meta' => [
+            'timestamp' => date('c'),
+            'version' => '1.0.0'
+        ]
+    ];
+}
+
+function apiError(string $message): ApiResponseShape {
+    return [
+        'success' => false,
+        'data' => null,
+        'error' => $message,
+        'meta' => [
+            'timestamp' => date('c'),
+            'version' => '1.0.0'
+        ]
+    ];
+}
+
+$successResponse = apiSuccess(['users' => [$user]]);
+$errorResponse = apiError('User not found');
+
+echo "Success response:\n";
+var_dump($successResponse['success'], $successResponse['error']);
+
+echo "Error response:\n";
+var_dump($errorResponse['success'], $errorResponse['error']);
+echo "\n";
+
+// ============================================================================
+// SUMMARY
+// ============================================================================
+
+echo "--- Autoload Summary ---\n";
+echo "Shapes autoloaded during this example:\n";
+foreach ($autoloadedShapes as $shape) {
+    echo "  - $shape\n";
+}
+echo "\n";
+
+// ============================================================================
+// CLEANUP
+// ============================================================================
+
+unlink($tempDir . '/UserShape.php');
+unlink($tempDir . '/OrderShape.php');
+unlink($tempDir . '/ApiResponseShape.php');
+rmdir($tempDir);
+echo "Cleaned up temporary files.\n";
+
+echo "\n=== Example Complete ===\n";
diff --git a/examples/array-shapes/README.md b/examples/array-shapes/README.md
index cbd5d3e9..5bd1f44c 100644
--- a/examples/array-shapes/README.md
+++ b/examples/array-shapes/README.md
@@ -14,6 +14,45 @@ function getUser(): array{id: int, name: string, email?: string} {
 }
 ```
 
+## Shape Type Aliases
+
+The `shape` keyword lets you define reusable type aliases for array structures:
+
+```php
+declare(strict_arrays=1);
+
+// Define a shape type alias
+shape User = array{id: int, name: string, email: string};
+
+// Use it like a type
+function getUser(int $id): User {
+    return ['id' => $id, 'name' => 'Alice', 'email' => 'alice@example.com'];
+}
+
+function processUser(User $user): void {
+    echo "Hello, {$user['name']}!";
+}
+
+// Check if a shape exists
+if (shape_exists('User')) {
+    echo "User shape is defined";
+}
+```
+
+Shapes can be autoloaded just like classes:
+
+```php
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+
+// UserShape will be autoloaded from shapes/UserShape.php
+function getUser(): UserShape { ... }
+```
+
 ## Quick Reference
 
 ### Basic Syntax
@@ -93,6 +132,8 @@ interface ConfigProvider {
 | `08-reflection-api.php` | Runtime inspection with Reflection API |
 | `09-validation-and-errors.php` | Error handling and validation patterns |
 | `10-real-world-patterns.php` | Production-ready patterns and use cases |
+| `11-shape-type-aliases.php` | Defining reusable shapes with the `shape` keyword |
+| `12-shape-autoloading.php` | Autoloading shapes like classes |
 
 ## Running Examples
 
@@ -179,6 +220,72 @@ if ($returnType instanceof ReflectionArrayShapeType) {
 }
 ```
 
+## Shape Type Alias Details
+
+### Defining Shapes
+
+```php
+// Simple shape
+shape Point = array{x: int, y: int};
+
+// Shape with optional keys
+shape Config = array{debug: bool, env: string, cache_ttl?: int};
+
+// Shape with nullable values
+shape ApiResponse = array{success: bool, data: mixed, error: ?string};
+
+// Nested shapes (shapes can reference other shapes)
+shape Address = array{street: string, city: string, zip: string};
+shape Person = array{name: string, address: Address};
+
+// Shape with typed arrays
+shape Team = array{name: string, members: array<string>, scores: array<int>};
+```
+
+### Using Shapes
+
+```php
+// As return type
+function getUser(): User { ... }
+
+// As parameter type
+function processUser(User $user): void { ... }
+
+// In classes
+class UserRepository {
+    public function find(int $id): ?User { ... }
+    public function save(User $user): void { ... }
+}
+```
+
+### Shape Autoloading
+
+Shapes can be autoloaded using `spl_autoload_register()`:
+
+```php
+spl_autoload_register(function($name) {
+    $file = __DIR__ . "/shapes/$name.php";
+    if (file_exists($file)) {
+        require_once $file;
+    }
+});
+```
+
+### shape_exists() Function
+
+Check if a shape is defined:
+
+```php
+// Check without triggering autoload
+if (shape_exists('User', false)) { ... }
+
+// Check with autoloading (default)
+if (shape_exists('User')) { ... }
+
+// Case-insensitive
+shape_exists('user');  // Same as shape_exists('User')
+```
+
 ## Common Patterns
 
 ### API Response Wrapper
diff --git a/ext/opcache/zend_file_cache.c b/ext/opcache/zend_file_cache.c
index d430f483..6bd586e8 100644
--- a/ext/opcache/zend_file_cache.c
+++ b/ext/opcache/zend_file_cache.c
@@ -484,6 +484,34 @@ static void zend_file_cache_serialize_type(
 		SERIALIZE_STR(type_name);
 		ZEND_TYPE_SET_PTR(*type, type_name);
 	}
+
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		SERIALIZE_PTR(elem);
+		ZEND_TYPE_SET_PTR(*type, elem);
+		UNSERIALIZE_PTR(elem);
+		zend_file_cache_serialize_type(&elem->element_type, script, info, buf);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_file_cache_serialize_type(&elem->key_type, script, info, buf);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		SERIALIZE_PTR(shape);
+		ZEND_TYPE_SET_PTR(*type, shape);
+		UNSERIALIZE_PTR(shape);
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				SERIALIZE_STR(elem->key);
+			}
+			zend_file_cache_serialize_type(&elem->type, script, info, buf);
+		}
+	}
 }
 
 static void zend_file_cache_serialize_op_array(zend_op_array            *op_array,
@@ -1399,6 +1427,32 @@ static void zend_file_cache_unserialize_type(
 			zend_alloc_ce_cache(type_name);
 		}
 	}
+
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		UNSERIALIZE_PTR(elem);
+		ZEND_TYPE_SET_PTR(*type, elem);
+		zend_file_cache_unserialize_type(&elem->element_type, scope, script, buf);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_file_cache_unserialize_type(&elem->key_type, scope, script, buf);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		UNSERIALIZE_PTR(shape);
+		ZEND_TYPE_SET_PTR(*type, shape);
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				UNSERIALIZE_STR(elem->key);
+			}
+			zend_file_cache_unserialize_type(&elem->type, scope, script, buf);
+		}
+	}
 }
 
 static void zend_file_cache_unserialize_op_array(zend_op_array           *op_array,
diff --git a/ext/opcache/zend_persist.c b/ext/opcache/zend_persist.c
index 38e58d5a..a201117e 100644
--- a/ext/opcache/zend_persist.c
+++ b/ext/opcache/zend_persist.c
@@ -371,6 +371,40 @@ static void zend_persist_type(zend_type *type) {
 		ZEND_TYPE_SET_PTR(*type, list);
 	}
 
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		if (!zend_accel_in_shm(elem)) {
+			elem = zend_shared_memdup_put(elem, sizeof(zend_typed_array_element));
+			ZEND_TYPE_SET_PTR(*type, elem);
+		}
+		/* Recursively persist element and key types */
+		zend_persist_type(&elem->element_type);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_persist_type(&elem->key_type);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		if (!zend_accel_in_shm(shape)) {
+			size_t shape_size = sizeof(zend_array_shape)
+				+ shape->num_elements * sizeof(zend_array_shape_element);
+			shape = zend_shared_memdup_put(shape, shape_size);
+			ZEND_TYPE_SET_PTR(*type, shape);
+		}
+		/* Persist each element's key string and type */
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				zend_accel_store_interned_string(elem->key);
+			}
+			zend_persist_type(&elem->type);
+		}
+	}
+
 	zend_type *single_type;
 	ZEND_TYPE_FOREACH_MUTABLE(*type, single_type) {
 		if (ZEND_TYPE_HAS_LIST(*single_type)) {
diff --git a/ext/opcache/zend_persist_calc.c b/ext/opcache/zend_persist_calc.c
index 106a69f5..74ad1129 100644
--- a/ext/opcache/zend_persist_calc.c
+++ b/ext/opcache/zend_persist_calc.c
@@ -201,6 +201,30 @@ static void zend_persist_type_calc(zend_type *type)
 		ADD_SIZE(ZEND_TYPE_LIST_SIZE(ZEND_TYPE_LIST(*type)->num_types));
 	}
 
+	/* Handle typed array (array<T> or array<K, V>) */
+	if ((type->type_mask & (1u << IS_ARRAY)) && type->ptr != NULL
+		&& !ZEND_TYPE_IS_COMPLEX(*type) && !ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_typed_array_element *elem = ZEND_TYPED_ARRAY_ELEMENT(*type);
+		ADD_SIZE(sizeof(zend_typed_array_element));
+		zend_persist_type_calc(&elem->element_type);
+		if (ZEND_TYPE_IS_SET(elem->key_type)) {
+			zend_persist_type_calc(&elem->key_type);
+		}
+	}
+
+	/* Handle array shape (array{key: type, ...}) */
+	if (ZEND_TYPE_HAS_ARRAY_SHAPE(*type)) {
+		zend_array_shape *shape = ZEND_ARRAY_SHAPE(*type);
+		ADD_SIZE(sizeof(zend_array_shape) + shape->num_elements * sizeof(zend_array_shape_element));
+		for (uint32_t i = 0; i < shape->num_elements; i++) {
+			zend_array_shape_element *elem = &shape->elements[i];
+			if (elem->key) {
+				ADD_INTERNED_STRING(elem->key);
+			}
+			zend_persist_type_calc(&elem->type);
+		}
+	}
+
 	zend_type *single_type;
 	ZEND_TYPE_FOREACH_MUTABLE(*type, single_type) {
 		if (ZEND_TYPE_HAS_LIST(*single_type)) {
diff --git a/ext/reflection/php_reflection.c b/ext/reflection/php_reflection.c
index db205a43..585e7972 100644
--- a/ext/reflection/php_reflection.c
+++ b/ext/reflection/php_reflection.c
@@ -3423,6 +3423,23 @@ ZEND_METHOD(ReflectionArrayShapeType, getRequiredElementCount)
 }
 /* }}} */
 
+/* {{{ Returns whether this is a closed shape (no extra keys allowed) */
+ZEND_METHOD(ReflectionArrayShapeType, isClosed)
+{
+	reflection_object *intern;
+	type_reference *param;
+	zend_array_shape *shape;
+
+	ZEND_PARSE_PARAMETERS_NONE();
+	GET_REFLECTION_OBJECT_PTR(param);
+
+	ZEND_ASSERT(ZEND_TYPE_HAS_ARRAY_SHAPE(param->type));
+	shape = ZEND_ARRAY_SHAPE(param->type);
+
+	RETURN_BOOL(shape->is_closed);
+}
+/* }}} */
+
 /* {{{ Returns the key name of this array shape element */
 ZEND_METHOD(ReflectionArrayShapeElement, getName)
 {
diff --git a/ext/reflection/php_reflection.stub.php b/ext/reflection/php_reflection.stub.php
index 35b4270c..bcca2c4f 100644
--- a/ext/reflection/php_reflection.stub.php
+++ b/ext/reflection/php_reflection.stub.php
@@ -767,6 +767,9 @@ public function getElementCount(): int {}
 
     /** Get the number of required (non-optional) elements */
     public function getRequiredElementCount(): int {}
+
+    /** Check if this is a closed shape (no extra keys allowed) */
+    public function isClosed(): bool {}
 }
 
 /** Represents an element in an array shape type */
diff --git a/ext/reflection/php_reflection_arginfo.h b/ext/reflection/php_reflection_arginfo.h
index d9eb0ecd..32e9589d 100644
Binary files a/ext/reflection/php_reflection_arginfo.h and b/ext/reflection/php_reflection_arginfo.h differ
diff --git a/ext/tokenizer/tokenizer_data.c b/ext/tokenizer/tokenizer_data.c
index 0900c51d..61b9acf1 100644
--- a/ext/tokenizer/tokenizer_data.c
+++ b/ext/tokenizer/tokenizer_data.c
@@ -105,11 +105,13 @@ char *get_token_type_name(int token_type)
 		case T_TRAIT: return "T_TRAIT";
 		case T_INTERFACE: return "T_INTERFACE";
 		case T_ENUM: return "T_ENUM";
+		case T_SHAPE: return "T_SHAPE";
 		case T_EXTENDS: return "T_EXTENDS";
 		case T_IMPLEMENTS: return "T_IMPLEMENTS";
 		case T_NAMESPACE: return "T_NAMESPACE";
 		case T_LIST: return "T_LIST";
 		case T_ARRAY: return "T_ARRAY";
+		case T_ARRAY_SHAPE_START: return "T_ARRAY_SHAPE_START";
 		case T_CALLABLE: return "T_CALLABLE";
 		case T_LINE: return "T_LINE";
 		case T_FILE: return "T_FILE";
diff --git a/ext/tokenizer/tokenizer_data.stub.php b/ext/tokenizer/tokenizer_data.stub.php
index 57c8edad..07ba208f 100644
--- a/ext/tokenizer/tokenizer_data.stub.php
+++ b/ext/tokenizer/tokenizer_data.stub.php
@@ -402,6 +402,11 @@
  * @cvalue T_ENUM
  */
 const T_ENUM = UNKNOWN;
+/**
+ * @var int
+ * @cvalue T_SHAPE
+ */
+const T_SHAPE = UNKNOWN;
 /**
  * @var int
  * @cvalue T_EXTENDS
@@ -427,6 +432,11 @@
  * @cvalue T_ARRAY
  */
 const T_ARRAY = UNKNOWN;
+/**
+ * @var int
+ * @cvalue T_ARRAY_SHAPE_START
+ */
+const T_ARRAY_SHAPE_START = UNKNOWN;
 /**
  * @var int
  * @cvalue T_CALLABLE
diff --git a/ext/tokenizer/tokenizer_data_arginfo.h b/ext/tokenizer/tokenizer_data_arginfo.h
index 3a3cdaa4..90d409f0 100644
Binary files a/ext/tokenizer/tokenizer_data_arginfo.h and b/ext/tokenizer/tokenizer_data_arginfo.h differ
